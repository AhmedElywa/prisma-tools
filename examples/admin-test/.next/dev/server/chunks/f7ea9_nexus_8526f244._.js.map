{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/messages.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/messages.ts"],"sourcesContent":["export const messages = {\n  /* istanbul ignore next */\n  removedDeclarativeWrapping: (location: string, used: string[]) => `\\\n[declarativeWrappingPlugin]: The ${used.join(' / ')} object prop${\n    used.length > 1 ? 's' : ''\n  } used in the ${location} has been\nmoved to a plugin, as improved chaining APIs and the list() / nonNull() helpers functions are preferred.\n\nOn Fields: \n\nt.string('someField', { nullable: false })   ->    t.nonNull.string('someField')\n\nOn args: \n\nstringArg({ required: true })    ->    nonNull(stringArg())\n\nIf you would like to incrementally migrate, or prefer the existing API, it is now supported via the declarativeWrappingPlugin. \nAdd this to your plugins array in your makeSchema config:\n\nmakeSchema({\n  plugins: [declarativeWrappingPlugin(), ...]\n})\n`,\n\n  removedDeclarativeWrappingShort: (location: string, used: string[]) => `\\\n[declarativeWrappingPlugin]: Additional warning for ${used.join(\n    ' / '\n  )} at ${location}. Add the declarativeWrappingPlugin() to the plugins array to disable this message.\n`,\n  /* istanbul ignore next */\n  removedFunctionShorthand: (typeName: string, fieldName: string) =>\n    `Since v0.18.0, Nexus no longer supports resolver shorthands like:\\n\\n    t.string(\"${fieldName}\", () => ...).\\n\\nInstead please write:\\n\\n    t.string(\"${fieldName}\", { resolve: () => ... })\\n\\n.`,\n}\n"],"names":[],"mappings":";;;;AAAO,MAAM,QAAQ,GAAG;IACtB,wBAAA,EAA0B,CAC1B,0BAA0B,EAAE,CAAC,QAAgB,EAAE,IAAc,EAAE,CAAG,CAAD,AAAC;mCACjC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA,YAAA,EAC/C,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAC1B,CAAA,aAAA,EAAgB,QAAQ,CAAA;;;;;;;;;;;;;;;;;CAiBzB;IAEC,+BAA+B,EAAE,CAAC,QAAgB,EAAE,IAAc,EAAE,CAAG,CAAD,AAAC;sDACnB,IAAI,CAAC,IAAI,CAC3D,KAAK,CACN,CAAA,IAAA,EAAO,QAAQ,CAAA;CACjB;IACC,wBAAA,EAA0B,CAC1B,wBAAwB,EAAE,CAAC,QAAgB,EAAE,SAAiB,EAAE,CAC9D,CADgE,AAChE,mFAAA,EAAsF,SAAS,CAAA,yDAAA,EAA4D,SAAS,CAAA,+BAAA,CAAiC;CACxM,CAAA"}},
    {"offset": {"line": 37, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/definitions/definitionBlocks.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/definitions/definitionBlocks.ts"],"sourcesContent":["import type { GraphQLFieldConfig, GraphQLFieldResolver, GraphQLInputFieldConfig } from 'graphql'\nimport { messages } from '../messages'\nimport type {\n  AllInputTypes,\n  FieldResolver,\n  GetGen,\n  GetGen3,\n  HasGen3,\n  NeedsResolver,\n} from '../typegenTypeHelpers'\nimport type { ArgsRecord } from './args'\nimport type { NexusMetaType } from './nexusMeta'\nimport type { AllNexusInputTypeDefs, AllNexusOutputTypeDefs, NexusWrapKind } from './wrapping'\nimport type { BaseScalars, Maybe } from './_types'\n\nexport interface CommonFieldConfig {\n  /** The description to annotate the GraphQL SDL */\n  description?: Maybe<string>\n  /**\n   * Info about a field deprecation. Formatted as a string and provided with the deprecated directive on\n   * field/enum types and as a comment on input fields.\n   */\n  deprecation?: Maybe<string> // | DeprecationInfo;\n}\n\nexport type CommonOutputFieldConfig<TypeName extends string, FieldName extends string> = CommonFieldConfig & {\n  /**\n   * [GraphQL.org Docs](https://graphql.github.io/learn/schema/#arguments) | [GraphQL 2018\n   * Spec](https://spec.graphql.org/June2018/#sec-Language.Arguments)\n   *\n   * Define arguments for this field.\n   *\n   * All fields in GraphQL can have arguments defined for them. Nexus provides a number of helpers for\n   * defining arguments. All builtin GraphQL scalar types have helpers named \"{scalarName}Arg\" such as\n   * \"stringArg\" and \"intArg\". You can also use type modifier helpers \"[list](https://nxs.li/docs/api/list)\"\n   * \"[nullable](https://nxs.li/docs/api/nullable)\" and \"[nonNull](https://nxs.li/docs/api/nonNull)\". For\n   * details about nonNull/nullable refer to the [nullability guide](https://nxs.li/guides/nullability).\n   *\n   * @example\n   *   export const Mutation = mutationType({\n   *     definition(t) {\n   *       t.field('createDraft', {\n   *         type: 'Post',\n   *         args: {\n   *           title: nonNull(stringArg()),\n   *           body: nonNull(stringArg()),\n   *         },\n   *         // ...\n   *       })\n   *     },\n   *   })\n   *\n   * @example\n   *   export const Mutation = mutationType({\n   *     definition(t) {\n   *       t.field('createDraft', {\n   *         type: 'Post',\n   *         args: {\n   *           title: arg({\n   *             type: 'String',\n   *             default: 'Untitled',\n   *             description: 'The title of this draft post.',\n   *           }),\n   *           body: nonNull(\n   *             arg({\n   *               type: 'String',\n   *               description: 'The content of this draft post.',\n   *             })\n   *           ),\n   *         },\n   *         // ...\n   *       })\n   *     },\n   *   })\n   */\n  args?: Maybe<ArgsRecord>\n  /**\n   * Data that will be added to the field-level [extensions field on the graphql-js type def\n   * instances](https://github.com/graphql/graphql-js/issues/1527) resulting from makeSchema. Useful for some\n   * graphql-js based tools like [join-monster](https://github.com/join-monster/join-monster) which rely on\n   * looking for special data here.\n   *\n   * @example\n   *   // taken from: https://github.com/graphql-nexus/schema/issues/683#issuecomment-735711640\n   *\n   *   const User = objectType({\n   *     name: 'User',\n   *     extensions: {\n   *       joinMonster: {\n   *         sqlTable: 'USERS',\n   *         uniqueKey: 'USER_ID',\n   *       },\n   *     },\n   *     definition(t) {\n   *       t.id('id', {\n   *         extensions: {\n   *           joinMonster: {\n   *             sqlColumn: 'USER_ID',\n   *           },\n   *         },\n   *       })\n   *     },\n   *   })\n   */\n  extensions?: GraphQLFieldConfig<any, any>['extensions']\n} & NexusGenPluginFieldConfig<TypeName, FieldName>\n\nexport type CommonInputFieldConfig<TypeName extends string, FieldName extends string> = CommonFieldConfig & {\n  /** The default value for the field, if any */\n  default?: GetGen3<'inputTypes', TypeName, FieldName>\n  /**\n   * Data that will be added to the field-level [extensions field on the graphql-js type def\n   * instances](https://github.com/graphql/graphql-js/issues/1527) resulting from makeSchema. Useful for some\n   * graphql-js based tools which rely on looking for special data here.\n   */\n  extensions?: GraphQLInputFieldConfig['extensions']\n} & NexusGenPluginFieldConfig<TypeName, FieldName> &\n  NexusGenPluginInputFieldConfig<TypeName, FieldName>\nexport interface OutputScalarConfig<TypeName extends string, FieldName extends string>\n  extends CommonOutputFieldConfig<TypeName, FieldName> {\n  /**\n   * [GraphQL.org Docs](https://graphql.org/learn/execution/#root-fields-resolvers)\n   *\n   * The actual implementation for this field.\n   *\n   * Every field has a resolver and they are the basis for resolving queries at runtime. You do not need to\n   * explicitly implement every resolver however. If the [source typing](https://nxs.li/guides/backing-types) includes:\n   *\n   * 1. A field whose name matches this one 2. And whose type is compatible 3. And is a scalar\n   *\n   * ...then the default resolver will be available, whose behaviour is to simply return that field from the\n   * received source type.\n   *\n   * @example\n   *   export const Query = queryType({\n   *     definition(t) {\n   *       t.list.field('posts', {\n   *         type: 'Post',\n   *         resolve(_, __, ctx) {\n   *           return ctx.db.post.findMany({ where: { published: true } })\n   *         },\n   *       })\n   *     },\n   *   })\n   *\n   * @param source The [source data](https://nxs.li/guides/source-types) for the GraphQL object that this\n   *     field belongs to, unless this is a root field (any field on a [root operation\n   *     type](https://spec.graphql.org/June2018/#sec-Root-Operation-Types): Query, Mutation, Subscription),\n   *     in which case there is no source data and this will be undefined.\n   * @param args If you have defined arguments on this field then this parameter will contain any arguments\n   *     passed by the client. If you specified default values for any arguments and the client did not\n   *     explicitly pass *any* value (including null) for those arguments then you will see the defaults here.\n   *\n   * Note that thanks to [Nexus' reflection system](https://nxs.li/guides/reflection) this parameter's type\n   *     will always be type safe.\n   * @param context The context data for this request.\n   *\n   * The context data is typically a singleton scoped to the lifecycle of the request. This means created at\n   *     the beginning of a request and then passed to all the resolvers that execute while resolving the\n   *     request. It is often used to store information like the current user making the request. Nexus is\n   *     not responsible for this however. That is typically something you'll do with e.g.\n   *     [Mercurius](https://mercurius.dev) or [Apollo\n   *     Server](https://apollographql.com/docs/apollo-server/api/apollo-server).\n   *\n   * Note that the type here will be whatever you have specified for \"contextType\" in your makeSchema configuration.\n   * @param info The GraphQL resolve info.\n   *\n   * This is an advanced parameter seldom used. It includes things like the AST of the [GraphQL\n   *     document](https://spec.graphql.org/June2018/#sec-Language.Document) sent by the client.\n   */\n  resolve?: FieldResolver<TypeName, FieldName>\n}\n\n// prettier-ignore\nexport interface NexusOutputFieldConfig<TypeName extends string, FieldName extends string> extends OutputScalarConfig<TypeName, FieldName> {\n  /**\n   * [GraphQL 2018 Spec](https://spec.graphql.org/June2018/#sec-Types)\n   *\n   * The type that this field should be.\n   *\n   * Object type fields may be typed as scalars or other output types in your schema, often object types. They\n   * may also use type modifiers like list and non-null types.\n   *\n   * Types may be expressed in one of three ways:\n   *\n   * 1. As string literals matching the name of a builtin scalar.\n   *\n   * 2. As string literals matching the name of another type. Thanks to [Nexus' reflection\n   * system](https://nxs.li/guides/reflection) this is typesafe and autocompletable. This is the idiomatic\n   * approach in Nexus because it avoids excessive importing and circular references.\n   *\n   * 3. As references to other enums or object type definitions.\n   *\n   * You may also use type modifier helpers like list() and nonNull() which in turn accept one of the three\n   * methods listed above.\n   *\n   * Note that both type modifier and scalar helpers are available as chainable shorthands which you can see\n   * in the examples below.\n   *\n   * @example\n   *   objectType({\n   *     name: 'User',\n   *     definition(t) {\n   *       t.field('location', {\n   *         // reference the friend type via typegen\n   *         type: 'Location',\n   *       })\n   *     },\n   *   })\n   *\n   * @example\n   *   objectType({\n   *     name: 'User',\n   *     definition(t) {\n   *       t.field('location', {\n   *         // reference the friend type via type def reference\n   *         type: Location,\n   *       })\n   *     },\n   *   })\n   *\n   * @example\n   *   objectType({\n   *     name: 'User',\n   *     definition(t) {\n   *       t.field('friends', {\n   *         // create a non-null list of non-null friends\n   *         // using typegen type referencing\n   *         type: nonNull(list(nonNull('Friend'))),\n   *       })\n   *     },\n   *   })\n   *\n   * @example\n   *   objectType({\n   *     name: 'User',\n   *     definition(t) {\n   *       // create a non-null list of non-null friends\n   *       // using chaining API and typegen type referencing\n   *       t.nonNull.list.nonNull.field('friends', {\n   *         type: 'Friend',\n   *       })\n   *     },\n   *   })\n   *\n   * @example\n   *   objectType({\n   *     name: 'User',\n   *     definition(t) {\n   *       t.field('friends', {\n   *         // create a non-null list of non-null friends\n   *         // using type def referencing\n   *         type: nonNull(list(nonNull(Friend))),\n   *       })\n   *     },\n   *   })\n   *\n   * @example\n   *   objectType({\n   *     name: 'User',\n   *     definition(t) {\n   *       t.field('id', {\n   *         // Refer to builtin scalars by string reference\n   *         type: 'ID',\n   *       })\n   *     },\n   *   })\n   */\n  type: GetGen<'allOutputTypes', string> | AllNexusOutputTypeDefs | NexusMetaType\n}\n\n// prettier-ignore\nexport interface NexusOutputFieldConfigWithName<TypeName extends string, FieldName extends string> extends NexusOutputFieldConfig<TypeName, FieldName> {\n  /**\n   * The name of this field. Must conform to the regex pattern: [_A-Za-z][_0-9A-Za-z]*\n   */\n  name: FieldName\n}\n\nexport type NexusOutputFieldDef = NexusOutputFieldConfig<string, any> & {\n  name: string\n  configFor: 'outputField'\n  parentType: string\n  subscribe?: GraphQLFieldResolver<any, any>\n  wrapping?: NexusWrapKind[]\n}\n\n// prettier-ignore\nexport type ScalarOutSpread<TypeName extends string, FieldName extends string> =\n  NeedsResolver<TypeName, FieldName> extends true\n    ? [ScalarOutConfig<TypeName, FieldName>]\n    : HasGen3<'argTypes', TypeName, FieldName> extends true\n      ? [ScalarOutConfig<TypeName, FieldName>]\n      : [ScalarOutConfig<TypeName, FieldName>] | []\n\n// prettier-ignore\nexport type ScalarOutConfig<TypeName extends string, FieldName extends string> =\n  NeedsResolver<TypeName, FieldName> extends true\n    ? OutputScalarConfig<TypeName, FieldName> &\n      {\n        resolve: FieldResolver<TypeName, FieldName>\n      }\n    : OutputScalarConfig<TypeName, FieldName>\n\n// prettier-ignore\nexport type FieldOutConfig<TypeName extends string, FieldName extends string> =\n  NeedsResolver<TypeName, FieldName> extends true\n    ? NexusOutputFieldConfig<TypeName, FieldName> & {\n        resolve: FieldResolver<TypeName, FieldName>\n      }\n    : NexusOutputFieldConfig<TypeName, FieldName>\n\n// prettier-ignore\nexport type FieldOutConfigWithName<TypeName extends string, FieldName extends string> =\n  NeedsResolver<TypeName, FieldName> extends true\n    ? NexusOutputFieldConfigWithName<TypeName, FieldName> & {\n        resolve: FieldResolver<TypeName, FieldName>\n      }\n    : NexusOutputFieldConfigWithName<TypeName, FieldName>\n\nexport interface OutputDefinitionBuilder {\n  typeName: string\n  addField(config: NexusOutputFieldDef): void\n  addDynamicOutputMembers(block: OutputDefinitionBlock<any>, wrapping?: NexusWrapKind[]): void\n  warn(msg: string): void\n}\n\nexport interface InputDefinitionBuilder {\n  typeName: string\n  addField(config: NexusInputFieldDef): void\n  addDynamicInputFields(block: InputDefinitionBlock<any>, wrapping?: NexusWrapKind[]): void\n  warn(msg: string): void\n}\n\n// prettier-ignore\nexport interface OutputDefinitionBlock<TypeName extends string>\n       extends NexusGenCustomOutputMethods<TypeName>,\n               NexusGenCustomOutputProperties<TypeName>\n       {}\n\n/** The output definition block is passed to the \"definition\" function property of the \"objectType\" / \"interfaceType\" */\nexport class OutputDefinitionBlock<TypeName extends string> {\n  /** The name of the enclosing object type. */\n  readonly typeName: string\n\n  constructor(protected typeBuilder: OutputDefinitionBuilder, protected wrapping?: NexusWrapKind[]) {\n    this.typeName = typeBuilder.typeName\n    this.typeBuilder.addDynamicOutputMembers(this, this.wrapping)\n  }\n\n  /**\n   * [API Docs](https://nxs.li/docs/api/list) | [GraphQL 2018\n   * Spec](https://spec.graphql.org/June2018/#sec-Type-System.List)\n   *\n   * Chain this property to wrap the right-hand-side type (the field type, another list, nonNull, etc.) with a\n   * List type.\n   *\n   * Chains are read backwards, right to left, like function composition. In other words the thing on the left\n   * wraps the thing on the right.\n   *\n   * This is a shorthand equivalent to:\n   *\n   * `t.field('...', { type: list('...') })`\n   *\n   * @example\n   *   objectType({\n   *     name: 'User',\n   *     definition(t) {\n   *       t.list.nonNull.string('aliases')\n   *     },\n   *   })\n   *\n   *   // GraphQL SDL\n   *   // -----------\n   *   //\n   *   // type User {\n   *   //   aliases: [String!]\n   *   // }\n   */\n  get list() {\n    return this._wrapClass('List')\n  }\n\n  /**\n   * [API Docs](https://nxs.li/docs/api/nonNull) | [Nullability\n   * Guide](https://nexusjs.org/docs/guides/nullability) | [GraphQL 2018\n   * Spec](https://spec.graphql.org/June2018/#sec-Type-System.Non-Null)\n   *\n   * Chain this property to wrap the right-hand-side type (the field type or a list) with a Non-Null type.\n   *\n   * In Nexus output types are nullable by default so this is useful to configure a field differently. Note if\n   * you find yourself using this most of the time then what you probably what is to change the\n   * nonNullDefaults configuration either globally in your makeSchema config or at the type definition level\n   * in one of your type configs to be false for outputs.\n   *\n   * Chains are read backwards, right to left, like function composition. In other words the thing on the left\n   * wraps the thing on the right.\n   *\n   * This is a shorthand equivalent to:\n   *\n   * `t.field('...', { type: nonNull('...') })`\n   *\n   * @example\n   *   objectType({\n   *     name: 'User',\n   *     definition(t) {\n   *       t.nonNull.list.string('aliases')\n   *     },\n   *   })\n   *\n   *   // GraphQL SDL\n   *   // -----------\n   *   //\n   *   // type User {\n   *   //   aliases: [String]!\n   *   // }\n   */\n  get nonNull(): Omit<OutputDefinitionBlock<TypeName>, 'nonNull' | 'nullable'> {\n    return this._wrapClass('NonNull')\n  }\n\n  /**\n   * [API Docs](https://nxs.li/docs/api/null) | [Nullability\n   * Guide](https://nexusjs.org/docs/guides/nullability) | [GraphQL 2018\n   * Spec](https://spec.graphql.org/June2018/#sec-Type-System.Non-Null)\n   *\n   * Chain this property to *unwrap* the right-hand-side type (the field type or a list) of a Non-Null type.\n   *\n   * In Nexus output types are nullable by default so this is only useful when you have changed your\n   * nonNullDefaults configuration either globally in your makeSchema config or at the type definition level\n   * in one of your type configs to be false for outputs.\n   *\n   * Chains are read backwards, right to left, like function composition. In other words the thing on the left\n   * wraps the thing on the right.\n   *\n   * This is a shorthand equivalent to:\n   *\n   * `t.field('...', { type: nullable('...') })`\n   *\n   * @example\n   *   objectType({\n   *     name: 'User',\n   *     nonNullDefaults: {\n   *       outputs: true,\n   *     },\n   *     definition(t) {\n   *       t.id('id')\n   *       t.nullable.string('bio')\n   *     },\n   *   })\n   *\n   *   // GraphQL SDL\n   *   // -----------\n   *   //\n   *   // type User {\n   *   //   id: ID!\n   *   //   bio: String\n   *   // }\n   */\n  get nullable(): Omit<OutputDefinitionBlock<TypeName>, 'nonNull' | 'nullable'> {\n    return this._wrapClass('Null')\n  }\n\n  /**\n   * [GraphQL 2018 spec](https://spec.graphql.org/June2018/#sec-Boolean)\n   *\n   * Define a field whose type is Boolean.\n   *\n   * Boolean types are [scalars](https://spec.graphql.org/June2018/#sec-Scalars) representing true or false.\n   * They are represented in JavaScript using the [boolean primitive\n   * type](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean).\n   *\n   * This is a shorthand equivalent to:\n   *\n   * `t.field('...', { type: boolean() })`\n   *\n   * @example\n   *   objectType({\n   *     name: 'User',\n   *     definition(t) {\n   *       t.boolean('active')\n   *     },\n   *   })\n   *\n   * @param name The name of this field. Must conform to the regex pattern: [_A-Za-z][_0-9A-Za-z]*\n   * @param config The configuration for things like the field's type, its description, its arguments, its\n   *     resolver, and more. See jsdoc on each field within for details.\n   *\n   * This parameter is optional if no resolver is required. No resolver is required if the [source\n   *     typing](https://nxs.li/guides/backing-types):\n   *\n   * 1. Has a field whose name matches this one 2. And whose type is compatible 3. And is a scalar\n   *\n   * ...in which case the default resolver will be available whose behaviour is to simply return that field\n   *     from the received source type.\n   */\n  boolean<FieldName extends string>(name: FieldName, ...config: ScalarOutSpread<TypeName, FieldName>) {\n    this.addScalarField(name, 'Boolean', config)\n  }\n\n  /**\n   * [GraphQL 2018 spec](https://spec.graphql.org/June2018/#sec-String)\n   *\n   * Define a field whose type is String.\n   *\n   * String types are [scalars](https://spec.graphql.org/June2018/#sec-Scalars) representing UTF-8 (aka.\n   * unicode) character sequences. It is most often used to represent free-form human-readable text. They are\n   * represented in JavaScript using the [string primitive\n   * type](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String).\n   *\n   * This is a shorthand, equivalent to:\n   *\n   * `t.field('...', { type: string() })`\n   *\n   * @example\n   *   objectType({\n   *     name: 'User',\n   *     definition(t) {\n   *       t.string('bio')\n   *     },\n   *   })\n   *\n   * @param name The name of this field. Must conform to the regex pattern: [_A-Za-z][_0-9A-Za-z]*\n   * @param config The configuration for things like the field's type, its description, its arguments, its\n   *     resolver, and more. See jsdoc on each field within for details.\n   *\n   * This parameter is optional if no resolver is required. No resolver is required if the [source\n   *     typing](https://nxs.li/guides/backing-types):\n   *\n   * 1. Has a field whose name matches this one 2. And whose type is compatible 3. And is a scalar\n   *\n   * ...in which case the default resolver will be available whose behaviour is to simply return that field\n   *     from the received source type.\n   */\n  string<FieldName extends string>(name: FieldName, ...config: ScalarOutSpread<TypeName, FieldName>) {\n    this.addScalarField(name, 'String', config)\n  }\n\n  /**\n   * [GraphQL 2018 spec](https://spec.graphql.org/June2018/#sec-ID)\n   *\n   * Define a field whose type is ID.\n   *\n   * ID types are [scalars](https://spec.graphql.org/June2018/#sec-Scalars) representing unique identifiers\n   * often used to refetch an object or as the key for a cache. It is serialized in the same way as the\n   * [String](https://spec.graphql.org/June2018/#sec-String) type but unlike String not intended to be\n   * human-readable. They are represented in JavaScript using the [string primitive\n   * type](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String).\n   *\n   * This is a shorthand, equivalent to:\n   *\n   * `t.field('...', { type: id() })`\n   *\n   * @example\n   *   objectType({\n   *     name: 'User',\n   *     definition(t) {\n   *       t.id('id')\n   *     },\n   *   })\n   *\n   * @param name The name of this field. Must conform to the regex pattern: [_A-Za-z][_0-9A-Za-z]*\n   * @param config The configuration for things like the field's type, its description, its arguments, its\n   *     resolver, and more. See jsdoc on each field within for details.\n   *\n   * This parameter is optional if no resolver is required. No resolver is required if the [source\n   *     typing](https://nxs.li/guides/backing-types):\n   *\n   * 1. Has a field whose name matches this one 2. And whose type is compatible 3. And is a scalar\n   *\n   * ...in which case the default resolver will be available whose behaviour is to simply return that field\n   *     from the received source type.\n   */\n  id<FieldName extends string>(name: FieldName, ...config: ScalarOutSpread<TypeName, FieldName>) {\n    this.addScalarField(name, 'ID', config)\n  }\n\n  /**\n   * [GraphQL 2018 spec](https://spec.graphql.org/June2018/#sec-Int)\n   *\n   * Define a field whose type is Int.\n   *\n   * Int types are [scalars](https://spec.graphql.org/June2018/#sec-Scalars) representing a signed 32-bit\n   * numeric non-fractional value. They are represented in JavaScript using the [number primitive\n   * type](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number).\n   *\n   * This is a shorthand equivalent to:\n   *\n   * `t.field('...', { type: int() })`\n   *\n   * @example\n   *   objectType({\n   *     name: 'User',\n   *     definition(t) {\n   *       t.int('age')\n   *     },\n   *   })\n   *\n   * @param name The name of this field. Must conform to the regex pattern: [_A-Za-z][_0-9A-Za-z]*\n   * @param config The configuration for things like the field's type, its description, its arguments, its\n   *     resolver, and more. See jsdoc on each field within for details.\n   *\n   * This parameter is optional if no resolver is required. No resolver is required if the [source\n   *     typing](https://nxs.li/guides/backing-types):\n   *\n   * 1. Has a field whose name matches this one 2. And whose type is compatible 3. And is a scalar\n   *\n   * ...in which case the default resolver will be available whose behaviour is to simply return that field\n   *     from the received source type.\n   */\n  int<FieldName extends string>(name: FieldName, ...config: ScalarOutSpread<TypeName, FieldName>) {\n    this.addScalarField(name, 'Int', config)\n  }\n\n  /**\n   * [GraphQL 2018 spec](https://spec.graphql.org/June2018/#sec-Float)\n   *\n   * Define a field whose type is Float.\n   *\n   * Float types are [scalars](https://spec.graphql.org/June2018/#sec-Scalars) representing signed\n   * double‚Äêprecision fractional values as specified by IEEE 754. They are represented in JavaScript using\n   * the [number primitive\n   * type](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number).\n   *\n   * This is a shorthand, equivalent to:\n   *\n   * `t.field('...', { type: float() })`\n   *\n   * @example\n   *   objectType({\n   *     name: 'User',\n   *     definition(t) {\n   *       t.float('height')\n   *     },\n   *   })\n   *\n   * @param name The name of this field. Must conform to the regex pattern: [_A-Za-z][_0-9A-Za-z]*\n   * @param config The configuration for things like the field's type, its description, its arguments, its\n   *     resolver, and more. See jsdoc on each field within for details.\n   *\n   * This parameter is optional if no resolver is required. No resolver is required if the [source\n   *     typing](https://nxs.li/guides/backing-types):\n   *\n   * 1. Has a field whose name matches this one 2. And whose type is compatible 3. And is a scalar\n   *\n   * ...in which case the default resolver will be available whose behaviour is to simply return that field\n   *     from the received source type.\n   */\n  float<FieldName extends string>(name: FieldName, ...config: ScalarOutSpread<TypeName, FieldName>) {\n    this.addScalarField(name, 'Float', config)\n  }\n\n  /**\n   * [GraphQL 2018 Spec](https://spec.graphql.org/June2018/#sec-Language.Fields)\n   *\n   * Define a field on this object.\n   *\n   * A field describes one discrete piece of information available to request within a [selection\n   * set](https://spec.graphql.org/June2018/#sec-Selection-Sets). They are in fact most of what any selection\n   * set will contain. Fields can be typed as scalars (marking the terminal point of a branch of a selection\n   * set) or as other object types in your schema thus allowing you to model relationships between things.\n   *\n   * @example\n   *   objectType({\n   *     name: 'User',\n   *     definition(t) {\n   *       t.field('id', {\n   *         type: id(),\n   *         description: 'The unique identification number for this user',\n   *       })\n   *     },\n   *   })\n   *\n   * @param name The name of this field. Must conform to the regex pattern: [_A-Za-z][_0-9A-Za-z]*\n   * @param config The configuration for things like the field's type, its description, its arguments, its\n   *     resolver, and more. See jsdoc on each field within for details.\n   */\n  field<FieldName extends string>(name: FieldName, config: FieldOutConfig<TypeName, FieldName>): void\n  /**\n   * [GraphQL 2018 Spec](https://spec.graphql.org/June2018/#sec-Language.Fields)\n   *\n   * Define a field on this object.\n   *\n   * A field describes one discrete piece of information available to request within a [selection\n   * set](https://spec.graphql.org/June2018/#sec-Selection-Sets). They are in fact most of what any selection\n   * set will contain. Fields can be typed as scalars (marking the terminal point of a branch of a selection\n   * set) or as other object types in your schema thus allowing you to model relationships between things.\n   *\n   * @example\n   *   objectType({\n   *     name: 'User',\n   *     definition(t) {\n   *       t.field({\n   *         name: 'id',\n   *         type: id(),\n   *         description: 'The unique identification number for this user',\n   *       })\n   *     },\n   *   })\n   *\n   * @param config The configuration for things like the field's type, its description, its arguments, its\n   *     resolver, and more. See jsdoc on each field within for details.\n   */\n  field<FieldName extends string>(config: FieldOutConfigWithName<TypeName, FieldName>): void\n  field<FieldName extends string>(\n    ...args:\n      | [name: FieldName, config: FieldOutConfig<TypeName, FieldName>]\n      | [config: FieldOutConfigWithName<TypeName, FieldName>]\n  ): void {\n    const config = args.length === 2 ? { name: args[0], ...args[1] } : args[0]\n\n    this.typeBuilder.addField({\n      ...config,\n      configFor: 'outputField',\n      wrapping: this.wrapping,\n      parentType: this.typeName,\n    } as any)\n  }\n\n  private _wrapClass(kind: NexusWrapKind): OutputDefinitionBlock<TypeName> {\n    const previousWrapping = this.wrapping?.[0]\n    if (\n      (kind === 'NonNull' || kind === 'Null') &&\n      (previousWrapping === 'NonNull' || previousWrapping === 'Null')\n    ) {\n      return new OutputDefinitionBlock(this.typeBuilder, this.wrapping || [])\n    }\n    return new OutputDefinitionBlock(this.typeBuilder, [kind].concat(this.wrapping || []))\n  }\n\n  private addScalarField<FieldName extends string>(\n    fieldName: FieldName,\n    typeName: BaseScalars,\n    opts: [] | ScalarOutSpread<TypeName, any>\n  ) {\n    let fieldConfig: FieldOutConfig<any, any> = {\n      type: typeName,\n    }\n\n    /* istanbul ignore if */\n    if (typeof opts[0] === 'function') {\n      throw new Error(messages.removedFunctionShorthand(typeName, fieldName))\n    } else {\n      fieldConfig = { ...fieldConfig, ...opts[0] }\n    }\n\n    this.field(fieldName, fieldConfig as any)\n  }\n}\n\n/** TODO move the code below to definitionBlocks/input.ts Input */\n\n// prettier-ignore\nexport interface NexusInputFieldConfig<TypeName extends string, FieldName extends string> extends CommonInputFieldConfig<TypeName, FieldName> {\n  type: AllInputTypes | AllNexusInputTypeDefs\n}\n\n// prettier-ignore\nexport interface NexusInputFieldConfigWithName<TypeName extends string, FieldName extends string> extends NexusInputFieldConfig<TypeName, FieldName> {\n  /**\n   * The name of this field. Must conform to the regex pattern: [_A-Za-z][_0-9A-Za-z]*\n   */\n  name: FieldName\n}\n\nexport type NexusInputFieldDef = NexusInputFieldConfig<string, string> & {\n  configFor: 'inputField'\n  name: string\n  wrapping?: NexusWrapKind[]\n  parentType: string\n}\n\nexport interface InputDefinitionBlock<TypeName extends string> extends NexusGenCustomInputMethods<TypeName> {}\n\nexport class InputDefinitionBlock<TypeName extends string> {\n  readonly typeName: string\n  constructor(protected typeBuilder: InputDefinitionBuilder, protected wrapping?: NexusWrapKind[]) {\n    this.typeName = typeBuilder.typeName\n    this.typeBuilder.addDynamicInputFields(this, this.wrapping)\n  }\n\n  get list() {\n    return this._wrapClass('List')\n  }\n\n  get nonNull(): Omit<InputDefinitionBlock<TypeName>, 'nonNull' | 'nullable'> {\n    return this._wrapClass('NonNull')\n  }\n\n  get nullable(): Omit<InputDefinitionBlock<TypeName>, 'nonNull' | 'nullable'> {\n    return this._wrapClass('Null')\n  }\n\n  string<FieldName extends string>(\n    fieldName: FieldName,\n    config?: CommonInputFieldConfig<TypeName, FieldName>\n  ) {\n    this.field(fieldName, { ...config, type: 'String' })\n  }\n\n  int<FieldName extends string>(fieldName: FieldName, config?: CommonInputFieldConfig<TypeName, FieldName>) {\n    this.field(fieldName, { ...config, type: 'Int' })\n  }\n\n  boolean<FieldName extends string>(\n    fieldName: FieldName,\n    opts?: CommonInputFieldConfig<TypeName, FieldName>\n  ) {\n    this.field(fieldName, { ...opts, type: 'Boolean' })\n  }\n\n  id<FieldName extends string>(fieldName: FieldName, config?: CommonInputFieldConfig<TypeName, FieldName>) {\n    this.field(fieldName, { ...config, type: 'ID' })\n  }\n\n  float<FieldName extends string>(\n    fieldName: FieldName,\n    config?: CommonInputFieldConfig<TypeName, FieldName>\n  ) {\n    this.field(fieldName, { ...config, type: 'Float' })\n  }\n\n  field<FieldName extends string>(config: NexusInputFieldConfigWithName<TypeName, FieldName>): void\n  field<FieldName extends string>(name: FieldName, config: NexusInputFieldConfig<TypeName, FieldName>): void\n  field<FieldName extends string>(\n    ...args:\n      | [FieldName, NexusInputFieldConfig<TypeName, FieldName>]\n      | [NexusInputFieldConfigWithName<TypeName, FieldName>]\n  ): void {\n    const config = args.length === 2 ? { name: args[0], ...args[1] } : args[0]\n\n    this.typeBuilder.addField({\n      ...config,\n      wrapping: this.wrapping,\n      parentType: this.typeName,\n      configFor: 'inputField',\n    })\n  }\n\n  private _wrapClass(kind: NexusWrapKind) {\n    const previousWrapping = this.wrapping?.[0]\n    if (\n      (kind === 'NonNull' || kind === 'Null') &&\n      (previousWrapping === 'NonNull' || previousWrapping === 'Null')\n    ) {\n      return new InputDefinitionBlock(this.typeBuilder, this.wrapping || [])\n    }\n    return new InputDefinitionBlock(this.typeBuilder, [kind].concat(this.wrapping || []))\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 436, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/definitions/_types.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/definitions/_types.ts"],"sourcesContent":["import type {\n  GraphQLCompositeType,\n  GraphQLEnumType,\n  GraphQLFieldConfig,\n  GraphQLInputObjectType,\n  GraphQLInputObjectTypeConfig,\n  GraphQLInterfaceType,\n  GraphQLInterfaceTypeConfig,\n  GraphQLLeafType,\n  GraphQLObjectType,\n  GraphQLObjectTypeConfig,\n  GraphQLScalarType,\n  GraphQLSchema,\n  GraphQLUnionType,\n} from 'graphql'\nimport type {\n  NexusFieldExtension,\n  NexusInputObjectTypeExtension,\n  NexusInterfaceTypeExtension,\n  NexusObjectTypeExtension,\n  NexusSchemaExtension,\n} from '../extensions'\nimport type * as AbstractTypes from '../typegenAbstractTypes'\nimport type { RequiredDeeply } from '../typeHelpersInternal'\n\nexport type { AbstractTypes }\n\n/** Conveniently represents flow's \"Maybe\" type https://flow.org/en/docs/types/maybe/ */\nexport type Maybe<T> = null | undefined | T\n\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>\n\nexport type BaseScalars = 'String' | 'Int' | 'Float' | 'ID' | 'Boolean'\n\nexport enum NexusTypes {\n  Arg = 'Arg',\n  DynamicInput = 'DynamicInput',\n  DynamicOutputMethod = 'DynamicOutputMethod',\n  DynamicOutputProperty = 'DynamicOutputProperty',\n  Enum = 'Enum',\n  ExtendInputObject = 'ExtendInputObject',\n  ExtendObject = 'ExtendObject',\n  InputField = 'InputField',\n  InputObject = 'InputObject',\n  Interface = 'Interface',\n  List = 'List',\n  NonNull = 'NonNull',\n  Null = 'Null',\n  Object = 'Object',\n  OutputField = 'OutputField',\n  Plugin = 'Plugin',\n  PrintedGenTyping = 'PrintedGenTyping',\n  PrintedGenTypingImport = 'PrintedGenTypingImport',\n  Scalar = 'Scalar',\n  Union = 'Union',\n}\n\nexport interface DeprecationInfo {\n  /** Reason for the deprecation. */\n  reason: string\n  /** Date | YYYY-MM-DD formatted date of when this field became deprecated. */\n  startDate?: string | Date\n  /** Field or usage that replaces the deprecated field. */\n  supersededBy?: string\n}\n\n/**\n * [Nullability Guide](https://nxs.li/guides/nullability)\n *\n * Configures the default nullability for fields and arguments.\n */\nexport interface NonNullConfig {\n  /**\n   * Whether output field (object type fields) types are non-null by default.\n   *\n   * @default false\n   */\n  output?: boolean\n  /**\n   * Whether input field (field arguments, input object type fields) types are non-null by default.\n   *\n   * @default false\n   */\n  input?: boolean\n}\n\nexport type GraphQLPossibleOutputs = GraphQLCompositeType | GraphQLLeafType\n\nexport type GraphQLPossibleInputs = GraphQLInputObjectType | GraphQLLeafType\n\nexport const NexusWrappedSymbol = Symbol.for('@nexus/wrapped')\n\nexport function withNexusSymbol(obj: Function, nexusType: NexusTypes) {\n  obj.prototype[NexusWrappedSymbol] = nexusType\n}\n\nexport interface AsyncIterator<T> {\n  next(value?: any): Promise<IteratorResult<T>>\n  return?(value?: any): Promise<IteratorResult<T>>\n  throw?(e?: any): Promise<IteratorResult<T>>\n}\n\nexport type SourceTypingDef = string | TypingImport\n\nexport type SourceTypings = Record<string, string | TypingImport>\n\nexport interface TypingImport {\n  /** An absolute path to a module in your project or the name of a package installed in your project. */\n  module: string\n  /** The name of a type exported from the module/package (specified in `module`) that you want to use. */\n  export: string\n  /**\n   * The name you want the imported type to be referenced as in the typegen.\n   *\n   * This is useful when there is already a typegen import whose name would conflict with this type name.\n   *\n   * Default :: By default no import alias will be used.\n   */\n  alias?: string\n}\n\nexport interface MissingType {\n  fromObject: boolean\n}\n\nexport type GraphQLNamedOutputType =\n  | GraphQLScalarType\n  | GraphQLObjectType\n  | GraphQLInterfaceType\n  | GraphQLUnionType\n  | GraphQLEnumType\n\nexport type GraphQLNamedInputType = GraphQLScalarType | GraphQLInputObjectType | GraphQLEnumType\n\ntype WithExt<T extends { extensions?: any }, Ext> = Omit<T, 'extensions'> & {\n  extensions?: Maybe<{ nexus?: Ext }>\n}\n\nexport type NexusGraphQLFieldConfig = WithExt<GraphQLFieldConfig<any, any>, NexusFieldExtension> & {\n  name: string\n}\n\nexport type NexusGraphQLObjectTypeConfig = WithExt<\n  GraphQLObjectTypeConfig<any, any>,\n  NexusObjectTypeExtension\n>\n\nexport type NexusGraphQLInputObjectTypeConfig = WithExt<\n  GraphQLInputObjectTypeConfig,\n  NexusInputObjectTypeExtension\n>\n\nexport type NexusGraphQLInterfaceTypeConfig = WithExt<\n  GraphQLInterfaceTypeConfig<any, any>,\n  NexusInterfaceTypeExtension\n> & { interfaces: () => GraphQLInterfaceType[] }\n\nexport interface NexusGraphQLSchema extends GraphQLSchema {\n  extensions: {\n    nexus: NexusSchemaExtension\n    [attributeName: string]: unknown\n  }\n}\n\nexport type NexusFeaturesInput = {\n  /**\n   * Toggle runtime checks for correct implementation of abstract types. This is a redundant check Nexus makes\n   * over the existing static typings it provides.\n   *\n   * Remarks :: This is useful for beginners because Nexus can give clear concise error messages unlike the\n   * static type errors.\n   *\n   * Note that if you enable the \"abstractTypeStrategies.__typename\" feature then this feature will be\n   * automatically disabled. For why this is, see that features' remarks.\n   */\n  abstractTypeRuntimeChecks?: boolean\n  /**\n   * Toggle abstract-type strategies. For more detail about this feature please refer to to the [abstract\n   * types guide](https://nxs.li/guides/abstract-types).\n   *\n   * If you plan on enabling multiple strategies and you've never done so then please [read the guide about\n   * using multiple strategies](https://nxs.li/guides/abstract-types/using-multiple-strategies) as there are\n   * a few quirks to be aware of.\n   *\n   * @default {resolveType: true,\n   *    __typename: false\n   *    isTypeOf: false,}\n   */\n  abstractTypeStrategies?: {\n    /**\n     * The Modular abstract type strategy. Every member object of an abstract type (union members or interface\n     * implementors) will generally be required to implement isTypeOf method. Nexus will not require it in\n     * cases where it detects you have implemented another strategy. For more detail see the guide for the\n     * [Modular Abstract Type Strategy](https://nxs.li/guides/abstract-types/modular-strategy).\n     */\n    isTypeOf?: boolean\n    /**\n     * The Centralized abstract type strategy. Every abstract type (union or interface) will generally be\n     * required to implement its resolveType method. Nexus will not require it in cases where it detects you\n     * have implemented another strategy. For more detail see the guide for the [Central Abstract Type\n     * Strategy](https://nxs.li/guides/abstract-types/centralized-strategy).\n     */\n    resolveType?: boolean\n    /**\n     * The Discriminant Model Field strategy. In this mode the resolvers of fields typed as abstract types\n     * will be required to include \"__typename\" field in the returned data. For more detail see the guide for\n     * the [Discriminant Model Field Strategy](https://nxs.li/guides/abstract-types/discriminant-model-field-strategy).\n     *\n     * Warning :: When this strategy is enabled in conjunction with other strategies the\n     * \"abstractTypeRuntimeChecks\" feature will automatically be disabled. This is because it is not\n     * practical at runtime to find out if resolvers will return objects that include the \"__typename\" field.\n     * This trade-off can be acceptable since the runtime checks are a redundant safety measure over the\n     * static typing. So as long as you are not ignoring static errors related to Nexus' abstract type type\n     * checks then you then you should still have a safe implementation.\n     *\n     * Furthermore another effect is that statically the other strategies will not appear to be *required*,\n     * but instead *optional*, while only this one will appear required. However, upon implementing any of\n     * the other strategies, this one will not longer be required. This quirk is explained in the guide\n     * section about [using multiple strategies](https://nxs.li/guides/abstract-types/using-multiple-strategies).\n     */\n    __typename?: boolean\n  }\n}\n\nexport type NexusFeatures = RequiredDeeply<NexusFeaturesInput>\n"],"names":[],"mappings":";;;;;;;;AAkCA,IAAY,UAqBX;AArBD,CAAA,SAAY,UAAU;IACpB,UAAA,CAAA,MAAA,GAAA,KAAW,CAAA;IACX,UAAA,CAAA,eAAA,GAAA,cAA6B,CAAA;IAC7B,UAAA,CAAA,sBAAA,GAAA,qBAA2C,CAAA;IAC3C,UAAA,CAAA,wBAAA,GAAA,uBAA+C,CAAA;IAC/C,UAAA,CAAA,OAAA,GAAA,MAAa,CAAA;IACb,UAAA,CAAA,oBAAA,GAAA,mBAAuC,CAAA;IACvC,UAAA,CAAA,eAAA,GAAA,cAA6B,CAAA;IAC7B,UAAA,CAAA,aAAA,GAAA,YAAyB,CAAA;IACzB,UAAA,CAAA,cAAA,GAAA,aAA2B,CAAA;IAC3B,UAAA,CAAA,YAAA,GAAA,WAAuB,CAAA;IACvB,UAAA,CAAA,OAAA,GAAA,MAAa,CAAA;IACb,UAAA,CAAA,UAAA,GAAA,SAAmB,CAAA;IACnB,UAAA,CAAA,OAAA,GAAA,MAAa,CAAA;IACb,UAAA,CAAA,SAAA,GAAA,QAAiB,CAAA;IACjB,UAAA,CAAA,cAAA,GAAA,aAA2B,CAAA;IAC3B,UAAA,CAAA,SAAA,GAAA,QAAiB,CAAA;IACjB,UAAA,CAAA,mBAAA,GAAA,kBAAqC,CAAA;IACrC,UAAA,CAAA,yBAAA,GAAA,wBAAiD,CAAA;IACjD,UAAA,CAAA,SAAA,GAAA,QAAiB,CAAA;IACjB,UAAA,CAAA,QAAA,GAAA,OAAe,CAAA;AACjB,CAAC,EArBW,UAAU,IAAA,CAAV,UAAU,GAAA,CAAA,CAAA,GAqBrB;AAmCM,MAAM,kBAAkB,GAAG,MAAM,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAA;AAExD,SAAU,eAAe,CAAC,GAAa,EAAE,SAAqB;IAClE,GAAG,CAAC,SAAS,CAAC,kBAAkB,CAAC,GAAG,SAAS,CAAA;AAC/C,CAAC"}},
    {"offset": {"line": 475, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/definitions/interfaceType.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/definitions/interfaceType.ts"],"sourcesContent":["import { assertValidName, GraphQLInterfaceTypeConfig } from 'graphql'\nimport type { FieldResolver, GetGen, InterfaceFieldsFor, ModificationType } from '../typegenTypeHelpers'\nimport type { ArgsRecord } from './args'\nimport { OutputDefinitionBlock, OutputDefinitionBuilder } from './definitionBlocks'\nimport { AbstractTypes, Maybe, NexusTypes, NonNullConfig, SourceTypingDef, withNexusSymbol } from './_types'\n\nexport type Implemented = GetGen<'interfaceNames'> | NexusInterfaceTypeDef<any>\n\nexport interface FieldModification<TypeName extends string, FieldName extends string> {\n  type?: ModificationType<TypeName, FieldName>\n  /** The description to annotate the GraphQL SDL */\n  description?: Maybe<string>\n  /** The resolve method we should be resolving the field with */\n  resolve?: FieldResolver<TypeName, FieldName>\n  /** You are allowed to add non-required args when modifying a field */\n  args?: Maybe<ArgsRecord>\n  /**\n   * Custom extensions, as supported in graphql-js\n   *\n   * @see https://github.com/graphql/graphql-js/issues/1527\n   */\n  extensions?: GraphQLInterfaceTypeConfig<any, any>['extensions']\n}\n\nexport interface FieldModificationDef<TypeName extends string, FieldName extends string>\n  extends FieldModification<TypeName, FieldName> {\n  field: FieldName\n}\n\nexport type NexusInterfaceTypeConfig<TypeName extends string> = {\n  name: TypeName\n\n  // Really wanted to keep this here, but alas, it looks like there's some\n  // issues around inferring the generic.\n  // https://github.com/Microsoft/TypeScript/pull/29478\n  // https://github.com/Microsoft/TypeScript/issues/10195\n  //\n  // resolveType: AbstractTypeResolver<TypeName>;\n\n  definition(t: InterfaceDefinitionBlock<TypeName>): void\n  /**\n   * Configures the nullability for the type, check the documentation's \"Getting Started\" section to learn\n   * more about GraphQL Nexus's assumptions and configuration on nullability.\n   */\n  nonNullDefaults?: NonNullConfig\n  /** The description to annotate the GraphQL SDL */\n  description?: Maybe<string>\n  /** Source type information for this type */\n  sourceType?: SourceTypingDef\n  /**\n   * Custom extensions, as supported in graphql-js\n   *\n   * @see https://github.com/graphql/graphql-js/issues/1527\n   */\n  extensions?: GraphQLInterfaceTypeConfig<any, any>['extensions']\n  /** Adds this type as a method on the Object/Interface definition blocks */\n  asNexusMethod?: string\n} & AbstractTypes.MaybeTypeDefConfigFieldResolveType<TypeName>\n\nexport interface InterfaceDefinitionBuilder<TypeName extends string> extends OutputDefinitionBuilder {\n  addInterfaces(toAdd: Implemented[]): void\n  addModification(toAdd: FieldModificationDef<TypeName, any>): void\n}\n\nexport class InterfaceDefinitionBlock<TypeName extends string> extends OutputDefinitionBlock<TypeName> {\n  constructor(protected typeBuilder: InterfaceDefinitionBuilder<TypeName>) {\n    super(typeBuilder)\n  }\n  /** @param interfaceName */\n  implements(...interfaceName: Array<Implemented>) {\n    this.typeBuilder.addInterfaces(interfaceName)\n  }\n  /** Modifies a field added via an interface */\n  modify<FieldName extends Extract<InterfaceFieldsFor<TypeName>, string>>(\n    field: FieldName,\n    modifications: FieldModification<TypeName, FieldName>\n  ) {\n    this.typeBuilder.addModification({ ...modifications, field })\n  }\n}\n\nexport class NexusInterfaceTypeDef<TypeName extends string> {\n  constructor(readonly name: TypeName, protected config: NexusInterfaceTypeConfig<TypeName>) {\n    assertValidName(name)\n  }\n  get value() {\n    return this.config\n  }\n}\n\nwithNexusSymbol(NexusInterfaceTypeDef, NexusTypes.Interface)\n\n/**\n * [API Docs](https://nxs.li/docs/api/interface-type) | [Abstract Types\n * Guide](https://nxs.li/guides/abstract-types) | [2018 GraphQL\n * Spec](https://spec.graphql.org/June2018/#sec-Interfaces)\n *\n * Defines an Interface type.\n *\n * Interface types are one of the two abstract type in GraphQL. They let you express polymorphic fields\n * wherein the field may return a number of different object types but they all share some subset of fields.\n * Interface types in Nexus also serve as a way to share a set of fields amongst different object types.\n *\n * @example\n *   export const Media = interfaceType({\n *     name: 'Media',\n *     resolveType(source) {\n *       return 'director' in source ? 'Movie' : 'Song'\n *     },\n *     definition(t) {\n *       t.string('url')\n *     },\n *   })\n *\n *   export const Movie = objectType({\n *     name: 'Movie',\n *     definition(t) {\n *       t.implements('Media')\n *       t.string('director')\n *     },\n *   })\n *\n *   export const Song = objectType({\n *     name: 'Song',\n *     definition(t) {\n *       t.implements('Media')\n *       t.string('album')\n *     },\n *   })\n *\n *   // GraphQL SDL\n *   // -----------\n *   //\n *   // interface Media {\n *   //   url: String\n *   // }\n *   //\n *   // type Movie implements Media {\n *   //   director: String\n *   //   url: String\n *   // }\n *   //\n *   // type Song implements Media {\n *   //   album: String\n *   //   url: String\n *   // }\n *\n * @param config Specify your interface's name, its fields, and more. See each config property's jsDoc for more detail.\n */\nexport function interfaceType<TypeName extends string>(config: NexusInterfaceTypeConfig<TypeName>) {\n  return new NexusInterfaceTypeDef<TypeName>(config.name, config)\n}\n"],"names":[],"mappings":";;;;;;;;AAAA,OAAO,EAAE,eAAe,EAA8B,MAAM,SAAS,CAAA;AAGrE,OAAO,EAAE,qBAAqB,EAA2B,MAAM,oBAAoB,CAAA;AACnF,OAAO,EAAwB,UAAU,EAAkC,eAAe,EAAE,MAAM,UAAU,CAAA;;;;AA4DtG,MAAO,wBAAkD,SAAQ,uQAA+B;IACpG,YAAsB,WAAiD,CAAA;QACrE,KAAK,CAAC,WAAW,CAAC,CAAA;QADE,IAAA,CAAA,WAAW,GAAX,WAAW,CAAsC;IAEvE,CAAC;IACD,yBAAA,EAA2B,CAC3B,UAAU,CAAC,GAAG,aAAiC,EAAA;QAC7C,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,aAAa,CAAC,CAAA;IAC/C,CAAC;IACD,4CAAA,EAA8C,CAC9C,MAAM,CACJ,KAAgB,EAChB,aAAqD,EAAA;QAErD,IAAI,CAAC,WAAW,CAAC,eAAe,CAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAM,aAAa,GAAA;YAAE,KAAK;QAAA,GAAG,CAAA;IAC/D,CAAC;CACF;AAEK,MAAO,qBAAqB;IAChC,YAAqB,IAAc,EAAY,MAA0C,CAAA;QAApE,IAAA,CAAA,IAAI,GAAJ,IAAI,CAAU;QAAY,IAAA,CAAA,MAAM,GAAN,MAAM,CAAoC;YACvF,kOAAe,EAAC,IAAI,CAAC,CAAA;IACvB,CAAC;IACD,IAAI,KAAK,GAAA;QACP,OAAO,IAAI,CAAC,MAAM,CAAA;IACpB,CAAC;CACF;IAED,uPAAe,EAAC,qBAAqB,EAAE,kPAAU,CAAC,SAAS,CAAC,CAAA;AA2DtD,SAAU,aAAa,CAA0B,MAA0C;IAC/F,OAAO,IAAI,qBAAqB,CAAW,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,CAAA;AACjE,CAAC"}},
    {"offset": {"line": 521, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/definitions/objectType.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/definitions/objectType.ts"],"sourcesContent":["import { assertValidName, GraphQLObjectType } from 'graphql'\nimport type { InterfaceFieldsFor } from '../typegenTypeHelpers'\nimport { OutputDefinitionBlock, OutputDefinitionBuilder } from './definitionBlocks'\nimport type { FieldModification, FieldModificationDef, Implemented } from './interfaceType'\nimport { AbstractTypes, Maybe, NexusTypes, NonNullConfig, SourceTypingDef, withNexusSymbol } from './_types'\n\nexport interface ObjectDefinitionBuilder extends OutputDefinitionBuilder {\n  addInterfaces(toAdd: Implemented[]): void\n  addModification(toAdd: FieldModificationDef<any, any>): void\n}\n\nexport class ObjectDefinitionBlock<TypeName extends string> extends OutputDefinitionBlock<TypeName> {\n  constructor(protected typeBuilder: ObjectDefinitionBuilder) {\n    super(typeBuilder)\n  }\n  /** @param interfaceName */\n  implements(...interfaceName: Array<Implemented>) {\n    this.typeBuilder.addInterfaces(interfaceName)\n  }\n  /** Modifies a field added via an interface */\n  modify<FieldName extends Extract<InterfaceFieldsFor<TypeName>, string>>(\n    field: FieldName,\n    modifications: FieldModification<TypeName, FieldName>\n  ) {\n    this.typeBuilder.addModification({ ...modifications, field })\n  }\n}\n\n/** Configuration object to specify an object's name, fields, and more. */\nexport type NexusObjectTypeConfig<TypeName extends string> = {\n  /**\n   * [GraphQL 2018 Spec](https://spec.graphql.org/June2018/#Name)\n   *\n   * The name of this object type. Must conform to the pattern:\n   *\n   * [_A-Za-z][_0-9A-Za-z]*\n   *\n   * From the spec: Names in GraphQL are case‚Äêsensitive. That is to say name, Name, and NAME all refer to\n   * dfferent names. Underscores are significant, which means other_name and othername are two different names.\n   *\n   * @example\n   *   'Post'\n   *\n   * @example\n   *   'User2'\n   *\n   * @example\n   *   'comment'\n   *\n   * @example\n   *   'User_Timeline'\n   */\n  name: TypeName\n  /**\n   * [Nullability Guide](https://nxs.li/guides/nullability)\n   *\n   * Configures the default nullability for fields and arguments in this object.\n   *\n   * Default :: By default inherits from the global nonNullDefaults configuration found in makeSchema.\n   *\n   * @example\n   *   const User = objectType({\n   *     name: 'User',\n   *     nonNullDefaults: {\n   *       input: true, // field args, input object type fields\n   *       output: false, // object type fields\n   *     },\n   *     definition(t) {\n   *       t.string('location', {\n   *         args: {\n   *           language: stringArg(),\n   *         },\n   *       })\n   *     },\n   *   })\n   *\n   *   // GraphQL SDL\n   *   // -----------\n   *   //\n   *   // type User {\n   *   //   location(language: String!): String\n   *   // }\n   */\n  nonNullDefaults?: NonNullConfig\n  /**\n   * [GraphQL 2018 Spec](https://spec.graphql.org/June2018/#sec-Descriptions)\n   *\n   * The description for this object type.\n   *\n   * Various GraphQL tools will make use of this information but it has zero runtime impact. The value given\n   * here will also be included as heredocs in the generated GraphQL SDL file.\n   *\n   * Default :: By default there will be no description\n   *\n   * @example\n   *   'Little description to help you along!'\n   *\n   *   // GraphQL SDL\n   *   // -----------\n   *   // \"\"\"Little description to help you along!\"\"\"\n   *   // type YOUR_TYPE_NAME {\n   *   //   # ...\n   *   // }\n   */\n  description?: Maybe<string>\n  /**\n   * [Source Types Guide](https://nxs.li/guides/backing-types)\n   *\n   * Specify the Source Type for this object type.\n   *\n   * You can give a literal TypeScript type written as a string or give the location of a module that exports a type.\n   *\n   * Default :: By default the source type of this object will be whatever you configured in makeSchema, if\n   * anything, otherwise simply 1:1 with how you have defined this object type.\n   *\n   * @example\n   *   '{ foo: string; qux: number; bar: boolean }'\n   *\n   * @example\n   *   {\n   *   \"module\": \"some-package\",\n   *   \"export\": \"User\"\n   *   }\n   *\n   * @example\n   *   {\n   *   module: `${__dirname}/some/module.ts`,\n   *   export: 'User',\n   *   }\n   */\n  sourceType?: SourceTypingDef\n  /**\n   * Data that will be added to the field-level [extensions field on the graphql-js type def\n   * instances](https://github.com/graphql/graphql-js/issues/1527) resulting from makeSchema. Useful for some\n   * graphql-js based tools like [join-monster](https://github.com/join-monster/join-monster) which rely on\n   * looking for special data here.\n   *\n   * @example\n   *   // taken from: https://github.com/graphql-nexus/schema/issues/683#issuecomment-735711640\n   *\n   *   const User = objectType({\n   *     name: 'User',\n   *     extensions: {\n   *       joinMonster: {\n   *         sqlTable: 'USERS',\n   *         uniqueKey: 'USER_ID',\n   *       },\n   *     },\n   *     definition(t) {\n   *       t.id('id', {\n   *         extensions: {\n   *           joinMonster: {\n   *             sqlColumn: 'USER_ID',\n   *           },\n   *         },\n   *       })\n   *     },\n   *   })\n   */\n  extensions?: GraphQLObjectType['extensions']\n  /**\n   * Define the fields of your object type.\n   *\n   * This method receives a type builder api that you will use to define the fields of your object type\n   * within. You can leverage conditionals, loops, other functions (that take the builder api as an\n   * argument), pull in variables from higher scopes, and so on, to help define your fields. However avoid two things:\n   *\n   * 1. Doing asynchronous work when defining fields. 2. Triggering side-effects that you would NOT want run\n   * at *build* time‚Äì‚Äìas this code will run during build\n   *     to support [Nexus' reflection system](https://nxs.li/guides/reflection).\n   *\n   * @example\n   *   objectType({\n   *     name: 'User',\n   *     definition(t) {\n   *       t.field('name', { type: 'String' })\n   *       t.string('status')\n   *       t.list.list.int('foo')\n   *       t.nullable.boolean('visible')\n   *       t.list.nonNull.field('friends', {\n   *         type: 'Friend',\n   *         // ...\n   *       })\n   *     },\n   *   })\n   *\n   * @param t The type builder API for object types. The primary method you'll find is \"t.field\" but there are\n   *     many convenient shorthands available as well, plus anything plugins have added. Explore each one's\n   *     jsDoc for more detail.\n   */\n  definition(t: ObjectDefinitionBlock<TypeName>): void\n  /** Adds this type as a method on the Object/Interface definition blocks */\n  asNexusMethod?: string\n} & AbstractTypes.MaybeTypeDefConfigFieldIsTypeOf<TypeName> &\n  NexusGenPluginTypeConfig<TypeName>\n\nexport class NexusObjectTypeDef<TypeName extends string> {\n  constructor(readonly name: TypeName, protected config: NexusObjectTypeConfig<TypeName>) {\n    assertValidName(name)\n  }\n  get value() {\n    return this.config\n  }\n}\n\nwithNexusSymbol(NexusObjectTypeDef, NexusTypes.Object)\n\n/**\n * [API Docs](https://nxs.li/docs/api/object-type) | [GraphQL.org\n * Docs](https://graphql.org/learn/schema/#object-types-and-fields) | [GraphQL 2018\n * Spec](https://spec.graphql.org/June2018/#sec-Objects)\n *\n * Define a GraphQL Object Type.\n *\n * Object types are typically the most common kind of type present in a GraphQL schema. You give them a name\n * and fields that model your domain. Fields are typed and can point to yet another object type you've defined.\n *\n * @example\n *   const Post = objectType({\n *     name: 'Post',\n *     definition(t) {\n *       t.int('id')\n *       t.string('title')\n *     },\n *   })\n *\n * @param config Specify your object's name, its fields, and more. See each config property's jsDoc for more detail.\n */\nexport function objectType<TypeName extends string>(config: NexusObjectTypeConfig<TypeName>) {\n  return new NexusObjectTypeDef<TypeName>(config.name, config)\n}\n"],"names":[],"mappings":";;;;;;;;AAAA,OAAO,EAAE,eAAe,EAAqB,MAAM,SAAS,CAAA;AAE5D,OAAO,EAAE,qBAAqB,EAA2B,MAAM,oBAAoB,CAAA;AAEnF,OAAO,EAAwB,UAAU,EAAkC,eAAe,EAAE,MAAM,UAAU,CAAA;;;;AAOtG,MAAO,qBAA+C,SAAQ,uQAA+B;IACjG,YAAsB,WAAoC,CAAA;QACxD,KAAK,CAAC,WAAW,CAAC,CAAA;QADE,IAAA,CAAA,WAAW,GAAX,WAAW,CAAyB;IAE1D,CAAC;IACD,yBAAA,EAA2B,CAC3B,UAAU,CAAC,GAAG,aAAiC,EAAA;QAC7C,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,aAAa,CAAC,CAAA;IAC/C,CAAC;IACD,4CAAA,EAA8C,CAC9C,MAAM,CACJ,KAAgB,EAChB,aAAqD,EAAA;QAErD,IAAI,CAAC,WAAW,CAAC,eAAe,CAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAM,aAAa,GAAA;YAAE,KAAK;QAAA,GAAG,CAAA;IAC/D,CAAC;CACF;AA0KK,MAAO,kBAAkB;IAC7B,YAAqB,IAAc,EAAY,MAAuC,CAAA;QAAjE,IAAA,CAAA,IAAI,GAAJ,IAAI,CAAU;QAAY,IAAA,CAAA,MAAM,GAAN,MAAM,CAAiC;YACpF,kOAAe,EAAC,IAAI,CAAC,CAAA;IACvB,CAAC;IACD,IAAI,KAAK,GAAA;QACP,OAAO,IAAI,CAAC,MAAM,CAAA;IACpB,CAAC;CACF;IAED,uPAAe,EAAC,kBAAkB,EAAE,kPAAU,CAAC,MAAM,CAAC,CAAA;AAuBhD,SAAU,UAAU,CAA0B,MAAuC;IACzF,OAAO,IAAI,kBAAkB,CAAW,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,CAAA;AAC9D,CAAC"}},
    {"offset": {"line": 567, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/definitions/unionType.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/definitions/unionType.ts"],"sourcesContent":["import { assertValidName, GraphQLUnionTypeConfig } from 'graphql'\nimport type { GetGen } from '../typegenTypeHelpers'\nimport type { NexusObjectTypeDef } from './objectType'\nimport { AbstractTypes, Maybe, NexusTypes, SourceTypingDef, withNexusSymbol } from './_types'\n\nexport interface UnionDefinitionBuilder {\n  typeName: string\n  addUnionMembers(members: UnionMembers): void\n}\n\nexport type UnionMembers = Array<GetGen<'objectNames'> | NexusObjectTypeDef<any>>\n\nexport class UnionDefinitionBlock {\n  constructor(protected typeBuilder: UnionDefinitionBuilder) {}\n  /**\n   * All ObjectType names that should be part of the union, either as string names or as references to the\n   * `objectType()` return value\n   */\n  members(...unionMembers: UnionMembers) {\n    this.typeBuilder.addUnionMembers(unionMembers)\n  }\n}\n\nexport type NexusUnionTypeConfig<TypeName extends string> = {\n  /** The name of the union type */\n  name: TypeName\n  /** Builds the definition for the union */\n  definition(t: UnionDefinitionBlock): void\n  /** The description to annotate the GraphQL SDL */\n  description?: Maybe<string>\n  /**\n   * Info about a field deprecation. Formatted as a string and provided with the deprecated directive on\n   * field/enum types and as a comment on input fields.\n   */\n  deprecation?: Maybe<string> // | DeprecationInfo;\n  /** Source type information for this type */\n  sourceType?: SourceTypingDef\n  /**\n   * Custom extensions, as supported in graphql-js\n   *\n   * @see https://github.com/graphql/graphql-js/issues/1527\n   */\n  extensions?: GraphQLUnionTypeConfig<any, any>['extensions']\n  /** Adds this type as a method on the Object/Interface definition blocks */\n  asNexusMethod?: string\n} & AbstractTypes.MaybeTypeDefConfigFieldResolveType<TypeName>\n\nexport class NexusUnionTypeDef<TypeName extends string> {\n  constructor(readonly name: TypeName, protected config: NexusUnionTypeConfig<TypeName>) {\n    assertValidName(name)\n  }\n  get value() {\n    return this.config\n  }\n}\n\nwithNexusSymbol(NexusUnionTypeDef, NexusTypes.Union)\n\n/**\n * [API Docs](https://nxs.li/docs/api/union-type) | [Abstract Types\n * Guide](https://nxs.li/guides/abstract-types) | [2018 GraphQL Spec](https://spec.graphql.org/June2018/#sec-Unions)\n *\n * Defines a Union type.\n *\n * Union types are one of the two abstract type in GraphQL. They let you express polymorphic fields where\n * members types can be totally different.\n *\n * @example\n *   export const Media = unionType({\n *     name: 'SearchResult',\n *     resolveType(source) {\n *       return 'director' in source ? 'Movie' : 'Song'\n *     },\n *     definition(t) {\n *       t.members('Movie', 'Song')\n *     },\n *   })\n *\n *   export const Movie = objectType({\n *     name: 'Movie',\n *     definition(t) {\n *       t.string('url')\n *       t.string('director')\n *     },\n *   })\n *\n *   export const Song = objectType({\n *     name: 'Song',\n *     definition(t) {\n *       t.string('url')\n *       t.string('album')\n *     },\n *   })\n *\n *   // GraphQL SDL\n *   // -----------\n *   //\n *   // union SearchResult = Movie | Song\n *   //\n *   // type Movie {\n *   //   director: String\n *   //   url: String\n *   // }\n *   //\n *   // type Song {\n *   //   album: String\n *   //   url: String\n *   // }\n *\n * @param config Specify your union's name, its members, and more. See each config property's jsDoc for more detail.\n */\nexport function unionType<TypeName extends string>(config: NexusUnionTypeConfig<TypeName>) {\n  return new NexusUnionTypeDef(config.name, config)\n}\n"],"names":[],"mappings":";;;;;;;;AAAA,OAAO,EAAE,eAAe,EAA0B,MAAM,SAAS,CAAA;AAGjE,OAAO,EAAwB,UAAU,EAAmB,eAAe,EAAE,MAAM,UAAU,CAAA;;;AASvF,MAAO,oBAAoB;IAC/B,YAAsB,WAAmC,CAAA;QAAnC,IAAA,CAAA,WAAW,GAAX,WAAW,CAAwB;IAAG,CAAC;IAC7D;;;OAGG,CACH,OAAO,CAAC,GAAG,YAA0B,EAAA;QACnC,IAAI,CAAC,WAAW,CAAC,eAAe,CAAC,YAAY,CAAC,CAAA;IAChD,CAAC;CACF;AA0BK,MAAO,iBAAiB;IAC5B,YAAqB,IAAc,EAAY,MAAsC,CAAA;QAAhE,IAAA,CAAA,IAAI,GAAJ,IAAI,CAAU;QAAY,IAAA,CAAA,MAAM,GAAN,MAAM,CAAgC;YACnF,kOAAe,EAAC,IAAI,CAAC,CAAA;IACvB,CAAC;IACD,IAAI,KAAK,GAAA;QACP,OAAO,IAAI,CAAC,MAAM,CAAA;IACpB,CAAC;CACF;IAED,uPAAe,EAAC,iBAAiB,EAAE,kPAAU,CAAC,KAAK,CAAC,CAAA;AAuD9C,SAAU,SAAS,CAA0B,MAAsC;IACvF,OAAO,IAAI,iBAAiB,CAAC,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,CAAA;AACnD,CAAC"}},
    {"offset": {"line": 608, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/blocks.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/blocks.ts"],"sourcesContent":["export { InputDefinitionBlock, OutputDefinitionBlock } from './definitions/definitionBlocks'\nexport { InterfaceDefinitionBlock } from './definitions/interfaceType'\nexport { ObjectDefinitionBlock } from './definitions/objectType'\nexport { UnionDefinitionBlock } from './definitions/unionType'\n"],"names":[],"mappings":";AAAA,OAAO,EAAE,oBAAoB,EAAE,qBAAqB,EAAE,MAAM,gCAAgC,CAAA;AAC5F,OAAO,EAAE,wBAAwB,EAAE,MAAM,6BAA6B,CAAA;AACtE,OAAO,EAAE,qBAAqB,EAAE,MAAM,0BAA0B,CAAA;AAChE,OAAO,EAAE,oBAAoB,EAAE,MAAM,yBAAyB,CAAA"}},
    {"offset": {"line": 642, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/definitions/decorateType.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/definitions/decorateType.ts"],"sourcesContent":["import type { GraphQLNamedType } from 'graphql'\nimport type { SourceTypingDef } from './_types'\n\nexport interface TypeExtensionConfig {\n  asNexusMethod?: string\n  sourceType?: SourceTypingDef\n}\n\nexport function decorateType<T extends GraphQLNamedType>(type: T, config: TypeExtensionConfig): T {\n  type.extensions = {\n    ...type.extensions,\n    nexus: {\n      ...Object(type.extensions?.nexus),\n      ...config,\n    },\n  }\n  return type\n}\n"],"names":[],"mappings":";;;;AAQM,SAAU,YAAY,CAA6B,IAAO,EAAE,MAA2B;;IAC3F,IAAI,CAAC,UAAU,GAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACV,IAAI,CAAC,UAAU,GAAA;QAClB,KAAK,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACA,MAAM,CAAC,CAAA,KAAA,IAAI,CAAC,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,KAAK,CAAC,GAC9B,MAAM;IAAA,EAEZ,CAAA;IACD,OAAO,IAAI,CAAA;AACb,CAAC"}},
    {"offset": {"line": 657, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/definitions/nexusMeta.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/definitions/nexusMeta.ts"],"sourcesContent":["import { ownProp } from '../utils'\nimport type { NexusInterfaceTypeDef } from './interfaceType'\nimport type { NexusObjectTypeDef } from './objectType'\nimport { isNexusStruct, isNexusInterfaceTypeDef, isNexusObjectTypeDef } from './wrapping'\n\n/** Symbol marking an object as something that can provide Nexus schema definitions */\nexport const NEXUS_TYPE = Symbol.for('@nexus/meta/NEXUS_TYPE')\nexport const NEXUS_BUILD = Symbol.for('@nexus/meta/NEXUS_BUILD')\n\ntype OutType = NexusObjectTypeDef<any> | NexusInterfaceTypeDef<any>\n\n/** Object representing a single output or interface type */\nexport type NexusMetaTypeProp = {\n  [NEXUS_TYPE]: OutType\n}\n\nexport type NexusMetaTypeFn = {\n  [NEXUS_TYPE]: () => OutType\n}\n\nexport type NexusMetaType = NexusMetaTypeProp | NexusMetaTypeFn\n\n/** Object containing a symbol defining a function that should be fed into the Nexus type construction layer */\nexport type NexusMetaBuild = {\n  [NEXUS_BUILD]: () => any\n}\n\nexport type NexusMeta = NexusMetaType | NexusMetaBuild\n\nexport function isNexusMetaBuild(obj: any): obj is NexusMetaBuild {\n  return Boolean(obj && typeof ownProp.get(obj, NEXUS_BUILD) === 'function')\n}\n\nexport function isNexusMetaType(obj: any): obj is NexusMetaType {\n  return isNexusMetaTypeProp(obj) || isNexusMetaTypeFn(obj)\n}\n\nexport function isNexusMetaTypeProp(obj: any): obj is NexusMetaTypeProp {\n  return Boolean(obj && ownProp.has(obj, NEXUS_TYPE) && isNexusStruct(ownProp.get(obj, NEXUS_TYPE)))\n}\n\nexport function isNexusMetaTypeFn(obj: any): obj is NexusMetaTypeFn {\n  return Boolean(obj && ownProp.has(obj, NEXUS_TYPE) && typeof ownProp.get(obj, NEXUS_TYPE) === 'function')\n}\n\nexport function isNexusMeta(obj: any): obj is NexusMetaBuild | NexusMetaTypeFn | NexusMetaType {\n  return isNexusMetaBuild(obj) || isNexusMetaType(obj) || isNexusMetaTypeFn(obj)\n}\n\n/**\n * Evaluates the thunk, replacing it with the type\n *\n * @param obj\n */\nexport function resolveNexusMetaType(obj: NexusMetaType): OutType {\n  let value = ownProp.get(obj, NEXUS_TYPE)\n  if (typeof value === 'function') {\n    value = ownProp.set(obj, NEXUS_TYPE, value.call(obj))\n  }\n  if (!isNexusObjectTypeDef(value) && !isNexusInterfaceTypeDef(value)) {\n    throw new Error(`Expected property of NEXUS_TYPE to be an object or interface type`)\n  }\n  return value\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,UAAU,CAAA;AAGlC,OAAO,EAAE,aAAa,EAAE,uBAAuB,EAAE,oBAAoB,EAAE,MAAM,YAAY,CAAA;;;AAGlF,MAAM,UAAU,GAAG,MAAM,CAAC,GAAG,CAAC,wBAAwB,CAAC,CAAA;AACvD,MAAM,WAAW,GAAG,MAAM,CAAC,GAAG,CAAC,yBAAyB,CAAC,CAAA;AAsB1D,SAAU,gBAAgB,CAAC,GAAQ;IACvC,OAAO,OAAO,CAAC,GAAG,IAAI,OAAO,+NAAO,CAAC,GAAG,CAAC,GAAG,EAAE,WAAW,CAAC,KAAK,UAAU,CAAC,CAAA;AAC5E,CAAC;AAEK,SAAU,eAAe,CAAC,GAAQ;IACtC,OAAO,mBAAmB,CAAC,GAAG,CAAC,IAAI,iBAAiB,CAAC,GAAG,CAAC,CAAA;AAC3D,CAAC;AAEK,SAAU,mBAAmB,CAAC,GAAQ;IAC1C,OAAO,OAAO,CAAC,GAAG,IAAI,+NAAO,CAAC,GAAG,CAAC,GAAG,EAAE,UAAU,CAAC,QAAI,uPAAa,EAAC,+NAAO,CAAC,GAAG,CAAC,GAAG,EAAE,UAAU,CAAC,CAAC,CAAC,CAAA;AACpG,CAAC;AAEK,SAAU,iBAAiB,CAAC,GAAQ;IACxC,OAAO,OAAO,CAAC,GAAG,IAAI,+NAAO,CAAC,GAAG,CAAC,GAAG,EAAE,UAAU,CAAC,IAAI,OAAO,+NAAO,CAAC,GAAG,CAAC,GAAG,EAAE,UAAU,CAAC,KAAK,UAAU,CAAC,CAAA;AAC3G,CAAC;AAEK,SAAU,WAAW,CAAC,GAAQ;IAClC,OAAO,gBAAgB,CAAC,GAAG,CAAC,IAAI,eAAe,CAAC,GAAG,CAAC,IAAI,iBAAiB,CAAC,GAAG,CAAC,CAAA;AAChF,CAAC;AAOK,SAAU,oBAAoB,CAAC,GAAkB;IACrD,IAAI,KAAK,GAAG,+NAAO,CAAC,GAAG,CAAC,GAAG,EAAE,UAAU,CAAC,CAAA;IACxC,IAAI,OAAO,KAAK,KAAK,UAAU,EAAE;QAC/B,KAAK,GAAG,+NAAO,CAAC,GAAG,CAAC,GAAG,EAAE,UAAU,EAAE,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAA;KACtD;IACD,IAAI,KAAC,8PAAoB,EAAC,KAAK,CAAC,IAAI,KAAC,iQAAuB,EAAC,KAAK,CAAC,EAAE;QACnE,MAAM,IAAI,KAAK,CAAC,CAAA,iEAAA,CAAmE,CAAC,CAAA;KACrF;IACD,OAAO,KAAK,CAAA;AACd,CAAC"}},
    {"offset": {"line": 709, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/package.json"],"sourcesContent":["{\"name\":\"nexus\",\"version\":\"1.3.0\",\"description\":\"Scalable, strongly typed GraphQL schema development\",\"keywords\":[\"graphql\",\"schema\",\"types\",\"typescript\"],\"homepage\":\"https://nexusjs.org\",\"repository\":{\"type\":\"git\",\"url\":\"git://github.com/graphql-nexus/nexus.git\"},\"license\":\"MIT\",\"author\":{\"name\":\"Tim Griesser\",\"url\":\"https://github.com/tgriesser\"},\"files\":[\"src\",\"dist\",\"dist-esm\",\"LICENSE.md\",\"README.md\",\"yarn.lock\"],\"main\":\"dist\",\"module\":\"dist-esm\",\"types\":\"dist/index.d.ts\",\"scripts\":{\"build\":\"yarn -s clean && tsc -p tsconfig.cjs.json && tsc -p tsconfig.esm.json\",\"clean\":\"rm -rf dist*\",\"deploy-site\":\"yarn && yarn build\",\"dev\":\"tsc -p tsconfig.cjs.json -w\",\"dev:examples\":\"yarn -s link-examples && yarn dev\",\"dev:test\":\"jest --watch\",\"examples\":\"yarn link-examples && yarn gulp run-examples\",\"format\":\"prettier --write 'src/**/*.ts' 'tests/**/*.ts' 'examples/*/src/**.ts'\",\"format:ci\":\"prettier --check 'src/**/*.ts' 'tests/**/*.ts' 'examples/*/src/**.ts'\",\"link-examples\":\"yarn && yarn gulp link-examples\",\"lint\":\"tslint -p tsconfig.json\",\"prepublish\":\"yarn clean && yarn build\",\"postpublish\":\"yarn upgrade-deps || echo 'Oops...'\",\"release:pr\":\"dripip pr\",\"release:preview\":\"dripip preview\",\"release:stable\":\"dripip stable\",\"test\":\"yarn test:types && jest --testTimeout 10000\",\"test:ci\":\"yarn test:types && jest --maxWorkers 2 --coverage --testTimeout 10000\",\"test:debug\":\"node --inspect-brk $(yarn bin)/jest -i --watch\",\"test:types\":\"tsc -p tsconfig.spec.types.json\",\"ts-ast-reader\":\"cd examples/ts-ast-reader && yarn start\",\"unlink-examples\":\"yarn && yarn gulp unlink-examples\",\"upgrade-deps\":\"yarn && yarn gulp upgrade-deps\"},\"husky\":{\"hooks\":{\"pre-commit\":\"lint-staged\"}},\"lint-staged\":{\"*.{ts,js,graphql,json,css,md}\":[\"prettier --write\",\"git add\"],\"*package.json\":[\"sort-package-json\",\"git add\"]},\"dependencies\":{\"iterall\":\"^1.3.0\",\"tslib\":\"^2.0.3\"},\"devDependencies\":{\"@types/graphql-iso-date\":\"^3.4.0\",\"@types/graphql-relay\":\"^0.4.11\",\"@types/jest\":\"^26.0.15\",\"@types/node\":\"^10.12.2\",\"@types/prettier\":\"^1.18.3\",\"@typescript-eslint/eslint-plugin\":\"2.7.0\",\"dripip\":\"^0.10.0\",\"eslint\":\"^6.6.0\",\"get-port\":\"^5.1.1\",\"graphql\":\"^16.3.0\",\"graphql-relay\":\"^0.10.0\",\"graphql-scalars\":\"^1.14.1\",\"gulp\":\"4.0.2\",\"husky\":\"^1.1.2\",\"jest\":\"^26.6.3\",\"jest-watch-typeahead\":\"^0.6.1\",\"lint-staged\":\"^7.3.0\",\"prettier\":\"^2.5.1\",\"sort-package-json\":\"^1.22.1\",\"ts-jest\":\"^26.4.4\",\"ts-morph\":\"^13.0.3\",\"ts-node\":\"^9.0.0\",\"tsd\":\"^0.13.1\",\"tslint\":\"^5.11.0\",\"tslint-config-prettier\":\"^1.15.0\",\"typescript\":\"^4.5.5\"},\"peerDependencies\":{\"graphql\":\"15.x || 16.x\"}}"],"names":[],"mappings":"AAAA"}},
    {"offset": {"line": 709, "column": 2585}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 713, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/utils.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/utils.ts"],"sourcesContent":["import * as fs from 'fs'\nimport {\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLInterfaceTypeConfig,\n  GraphQLNamedType,\n  GraphQLObjectType,\n  GraphQLResolveInfo,\n  GraphQLScalarType,\n  GraphQLSchema,\n  GraphQLType,\n  GraphQLUnionType,\n  isAbstractType,\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n  isScalarType,\n  isSpecifiedScalarType,\n  isUnionType,\n  isWrappingType,\n  specifiedScalarTypes,\n} from 'graphql'\nimport * as Path from 'path'\nimport { decorateType } from './definitions/decorateType'\nimport { isNexusMetaType, NexusMetaType, resolveNexusMetaType } from './definitions/nexusMeta'\nimport {\n  AllNexusArgsDefs,\n  AllNexusNamedTypeDefs,\n  AllNexusTypeDefs,\n  isNexusWrappingType,\n  isNexusArgDef,\n  AllNamedInputTypeDefs,\n} from './definitions/wrapping'\nimport {\n  Maybe,\n  MissingType,\n  NexusFeatures,\n  NexusGraphQLSchema,\n  NexusTypes,\n  TypingImport,\n  withNexusSymbol,\n} from './definitions/_types'\n\nexport const isInterfaceField = (type: GraphQLObjectType, fieldName: string) => {\n  return type.getInterfaces().some((i) => Boolean(i.getFields()[fieldName]))\n}\n\n// ----------------------------\n\n/** Copied from graphql-js: */\n\n/**\n * Given an invalid input string and a list of valid options, returns a filtered list of valid options sorted\n * based on their similarity with the input.\n */\nexport function suggestionList(input: string = '', options: string[] = []): string[] {\n  var optionsByDistance = Object.create(null)\n  var oLength = options.length\n  var inputThreshold = input.length / 2\n\n  for (var i = 0; i < oLength; i++) {\n    var distance = lexicalDistance(input, options[i])\n    var threshold = Math.max(inputThreshold, options[i].length / 2, 1)\n\n    if (distance <= threshold) {\n      optionsByDistance[options[i]] = distance\n    }\n  }\n\n  return Object.keys(optionsByDistance).sort(function (a, b) {\n    return optionsByDistance[a] - optionsByDistance[b]\n  })\n}\n/**\n * Computes the lexical distance between strings A and B.\n *\n * The \"distance\" between two strings is given by counting the minimum number of edits needed to transform\n * string A into string B. An edit can be an insertion, deletion, or substitution of a single character, or a\n * swap of two adjacent characters.\n *\n * Includes a custom alteration from Damerau-Levenshtein to treat case changes as a single edit which helps\n * identify mis-cased values with an edit distance of 1.\n *\n * This distance can be useful for detecting typos in input or sorting\n */\nfunction lexicalDistance(aStr: string, bStr: string): number {\n  if (aStr === bStr) {\n    return 0\n  }\n\n  let i: number\n  let j: number\n  const d: number[][] = []\n  const a = aStr.toLowerCase()\n  const b = bStr.toLowerCase()\n  const aLength = a.length\n  const bLength = b.length // Any case change counts as a single edit\n\n  if (a === b) {\n    return 1\n  }\n\n  for (i = 0; i <= aLength; i++) {\n    d[i] = [i]\n  }\n\n  for (j = 1; j <= bLength; j++) {\n    d[0][j] = j\n  }\n\n  for (i = 1; i <= aLength; i++) {\n    for (j = 1; j <= bLength; j++) {\n      var cost = a[i - 1] === b[j - 1] ? 0 : 1\n      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost)\n\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost)\n      }\n    }\n  }\n\n  return d[aLength][bLength]\n}\n\n// ----------------------------\n\nexport function objValues<T>(obj: Record<string, T>): T[] {\n  return Object.keys(obj).reduce((result: T[], key) => {\n    result.push(obj[key])\n    return result\n  }, [])\n}\n\nexport function mapObj<T, R>(obj: Record<string, T>, mapper: (val: T, key: string, index: number) => R) {\n  return Object.keys(obj).map((key, index) => mapper(obj[key], key, index))\n}\n\nexport function mapValues<T, R>(obj: Record<string, T>, mapper: (val: T, key: string, index: number) => R) {\n  const result: Record<string, any> = {}\n  Object.keys(obj).forEach((key, index) => (result[key] = mapper(obj[key], key, index)))\n  return result\n}\n\nexport function eachObj<T>(obj: Record<string, T>, iter: (val: T, key: string, index: number) => void) {\n  Object.keys(obj).forEach((name, i) => iter(obj[name], name, i))\n}\n\nexport const isObject = (obj: any): boolean => obj !== null && typeof obj === 'object'\n\nexport const assertAbsolutePath = (pathName: string, property: string) => {\n  if (!Path.isAbsolute(pathName)) {\n    throw new Error(`Expected path for \"${property}\" to be an absolute path, saw \"${pathName}\"`)\n  }\n  return pathName\n}\n\nexport interface GroupedTypes {\n  input: GraphQLInputObjectType[]\n  interface: GraphQLInterfaceType[]\n  object: GraphQLObjectType[]\n  union: GraphQLUnionType[]\n  enum: GraphQLEnumType[]\n  scalar: Array<GraphQLScalarType & { asNexusMethod?: string }>\n}\n\nexport function groupTypes(schema: GraphQLSchema) {\n  const groupedTypes: GroupedTypes = {\n    input: [],\n    interface: [],\n    object: [],\n    union: [],\n    enum: [],\n    scalar: Array.from(specifiedScalarTypes),\n  }\n  const schemaTypeMap = schema.getTypeMap()\n  Object.keys(schemaTypeMap)\n    .sort()\n    .forEach((typeName) => {\n      if (typeName.startsWith('__')) {\n        return\n      }\n      const type = schema.getType(typeName)\n      if (isObjectType(type)) {\n        groupedTypes.object.push(type)\n      } else if (isInputObjectType(type)) {\n        groupedTypes.input.push(type)\n      } else if (isScalarType(type) && !isSpecifiedScalarType(type) && !isUnknownType(type)) {\n        groupedTypes.scalar.push(type)\n      } else if (isUnionType(type)) {\n        groupedTypes.union.push(type)\n      } else if (isInterfaceType(type)) {\n        groupedTypes.interface.push(type)\n      } else if (isEnumType(type)) {\n        groupedTypes.enum.push(type)\n      }\n    })\n  return groupedTypes\n}\n\nexport function isUnknownType(type: GraphQLNamedType) {\n  return type.name === UNKNOWN_TYPE_SCALAR.name\n}\n\nexport function firstDefined<T>(...args: Array<T | undefined>): T {\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i]\n    if (typeof arg !== 'undefined') {\n      return arg\n    }\n  }\n  /* istanbul ignore next */\n  throw new Error('At least one of the values should be defined')\n}\n\nexport function isPromiseLike(value: any): value is PromiseLike<any> {\n  return Boolean(value && typeof value.then === 'function')\n}\n\nexport const typeScriptFileExtension = /(\\.d)?\\.ts$/\n\nfunction makeRelativePathExplicitlyRelative(path: string) {\n  if (Path.isAbsolute(path)) return path\n  if (path.startsWith('./')) return path\n  return `./${path}`\n}\n\nfunction nixifyPathSlashes(path: string): string {\n  return path.replace(/\\\\+/g, '/')\n}\n\n/**\n * Format a path so it is suitable to be used as a module import.\n *\n * - Implicitly relative is made explicitly relative - TypeScript file extension is stripped - Windows slashes\n * converted into *nix slashes\n *\n * Do not pass Node module IDs here as they will be treated as relative paths e.g. \"react\" \"@types/react\" etc.\n */\nexport function formatPathForModuleImport(path: string) {\n  return nixifyPathSlashes(makeRelativePathExplicitlyRelative(path).replace(typeScriptFileExtension, ''))\n}\n\nexport function relativePathTo(absolutePath: string, fromPath: string): string {\n  const filename = Path.basename(absolutePath)\n  const relative = Path.relative(Path.dirname(fromPath), Path.dirname(absolutePath))\n  return formatPathForModuleImport(Path.join(relative, filename))\n}\n\nexport interface PrintedGenTypingImportConfig {\n  module: string\n  default?: string\n  bindings?: Array<string | [string, string]> // import { X } or import { X as Y }\n}\n\nexport class PrintedGenTypingImport {\n  constructor(readonly config: PrintedGenTypingImportConfig) {}\n}\nwithNexusSymbol(PrintedGenTypingImport, NexusTypes.PrintedGenTypingImport)\n\nexport function printedGenTypingImport(config: PrintedGenTypingImportConfig) {\n  return new PrintedGenTypingImport(config)\n}\n\nexport interface PrintedGenTypingConfig {\n  name: string\n  optional: boolean\n  type: string\n  description?: Maybe<string>\n  imports?: PrintedGenTypingImport[]\n}\n\nexport class PrintedGenTyping {\n  constructor(protected config: PrintedGenTypingConfig) {}\n\n  get imports() {\n    return this.config.imports || []\n  }\n\n  toString() {\n    let str = ``\n    if (this.config.description) {\n      const descriptionLines = this.config.description\n        .split('\\n')\n        .map((s) => s.trim())\n        .filter((s) => s)\n        .map((s) => ` * ${s}`)\n        .join('\\n')\n      str = `/**\\n${descriptionLines}\\n */\\n`\n    }\n    const field = `${this.config.name}${this.config.optional ? '?' : ''}`\n    str += `${field}: ${this.config.type}`\n    return str\n  }\n}\nwithNexusSymbol(PrintedGenTyping, NexusTypes.PrintedGenTyping)\n\nexport function printedGenTyping(config: PrintedGenTypingConfig) {\n  return new PrintedGenTyping(config)\n}\n\nexport function assertNoMissingTypes(schema: GraphQLSchema, missingTypes: Record<string, MissingType>) {\n  const missingTypesNames = Object.keys(missingTypes)\n  const schemaTypeMap = schema.getTypeMap()\n  const schemaTypeNames = Object.keys(schemaTypeMap).filter(\n    (typeName) => !isUnknownType(schemaTypeMap[typeName])\n  )\n\n  if (missingTypesNames.length > 0) {\n    const errors = missingTypesNames\n      .map((typeName) => {\n        const { fromObject } = missingTypes[typeName]\n\n        if (fromObject) {\n          return `- Looks like you forgot to import ${typeName} in the root \"types\" passed to Nexus makeSchema`\n        }\n\n        const suggestions = suggestionList(typeName, schemaTypeNames)\n\n        let suggestionsString = ''\n\n        if (suggestions.length > 0) {\n          suggestionsString = ` or mean ${suggestions.join(', ')}`\n        }\n\n        return `- Missing type ${typeName}, did you forget to import a type to the root query${suggestionsString}?`\n      })\n      .join('\\n')\n\n    throw new Error('\\n' + errors)\n  }\n}\n\nexport function runAbstractTypeRuntimeChecks(schema: NexusGraphQLSchema, features: NexusFeatures) {\n  if (features.abstractTypeRuntimeChecks === false) {\n    return\n  }\n\n  const abstractTypes = Object.values(schema.getTypeMap()).filter(isAbstractType)\n\n  abstractTypes.forEach((type) => {\n    const kind = isInterfaceType(type) ? 'Interface' : 'Union'\n    const resolveTypeImplemented = type.resolveType !== undefined\n    const typesWithoutIsTypeOf = schema.getPossibleTypes(type).filter((type) => type.isTypeOf === undefined)\n\n    // if no resolveType implemented but resolveType strategy enabled and isTypeOf strategy disabled\n    if (\n      resolveTypeImplemented === false &&\n      features.abstractTypeStrategies.resolveType === true &&\n      features.abstractTypeStrategies.isTypeOf === false\n    ) {\n      const messagePrefix = `You have a faulty implementation for your ${kind.toLowerCase()} type \"${\n        type.name\n      }\".`\n      const message = `${messagePrefix} It is missing a \\`resolveType\\` implementation.`\n      raiseProgrammerError(new Error(message))\n    }\n\n    // if some isTypeOf implementations are missing but isTypeOf strategy enabled\n    if (\n      typesWithoutIsTypeOf.length > 0 &&\n      features.abstractTypeStrategies.isTypeOf === true &&\n      features.abstractTypeStrategies.resolveType === false\n    ) {\n      const messageBadTypes = typesWithoutIsTypeOf.map((t) => `\"${t.name}\"`).join(', ')\n      const messagePrefix = `You have a faulty implementation for your ${kind.toLowerCase()} type \"${\n        type.name\n      }\".`\n      const messageSuffix = `are missing an \\`isTypeOf\\` implementation: ${messageBadTypes}`\n      let message\n      if (kind === 'Union') {\n        message = `${messagePrefix} Some members of union type \"${type.name}\" ${messageSuffix}`\n      } else if (kind === 'Interface') {\n        message = `${messagePrefix} Some objects implementing the interface type \"${type.name}\" ${messageSuffix}`\n      } else {\n        casesHandled(kind)\n      }\n      raiseProgrammerError(new Error(message))\n    }\n\n    // if some isTypeOf or resolveType implementations are missing but isTypeOf and resolveType strategy enabled\n    if (\n      (resolveTypeImplemented === false || typesWithoutIsTypeOf.length > 0) &&\n      features.abstractTypeStrategies.isTypeOf === true &&\n      features.abstractTypeStrategies.resolveType === true\n    ) {\n      const messageBadTypes = typesWithoutIsTypeOf.map((t) => `\"${t.name}\"`).join(', ')\n      const messagePrefix = `You have a faulty implementation for your ${kind.toLowerCase()} type \"${\n        type.name\n      }\". Either implement its \\`resolveType\\` or implement \\`isTypeOf\\` on each object`\n      const messageSuffix = `These objects are missing an \\`isTypeOf\\` implementation: ${messageBadTypes}`\n      let message\n      if (kind === 'Union') {\n        message = `${messagePrefix} in the union. ${messageSuffix}`\n      } else if (kind === 'Interface') {\n        message = `${messagePrefix} that implements this interface. ${messageSuffix}`\n      } else {\n        casesHandled(kind)\n      }\n      raiseProgrammerError(new Error(message))\n    }\n  })\n}\n\nexport function consoleWarn(msg: string) {\n  console.warn(msg)\n}\n\nexport function log(msg: string) {\n  console.log(`Nexus Schema: ${msg}`)\n}\n\n/**\n * Calculate the venn diagram between two iterables based on reference equality checks. The returned tripple\n * contains items thusly:\n *\n *     * items only in arg 1 --> first tripple slot\n *     * items in args 1 & 2 --> second tripple slot\n *     * items only in arg 2 --> third tripple slot\n */\nexport function venn<T>(xs: Iterable<T>, ys: Iterable<T>): [Set<T>, Set<T>, Set<T>] {\n  const lefts: Set<T> = new Set(xs)\n  const boths: Set<T> = new Set()\n  const rights: Set<T> = new Set(ys)\n\n  lefts.forEach((l) => {\n    if (rights.has(l)) {\n      boths.add(l)\n      lefts.delete(l)\n      rights.delete(l)\n    }\n  })\n\n  return [lefts, boths, rights]\n}\n\nexport const UNKNOWN_TYPE_SCALAR = decorateType(\n  new GraphQLScalarType({\n    name: 'NEXUS__UNKNOWN__TYPE',\n    description: `\n    This scalar should never make it into production. It is used as a placeholder for situations\n    where GraphQL Nexus encounters a missing type. We don't want to error immediately, otherwise\n    the TypeScript definitions will not be updated.\n  `,\n    parseValue(value) {\n      throw new Error('Error: NEXUS__UNKNOWN__TYPE is not a valid scalar.')\n    },\n    parseLiteral(value) {\n      throw new Error('Error: NEXUS__UNKNOWN__TYPE is not a valid scalar.')\n    },\n    serialize(value) {\n      throw new Error('Error: NEXUS__UNKNOWN__TYPE is not a valid scalar.')\n    },\n  }),\n  {\n    sourceType: 'never',\n  }\n)\n\nexport function pathToArray(infoPath: GraphQLResolveInfo['path']): Array<string | number> {\n  const flattened = []\n  let curr: GraphQLResolveInfo['path'] | undefined = infoPath\n  while (curr) {\n    flattened.push(curr.key)\n    curr = curr.prev\n  }\n  return flattened.reverse()\n}\n\nexport function getOwnPackage(): { name: string } {\n  return require('../package.json')\n}\n\n/** Use this to make assertion at end of if-else chain that all members of a union have been accounted for. */\nexport function casesHandled(x: never): never {\n  throw new Error(`A case was not handled for value: \"${x}\"`)\n}\n\n/** Quickly log objects */\nexport function dump(x: any) {\n  console.log(require('util').inspect(x, { depth: null }))\n}\n\nfunction isNodeModule(path: string) {\n  // Avoid treating absolute windows paths as Node packages e.g. D:/a/b/c\n  return !Path.isAbsolute(path) && /^([A-z0-9@])/.test(path)\n}\n\nexport function resolveImportPath(rootType: TypingImport, typeName: string, outputPath: string) {\n  const rootTypePath = rootType.module\n\n  if (typeof rootTypePath !== 'string' || (!Path.isAbsolute(rootTypePath) && !isNodeModule(rootTypePath))) {\n    throw new Error(\n      `Expected an absolute path or Node package for the root typing path of the type \"${typeName}\", saw \"${rootTypePath}\"`\n    )\n  }\n\n  if (isNodeModule(rootTypePath)) {\n    try {\n      require.resolve(rootTypePath)\n    } catch (e) {\n      throw new Error(`Module \"${rootTypePath}\" for the type \"${typeName}\" does not exist`)\n    }\n  } else if (!fs.existsSync(rootTypePath)) {\n    throw new Error(`Root typing path \"${rootTypePath}\" for the type \"${typeName}\" does not exist`)\n  }\n\n  if (isNodeModule(rootTypePath)) {\n    return rootTypePath\n  }\n\n  if (Path.isAbsolute(rootTypePath)) {\n    return relativePathTo(rootTypePath, outputPath)\n  }\n\n  return rootTypePath\n}\n\n/** Given the right hand side of an arg definition, returns the underlying \"named type\" for us to add to the builder */\nexport function getArgNamedType(argDef: AllNexusArgsDefs | string): AllNamedInputTypeDefs | string {\n  let finalValue = argDef\n  if (typeof finalValue === 'string') {\n    return finalValue\n  }\n  while (isNexusWrappingType(finalValue) || isWrappingType(finalValue) || isNexusArgDef(finalValue)) {\n    if (isNexusArgDef(finalValue)) {\n      finalValue = finalValue.value.type\n    } else if (isNexusWrappingType(finalValue)) {\n      finalValue = finalValue.ofNexusType\n    } else if (isWrappingType(finalValue)) {\n      finalValue = finalValue.ofType\n    }\n  }\n  return finalValue\n}\n\nexport function getNexusNamedType(\n  type: AllNexusTypeDefs | NexusMetaType | GraphQLType | string\n): AllNexusNamedTypeDefs | GraphQLNamedType | string {\n  if (typeof type === 'string') {\n    return type\n  }\n  let namedType = type\n  while (isNexusWrappingType(namedType) || isWrappingType(namedType) || isNexusMetaType(namedType)) {\n    if (isNexusWrappingType(namedType)) {\n      namedType = namedType.ofNexusType\n    }\n    if (isWrappingType(namedType)) {\n      namedType = namedType.ofType\n    }\n    if (isNexusMetaType(namedType)) {\n      namedType = resolveNexusMetaType(namedType)\n    }\n  }\n  return namedType as AllNexusNamedTypeDefs | GraphQLNamedType | string\n}\n\n/** Assertion utility with nexus-aware feedback for users. */\nexport function invariantGuard(val: any) {\n  /* istanbul ignore next */\n  if (Boolean(val) === false) {\n    throw new Error(\n      'Nexus Error: This should never happen, ' +\n        'please check your code or if you think this is a bug open a GitHub issue https://github.com/graphql-nexus/schema/issues/new.'\n    )\n  }\n}\n\n/** Is the current stage production? If NODE_ENV envar is set to \"production\" or \"prod\" then yes it is. */\nexport function isProductionStage() {\n  return process.env.NODE_ENV === 'production' || process.env.NODE_ENV === 'prod'\n}\n\n/** Throw a programmer error in production but only log it in development. */\nexport function raiseProgrammerError(error: Error) {\n  if (isProductionStage()) {\n    throw error\n  } else {\n    console.error(error)\n  }\n}\n\nexport class Unreachable extends Error {\n  /* istanbul ignore next */\n  constructor(val: never) {\n    super(`Unreachable case or branch, unexpected ${val}`)\n  }\n}\n\nexport function graphql15InterfaceConfig<T extends GraphQLInterfaceTypeConfig<any, any>>(\n  config: T\n): T & { interfaces: GraphQLInterfaceType[] } {\n  return {\n    ...config,\n    interfaces: [],\n  }\n}\n\nexport function graphql15InterfaceType<T extends GraphQLInterfaceType>(\n  type: T & { getInterfaces?: () => ReadonlyArray<GraphQLInterfaceType> }\n): T & { getInterfaces(): ReadonlyArray<GraphQLInterfaceType> } {\n  if (typeof type.getInterfaces !== 'function') {\n    type.getInterfaces = () => []\n  }\n  return type as T & { getInterfaces(): ReadonlyArray<GraphQLInterfaceType> }\n}\n\n/** @internal */\nexport function unpack<T extends object>(val: T | (() => T)): T {\n  if (val instanceof Function) {\n    return val()\n  }\n  return val\n}\n\n/**\n * A specially typed version of `Array.isArray` to work around [this\n * issue](https://github.com/microsoft/TypeScript/issues/17002).\n */\nexport function isArray<T>(\n  arg: T | {}\n): arg is T extends readonly any[] ? (unknown extends T ? never : readonly any[]) : any[] {\n  return Array.isArray(arg)\n}\n\nexport const ownProp = {\n  has<O extends object, K extends keyof O>(obj: O, key: K): boolean {\n    return Boolean(Object.getOwnPropertyDescriptor(obj, key))\n  },\n  set<O extends object, K extends keyof O>(obj: O, key: K, value: O[K]): O[K] {\n    Object.defineProperty(obj, key, { value })\n    return value\n  },\n  get<O extends object, K extends keyof O>(obj: O, key: K): O[K] | undefined {\n    return Object.getOwnPropertyDescriptor(obj, key)?.value\n  },\n}\n\nexport function result<T>(val: T | (() => T)): T {\n  if (val instanceof Function) {\n    return val()\n  }\n  return val as T\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1252, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/definitions/args.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/definitions/args.ts"],"sourcesContent":["import type { GraphQLScalarTypeConfig } from 'graphql'\nimport type { AllInputTypes, GetGen2 } from '../typegenTypeHelpers'\nimport type { AllNexusArgsDefs, AllNexusInputTypeDefs } from './wrapping'\nimport { Maybe, NexusTypes, withNexusSymbol } from './_types'\n\nexport type ArgsRecord = Record<string, AllNexusArgsDefs>\n\nexport type CommonArgConfig = {\n  /**\n   * [GraphQL 2018 Spec](https://spec.graphql.org/June2018/#sec-Descriptions)\n   *\n   * The description for this argument.\n   *\n   * Various GraphQL tools will make use of this information but it has zero runtime impact. The value given\n   * here will also be included as heredocs in the generated GraphQL SDL file.\n   *\n   * Default :: By default there will be no description\n   *\n   * @example\n   *   export const Query = queryType({\n   *     definition(t) {\n   *       t.list.int('connectionCount', {\n   *         args: {\n   *           lastSeconds: intArg({\n   *             description: 'Limit count to this number of past seconds from now.',\n   *           }),\n   *         },\n   *       })\n   *     },\n   *   })\n   *\n   *   // GraphQL SDL\n   *   // -----------\n   *   //\n   *   // type Query {\n   *   //   connectionCount(\n   *   //   \"\"\"Limit count to this number of past seconds from now.\"\"\"\n   *   //    lastSeconds: Int\n   *   //   ): [Int]\n   *   // }\n   */\n  description?: Maybe<string>\n\n  /**\n   * Data that will be added to the arg-level [extensions field on the graphql-js type def\n   * instances](https://github.com/graphql/graphql-js/issues/1527) resulting from makeSchema. Useful for some\n   * graphql-js based tools which rely on looking for special data here.\n   */\n  extensions?: GraphQLScalarTypeConfig<any, any>['extensions']\n} & NexusGenPluginArgConfig\n\nexport interface ScalarArgConfig<T> extends CommonArgConfig {\n  /**\n   * The default value for this argument when ***none*** is given by the client.\n   *\n   * Note that *null* is still considered something meaning if the client gives an explicit null that will\n   * prevent the default from activating. This is why the type of an arg with a default value in the resolver\n   * includes \"undefined | null\".\n   *\n   * @example\n   *   intArg({ default: 42 })\n   */\n  default?: T\n}\n\nexport type NexusArgConfigType<T extends string> = T | AllNexusInputTypeDefs<T>\n\nexport interface NexusAsArgConfig<T extends string> extends CommonArgConfig {\n  /**\n   * Sets the default value for this argument, should match the type of the argument\n   *\n   * @example\n   *   intArg({ default: 42 })\n   */\n  default?: GetGen2<'inputTypeShapes', T>\n}\n\nexport interface NexusArgConfig<T extends string> extends NexusAsArgConfig<T> {\n  /**\n   * [GraphQL 2018 Spec](https://spec.graphql.org/June2018/#sec-Types)\n   *\n   * The type that this argument should be.\n   *\n   * Argument types may be scalars or other input types (input objects, enums) in your schema and modified\n   * with non-null and list types.\n   *\n   * Types may be expressed in one of three ways:\n   *\n   * 1. As string literals matching the name of a builtin scalar. 2. As string literals matching the name of\n   * another type. Thanks to [Nexus' reflection\n   *     system](https://nxs.li/guides/reflection) this is typesafe and autocompletable. 3. As references to other\n   * enums or input object type definitions.\n   *\n   * Type modifier helpers like list() may also be used and in turn accept one of the three methods listed above.\n   *\n   * @example\n   *   arg({ type: 'UserCreateInput' })\n   *\n   * @example\n   *   arg({ type: nonNull(list(nonNull('UserCreateInput'))) })\n   *\n   * @example\n   *   arg({ type: UserCreateInput })\n   *\n   * @example\n   *   arg({ type: nonNull(list(nonNull(UserCreateInput))) })\n   *\n   * @example\n   *   arg({ type: 'String' })\n   */\n  type: NexusArgConfigType<T>\n}\n\nexport interface NexusFinalArgConfig extends NexusArgConfig<any> {\n  configFor: 'arg'\n  argName: string\n  fieldName: string\n  parentType: string\n}\n\nexport class NexusArgDef<TypeName extends AllInputTypes> {\n  constructor(readonly name: TypeName, protected config: NexusArgConfig<any>) {}\n  get value() {\n    return this.config\n  }\n}\nwithNexusSymbol(NexusArgDef, NexusTypes.Arg)\n\n/**\n * [API Docs](https://nexusjs.org/docs/api/args) | [GraphQL.org\n * Docs](https://graphql.github.io/learn/schema/#arguments) | [GraphQL 2018\n * Spec](https://spec.graphql.org/June2018/#sec-Language.Arguments)\n *\n * Define an argument. Arguments can be used with the args config of any field.\n *\n * @example\n *   export const Mutation = mutationType({\n *     definition(t) {\n *       t.field('createDraft', {\n *         type: 'Post',\n *         args: {\n *           title: arg({\n *             type: 'String',\n *             default: 'Untitled',\n *             description: 'The title of this draft post.',\n *           }),\n *           body: nonNull(\n *             arg({\n *               type: 'String',\n *               description: 'The content of this draft post.',\n *             })\n *           ),\n *         },\n *         // ...\n *       })\n *     },\n *   })\n *\n * @param config Configuration for the argument like its type and description. See jsdoc on each config field\n *     for details.\n */\nexport function arg<T extends string>(config: NexusArgConfig<T>) {\n  if (!config.type) {\n    throw new Error('You must provide a \"type\" for the arg()')\n  }\n  return new NexusArgDef(typeof config.type === 'string' ? config.type : (config.type as any).name, config)\n}\n\n/**\n * [API Docs](https://nexusjs.org/docs/api/args) | [GraphQL.org\n * Docs](https://graphql.github.io/learn/schema/#arguments) | [GraphQL 2018\n * Spec](https://spec.graphql.org/June2018/#sec-Language.Arguments)\n *\n * Define a string argument. Arguments can be used with the args config of any field.\n *\n * This is a shorthand equivalent to:\n *\n * `arg({ type: 'String', ... })`\n *\n * @example\n *   export const Mutation = mutationType({\n *     definition(t) {\n *       t.field('createDraft', {\n *         type: 'Post',\n *         args: {\n *           title: stringArg(),\n *           body: stringArg(),\n *         },\n *         // ...\n *       })\n *     },\n *   })\n *\n * @param config Configuration for the argument like its description. See jsdoc on each config field for details.\n */\nexport function stringArg(config?: ScalarArgConfig<string>) {\n  return arg({ type: 'String', ...config })\n}\n\n/**\n * [API Docs](https://nexusjs.org/docs/api/args) | [GraphQL.org\n * Docs](https://graphql.github.io/learn/schema/#arguments) | [GraphQL 2018\n * Spec](https://spec.graphql.org/June2018/#sec-Language.Arguments)\n *\n * Define a string argument. Arguments can be used with the args config of any field.\n *\n * This is a shorthand equivalent to:\n *\n * `arg({ type: 'Int', ... })`\n *\n * @example\n *   export const Query = queryType({\n *     definition(t) {\n *       t.field('search', {\n *         type: 'SearchResult',\n *         args: {\n *           maxResults: intArg(),\n *         },\n *         // ...\n *       })\n *     },\n *   })\n *\n * @param config Configuration for the argument like its description. See jsdoc on each config field for details.\n */\nexport function intArg(config?: ScalarArgConfig<number>) {\n  return arg({ type: 'Int', ...config })\n}\n\n/**\n * [API Docs](https://nexusjs.org/docs/api/args) | [GraphQL.org\n * Docs](https://graphql.github.io/learn/schema/#arguments) | [GraphQL 2018\n * Spec](https://spec.graphql.org/June2018/#sec-Language.Arguments)\n *\n * Define a string argument. Arguments can be used with the args config of any field.\n *\n * This is a shorthand equivalent to:\n *\n * `arg({ type: 'Float', ... })`\n *\n * @example\n *   export const Query = queryType({\n *     definition(t) {\n *       t.field('search', {\n *         type: 'SearchResult',\n *         args: {\n *           ratingAbove: floatArg(),\n *         },\n *         // ...\n *       })\n *     },\n *   })\n *\n * @param config Configuration for the argument like its description. See jsdoc on each config field for details.\n */\nexport function floatArg(config?: ScalarArgConfig<number>) {\n  return arg({ type: 'Float', ...config })\n}\n\n/**\n * [API Docs](https://nexusjs.org/docs/api/args) | [GraphQL.org\n * Docs](https://graphql.github.io/learn/schema/#arguments) | [GraphQL 2018\n * Spec](https://spec.graphql.org/June2018/#sec-Language.Arguments)\n *\n * Define a string argument. Arguments can be used with the args config of any field.\n *\n * This is a shorthand equivalent to:\n *\n * `arg({ type: 'ID', ... })`\n *\n * @example\n *   export const Query = queryType({\n *     definition(t) {\n *       t.field('user', {\n *         type: 'User',\n *         args: {\n *           id: idArg(),\n *         },\n *         // ...\n *       })\n *     },\n *   })\n *\n * @param config Configuration for the argument like its description. See jsdoc on each config field for details.\n */\nexport function idArg(config?: ScalarArgConfig<string>) {\n  return arg({ type: 'ID', ...config })\n}\n\n/**\n * [API Docs](https://nexusjs.org/docs/api/args) | [GraphQL.org\n * Docs](https://graphql.github.io/learn/schema/#arguments) | [GraphQL 2018\n * Spec](https://spec.graphql.org/June2018/#sec-Language.Arguments)\n *\n * Define a string argument. Arguments can be used with the args config of any field.\n *\n * This is a shorthand equivalent to:\n *\n * `arg({ type: 'Boolean', ... })`\n *\n * @example\n *   export const Query = queryType({\n *     definition(t) {\n *       t.list.field('users', {\n *         type: 'User',\n *         args: {\n *           active: booleanArg(),\n *         },\n *         // ...\n *       })\n *     },\n *   })\n *\n * @param config Configuration for the argument like its description. See jsdoc on each config field for details.\n */\nexport function booleanArg(config?: ScalarArgConfig<boolean>) {\n  return arg({ type: 'Boolean', ...config })\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAGA,OAAO,EAAS,UAAU,EAAE,eAAe,EAAE,MAAM,UAAU,CAAA;;AAqHvD,MAAO,WAAW;IACtB,YAAqB,IAAc,EAAY,MAA2B,CAAA;QAArD,IAAA,CAAA,IAAI,GAAJ,IAAI,CAAU;QAAY,IAAA,CAAA,MAAM,GAAN,MAAM,CAAqB;IAAG,CAAC;IAC9E,IAAI,KAAK,GAAA;QACP,OAAO,IAAI,CAAC,MAAM,CAAA;IACpB,CAAC;CACF;IACD,uPAAe,EAAC,WAAW,EAAE,kPAAU,CAAC,GAAG,CAAC,CAAA;AAmCtC,SAAU,GAAG,CAAmB,MAAyB;IAC7D,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE;QAChB,MAAM,IAAI,KAAK,CAAC,yCAAyC,CAAC,CAAA;KAC3D;IACD,OAAO,IAAI,WAAW,CAAC,OAAO,MAAM,CAAC,IAAI,KAAK,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAE,MAAM,CAAC,IAAY,CAAC,IAAI,EAAE,MAAM,CAAC,CAAA;AAC3G,CAAC;AA6BK,SAAU,SAAS,CAAC,MAAgC;IACxD,OAAO,GAAG,CAAA,OAAA,MAAA,CAAA;QAAG,IAAI,EAAE,QAAQ;IAAA,GAAK,MAAM,EAAG,CAAA;AAC3C,CAAC;AA4BK,SAAU,MAAM,CAAC,MAAgC;IACrD,OAAO,GAAG,CAAA,OAAA,MAAA,CAAA;QAAG,IAAI,EAAE,KAAK;IAAA,GAAK,MAAM,EAAG,CAAA;AACxC,CAAC;AA4BK,SAAU,QAAQ,CAAC,MAAgC;IACvD,OAAO,GAAG,CAAA,OAAA,MAAA,CAAA;QAAG,IAAI,EAAE,OAAO;IAAA,GAAK,MAAM,EAAG,CAAA;AAC1C,CAAC;AA4BK,SAAU,KAAK,CAAC,MAAgC;IACpD,OAAO,GAAG,CAAA,OAAA,MAAA,CAAA;QAAG,IAAI,EAAE,IAAI;IAAA,GAAK,MAAM,EAAG,CAAA;AACvC,CAAC;AA4BK,SAAU,UAAU,CAAC,MAAiC;IAC1D,OAAO,GAAG,CAAA,OAAA,MAAA,CAAA;QAAG,IAAI,EAAE,SAAS;IAAA,GAAK,MAAM,EAAG,CAAA;AAC5C,CAAC"}},
    {"offset": {"line": 1315, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/definitions/list.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/definitions/list.ts"],"sourcesContent":["import { isType } from 'graphql'\nimport { isNexusMeta } from './nexusMeta'\nimport { isNexusStruct, NexusListableTypes } from './wrapping'\nimport { NexusTypes, withNexusSymbol } from './_types'\n\nexport class NexusListDef<TypeName extends NexusListableTypes> {\n  // @ts-ignore\n  // Required field for TS to differentiate NonNull from Null from List\n  private _isNexusListDef: boolean = true\n\n  constructor(readonly ofNexusType: TypeName) {\n    /* istanbul ignore if */\n    if (\n      typeof ofNexusType !== 'string' &&\n      !isNexusStruct(ofNexusType) &&\n      !isNexusMeta(ofNexusType) &&\n      !isType(ofNexusType)\n    ) {\n      throw new Error('Cannot wrap unknown types in list(). Saw ' + ofNexusType)\n    }\n  }\n}\n\nwithNexusSymbol(NexusListDef, NexusTypes.List)\n\nexport function list<TypeName extends NexusListableTypes>(type: TypeName): NexusListDef<TypeName> {\n  return new NexusListDef(type)\n}\n"],"names":[],"mappings":";;;;;;AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,SAAS,CAAA;AAChC,OAAO,EAAE,WAAW,EAAE,MAAM,aAAa,CAAA;AACzC,OAAO,EAAE,aAAa,EAAsB,MAAM,YAAY,CAAA;AAC9D,OAAO,EAAE,UAAU,EAAE,eAAe,EAAE,MAAM,UAAU,CAAA;;;;;AAEhD,MAAO,YAAY;IAKvB,YAAqB,WAAqB,CAAA;QAArB,IAAA,CAAA,WAAW,GAAX,WAAW,CAAU;QAJ1C,aAAa;QACb,qEAAqE;QAC7D,IAAA,CAAA,eAAe,GAAY,IAAI,CAAA;QAGrC,sBAAA,EAAwB,CACxB,IACE,OAAO,WAAW,KAAK,QAAQ,IAC/B,KAAC,uPAAa,EAAC,WAAW,CAAC,IAC3B,KAAC,sPAAW,EAAC,WAAW,CAAC,IACzB,KAAC,+MAAM,EAAC,WAAW,CAAC,EACpB;YACA,MAAM,IAAI,KAAK,CAAC,2CAA2C,GAAG,WAAW,CAAC,CAAA;SAC3E;IACH,CAAC;CACF;IAED,uPAAe,EAAC,YAAY,EAAE,kPAAU,CAAC,IAAI,CAAC,CAAA;AAExC,SAAU,IAAI,CAAsC,IAAc;IACtE,OAAO,IAAI,YAAY,CAAC,IAAI,CAAC,CAAA;AAC/B,CAAC"}},
    {"offset": {"line": 1348, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/definitions/nonNull.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/definitions/nonNull.ts"],"sourcesContent":["import { isNonNullType, isType } from 'graphql'\nimport { isNexusMeta } from './nexusMeta'\nimport { isNexusNonNullTypeDef, isNexusNullTypeDef, isNexusStruct, NexusNonNullableTypes } from './wrapping'\nimport { NexusTypes, withNexusSymbol } from './_types'\n\nexport class NexusNonNullDef<TypeName extends NexusNonNullableTypes> {\n  // @ts-ignore\n  // Required field for TS to differentiate NonNull from Null from List\n  private _isNexusNonNullDef: boolean = true\n\n  constructor(readonly ofNexusType: TypeName) {\n    if (\n      typeof ofNexusType !== 'string' &&\n      !isNexusStruct(ofNexusType) &&\n      !isNexusMeta(ofNexusType) &&\n      !isType(ofNexusType)\n    ) {\n      throw new Error('Cannot wrap unknown types in a nonNull(). Saw ' + ofNexusType)\n    }\n  }\n}\n\nwithNexusSymbol(NexusNonNullDef, NexusTypes.NonNull)\n\n/**\n * [API Docs](https://nxs.li/docs/api/nonNull) | [Nullability Guide](https://nxs.li/guides/nullability) |\n * [2018 GraphQL Spec](https://spec.graphql.org/June2018/#sec-Type-System.Non-Null)\n *\n * Modify a type to be Non-Null.\n *\n * In Nexus input and output position types are nullable by default so use this to modify them so long as\n * you've not changed the non-null defaults for one or both positions.\n *\n * If you find yourself using this a large majority of the time then consider changing your nullability defaults.\n *\n * @example\n *   objectType({\n *     name: 'User',\n *     definition(t) {\n *       t.field('id', {\n *         type: nonNull('ID'),\n *       })\n *       t.field('bio', {\n *         args: {\n *           format: nonNull(booleanArg()),\n *           maxWords: intArg(),\n *         },\n *         type: 'String',\n *       })\n *     },\n *   })\n *\n *   // GraphQL SDL\n *   // -----------\n *   //\n *   // type User {\n *   //   id: ID!\n *   //   bio(maxWords: Int, format: Boolean!): String\n *   // }\n *\n * @param type The type to wrap in Non-Null. This may be expressed in one of three ways:\n *\n *   1. As string literals matching the name of a builtin scalar. E.g.: 'ID', 'String', ...\n *   2. As string literals matching the name of another type. E.g.: 'User', 'Location', ... Thanks to [Nexus'\n *        reflection system](https://nxs.li/guides/reflection) this is typesafe and autocompletable. This is\n *        the idiomatic approach in Nexus because it avoids excessive importing and circular references.\n *   3. As references to other enums or object type definitions. E.g.: User, Location\n *\n *   You may also use other type modifier helpers like list() which in turn accept one of the three\n */\nexport function nonNull<TypeName extends NexusNonNullableTypes>(type: TypeName) {\n  if (isNexusNonNullTypeDef(type) || isNonNullType(type)) {\n    /*\n\t  Ran into an issue around the generated return type for `nonNull()`, \n\t  which produces:\n\t  \n\t  ```ts\n\t  NexusNonNullDef<any> | (TypeName & GraphQLNonNull<any>)\n\t  ```\n\t  \n\t  This is problematic when you reach a decent amount of types, where you'll \n\t  hit a `union type that is too complex to represent` error. Removing the \n\t  right hand side of the clause resolves the issue, and the fact that it's a \n\t  `GraphQLNonNull` type is irrelevant, so we can just cast it to \n\t  `NexusNonNullDef<any>` here\n\t*/\n    return type as NexusNonNullDef<any>\n  }\n  if (isNexusNullTypeDef(type)) {\n    return new NexusNonNullDef(type.ofNexusType)\n  }\n  return new NexusNonNullDef(type)\n}\n"],"names":[],"mappings":";;;;;;AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,EAAE,MAAM,SAAS,CAAA;AAC/C,OAAO,EAAE,WAAW,EAAE,MAAM,aAAa,CAAA;AACzC,OAAO,EAAE,qBAAqB,EAAE,kBAAkB,EAAE,aAAa,EAAyB,MAAM,YAAY,CAAA;AAC5G,OAAO,EAAE,UAAU,EAAE,eAAe,EAAE,MAAM,UAAU,CAAA;;;;;AAEhD,MAAO,eAAe;IAK1B,YAAqB,WAAqB,CAAA;QAArB,IAAA,CAAA,WAAW,GAAX,WAAW,CAAU;QAJ1C,aAAa;QACb,qEAAqE;QAC7D,IAAA,CAAA,kBAAkB,GAAY,IAAI,CAAA;QAGxC,IACE,OAAO,WAAW,KAAK,QAAQ,IAC/B,KAAC,uPAAa,EAAC,WAAW,CAAC,IAC3B,KAAC,sPAAW,EAAC,WAAW,CAAC,IACzB,KAAC,+MAAM,EAAC,WAAW,CAAC,EACpB;YACA,MAAM,IAAI,KAAK,CAAC,gDAAgD,GAAG,WAAW,CAAC,CAAA;SAChF;IACH,CAAC;CACF;IAED,uPAAe,EAAC,eAAe,EAAE,kPAAU,CAAC,OAAO,CAAC,CAAA;AAgD9C,SAAU,OAAO,CAAyC,IAAc;IAC5E,QAAI,+PAAqB,EAAC,IAAI,CAAC,QAAI,sNAAa,EAAC,IAAI,CAAC,EAAE;QACtD;;;;;;;;;;;;;UAaD,CACC,OAAO,IAA4B,CAAA;KACpC;IACD,QAAI,4PAAkB,EAAC,IAAI,CAAC,EAAE;QAC5B,OAAO,IAAI,eAAe,CAAC,IAAI,CAAC,WAAW,CAAC,CAAA;KAC7C;IACD,OAAO,IAAI,eAAe,CAAC,IAAI,CAAC,CAAA;AAClC,CAAC"}},
    {"offset": {"line": 1400, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/definitions/nullable.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/definitions/nullable.ts"],"sourcesContent":["import { isType } from 'graphql'\nimport { isNexusMeta } from './nexusMeta'\nimport { isNexusNonNullTypeDef, isNexusNullTypeDef, isNexusStruct, NexusNullableTypes } from './wrapping'\nimport { NexusTypes, withNexusSymbol } from './_types'\n\nexport class NexusNullDef<TypeName extends NexusNullableTypes> {\n  // @ts-ignore\n  // Required field for TS to differentiate NonNull from Null from List\n  private _isNexusNullDef: boolean = true\n\n  constructor(readonly ofNexusType: TypeName) {\n    if (\n      typeof ofNexusType !== 'string' &&\n      !isNexusStruct(ofNexusType) &&\n      !isNexusMeta(ofNexusType) &&\n      !isType(ofNexusType)\n    ) {\n      throw new Error('Cannot wrap unknown types in nullable(). Saw ' + ofNexusType)\n    }\n  }\n}\n\nwithNexusSymbol(NexusNullDef, NexusTypes.Null)\n\n/**\n * [API Docs](https://nxs.li/docs/api/nonNull) | [Nullability Guide](https://nxs.li/guides/nullability) |\n * [2018 GraphQL Spec](https://spec.graphql.org/June2018/#sec-Type-System.Non-Null)\n *\n * Remove the Non-Null wrapper from a type, if present.\n *\n * In Nexus input and output position types are nullable by default so this has ***no use*** until you've\n * changed the non-null defaults for one or both positions.\n *\n * If you find yourself using this a large majority of the time then consider changing your nullability defaults.\n *\n * @example\n *   objectType({\n *     name: 'User',\n *     nonNullDefaults: {\n *       inputs: true,\n *       outputs: true,\n *     },\n *     definition(t) {\n *       t.field('id', {\n *         type: 'ID',\n *       })\n *       t.field('bio', {\n *         args: {\n *           format: booleanArg(),\n *           maxWords: nullable(intArg()),\n *         },\n *         type: nullable('String'),\n *       })\n *     },\n *   })\n *\n *   // GraphQL SDL\n *   // -----------\n *   //\n *   // type User {\n *   //   id: ID!\n *   //   bio(maxWords: Int, format: Boolean!): String\n *   // }\n *\n * @param type The type to wrap in Non-Null. This may be expressed in one of three ways:\n *\n *   1. As string literals matching the name of a builtin scalar. E.g.: 'ID', 'String', ...\n *   2. As string literals matching the name of another type. E.g.: 'User', 'Location', ... Thanks to [Nexus'\n *        reflection system](https://nxs.li/guides/reflection) this is typesafe and autocompletable. This is\n *        the idiomatic approach in Nexus because it avoids excessive importing and circular references.\n *   3. As references to other enums or object type definitions. E.g.: User, Location\n *\n *   You may also use other type modifier helpers like list() which in turn accept one of the three\n */\nexport function nullable<TypeName extends NexusNullableTypes>(type: TypeName) {\n  if (isNexusNonNullTypeDef(type)) {\n    return new NexusNullDef(type.ofNexusType)\n  }\n  if (isNexusNullTypeDef(type)) {\n    return type\n  }\n  return new NexusNullDef(type)\n}\n"],"names":[],"mappings":";;;;;;AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,SAAS,CAAA;AAChC,OAAO,EAAE,WAAW,EAAE,MAAM,aAAa,CAAA;AACzC,OAAO,EAAE,qBAAqB,EAAE,kBAAkB,EAAE,aAAa,EAAsB,MAAM,YAAY,CAAA;AACzG,OAAO,EAAE,UAAU,EAAE,eAAe,EAAE,MAAM,UAAU,CAAA;;;;;AAEhD,MAAO,YAAY;IAKvB,YAAqB,WAAqB,CAAA;QAArB,IAAA,CAAA,WAAW,GAAX,WAAW,CAAU;QAJ1C,aAAa;QACb,qEAAqE;QAC7D,IAAA,CAAA,eAAe,GAAY,IAAI,CAAA;QAGrC,IACE,OAAO,WAAW,KAAK,QAAQ,IAC/B,KAAC,uPAAa,EAAC,WAAW,CAAC,IAC3B,KAAC,sPAAW,EAAC,WAAW,CAAC,IACzB,KAAC,+MAAM,EAAC,WAAW,CAAC,EACpB;YACA,MAAM,IAAI,KAAK,CAAC,+CAA+C,GAAG,WAAW,CAAC,CAAA;SAC/E;IACH,CAAC;CACF;IAED,uPAAe,EAAC,YAAY,EAAE,kPAAU,CAAC,IAAI,CAAC,CAAA;AAoDxC,SAAU,QAAQ,CAAsC,IAAc;IAC1E,QAAI,+PAAqB,EAAC,IAAI,CAAC,EAAE;QAC/B,OAAO,IAAI,YAAY,CAAC,IAAI,CAAC,WAAW,CAAC,CAAA;KAC1C;IACD,QAAI,4PAAkB,EAAC,IAAI,CAAC,EAAE;QAC5B,OAAO,IAAI,CAAA;KACZ;IACD,OAAO,IAAI,YAAY,CAAC,IAAI,CAAC,CAAA;AAC/B,CAAC"}},
    {"offset": {"line": 1439, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/definitions/wrapping.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/definitions/wrapping.ts"],"sourcesContent":["import {\n  GraphQLInputType,\n  GraphQLList,\n  GraphQLNamedType,\n  GraphQLNonNull,\n  GraphQLType,\n  isWrappingType,\n  isListType,\n  isNonNullType,\n} from 'graphql'\nimport type { DynamicInputMethodDef, DynamicOutputMethodDef } from '../dynamicMethod'\nimport type { DynamicOutputPropertyDef } from '../dynamicProperty'\nimport type { NexusPlugin } from '../plugin'\nimport type { AllInputTypes, GetGen } from '../typegenTypeHelpers'\nimport { PrintedGenTyping, PrintedGenTypingImport, Unreachable } from '../utils'\nimport { NexusArgDef, arg } from './args'\nimport type { NexusEnumTypeDef } from './enumType'\nimport type { NexusExtendInputTypeDef } from './extendInputType'\nimport type { NexusExtendTypeDef } from './extendType'\nimport type { NexusInputObjectTypeDef } from './inputObjectType'\nimport type { NexusInterfaceTypeDef } from './interfaceType'\nimport { list, NexusListDef } from './list'\nimport { NexusNonNullDef, nonNull } from './nonNull'\nimport { NexusNullDef, nullable } from './nullable'\nimport type { NexusObjectTypeDef } from './objectType'\nimport type { NexusScalarTypeDef } from './scalarType'\nimport { isNexusMetaType, NexusMetaType, resolveNexusMetaType } from './nexusMeta'\nimport type { NexusUnionTypeDef } from './unionType'\nimport { NexusTypes, NexusWrappedSymbol } from './_types'\n\n/** Input(named): Nexus only */\nexport type AllNexusNamedInputTypeDefs<T extends string = any> =\n  | NexusInputObjectTypeDef<T>\n  | NexusEnumTypeDef<T>\n  | NexusScalarTypeDef<T>\n\n/** Input(named): Nexus + GraphQLInput */\nexport type AllNamedInputTypeDefs<T extends string = any> =\n  | AllNexusNamedInputTypeDefs<T>\n  | Exclude<GraphQLInputType, GraphQLList<any> | GraphQLNonNull<any>>\n\n/** Input(all): Nexus + GraphQL */\nexport type AllNexusInputTypeDefs<T extends string = any> =\n  | AllNamedInputTypeDefs<T>\n  | NexusListDef<any>\n  | NexusNonNullDef<any>\n  | NexusNullDef<any>\n  | GraphQLList<any>\n  | GraphQLNonNull<any>\n\n/** Output(named): Nexus only */\nexport type AllNexusNamedOutputTypeDefs =\n  | NexusObjectTypeDef<any>\n  | NexusInterfaceTypeDef<any>\n  | NexusUnionTypeDef<any>\n  | NexusEnumTypeDef<any>\n  | NexusScalarTypeDef<any>\n\n/** Output(all): Nexus only */\nexport type AllNexusOutputTypeDefs =\n  | AllNexusNamedOutputTypeDefs\n  | NexusListDef<any>\n  | NexusNonNullDef<any>\n  | NexusNullDef<any>\n\n/** Input + output(named): Nexus only */\nexport type AllNexusNamedTypeDefs = AllNexusNamedInputTypeDefs | AllNexusNamedOutputTypeDefs\n\n/** Input + output(all): Nexus only */\nexport type AllNexusTypeDefs = AllNexusOutputTypeDefs | AllNexusInputTypeDefs\n\n/** Input + output(all): Nexus only + Name */\nexport type AllNamedTypeDefs = AllNexusNamedTypeDefs | GraphQLNamedType\n\n/** All inputs to list(...) */\nexport type NexusListableTypes =\n  | GetGen<'allNamedTypes', string>\n  | AllNamedTypeDefs\n  | NexusArgDef<any>\n  | NexusListDef<NexusListableTypes>\n  | NexusNonNullDef<NexusNonNullableTypes>\n  | NexusNullDef<NexusNullableTypes>\n  | GraphQLType\n  | NexusMetaType\n\n/** All inputs to nonNull(...) */\nexport type NexusNonNullableTypes =\n  | GetGen<'allNamedTypes', string>\n  | AllNamedTypeDefs\n  | NexusListDef<NexusListableTypes>\n  | NexusArgDef<any>\n  | NexusMetaType\n\n/** All inputs to nullable(...) */\nexport type NexusNullableTypes =\n  | GetGen<'allNamedTypes', string>\n  | AllNamedTypeDefs\n  | NexusListDef<NexusListableTypes>\n  | NexusArgDef<any>\n  | NexusMetaType\n\nexport type AllNexusNamedArgsDefs<T extends AllInputTypes = AllInputTypes> =\n  | T\n  | NexusArgDef<T>\n  | AllNamedInputTypeDefs<T>\n  | GraphQLInputType\n\nexport type AllNexusArgsDefs =\n  | AllNexusNamedArgsDefs\n  | NexusListDef<any>\n  | NexusNonNullDef<any>\n  | NexusNullDef<any>\n  | GraphQLInputType\n\nconst NamedTypeDefs = new Set([\n  NexusTypes.Enum,\n  NexusTypes.Object,\n  NexusTypes.Scalar,\n  NexusTypes.Union,\n  NexusTypes.Interface,\n  NexusTypes.InputObject,\n])\n\nexport const isNexusTypeDef = (obj: any): obj is { [NexusWrappedSymbol]: NexusTypes } => {\n  console.warn(`isNexusTypeDef is deprecated, use isNexusStruct`)\n  return isNexusStruct(obj)\n}\n\nexport function isNexusStruct(obj: any): obj is { [NexusWrappedSymbol]: NexusTypes } {\n  return obj && Boolean(obj[NexusWrappedSymbol])\n}\nexport function isNexusNamedTypeDef(obj: any): obj is AllNexusNamedTypeDefs {\n  return isNexusStruct(obj) && NamedTypeDefs.has(obj[NexusWrappedSymbol]) && 'name' in obj\n}\nexport function isNexusListTypeDef(obj: any): obj is NexusListDef<any> {\n  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.List\n}\n\nexport function isNexusNonNullTypeDef(obj: any): obj is NexusNonNullDef<any> {\n  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.NonNull\n}\n\nexport function isNexusNullTypeDef(obj: any): obj is NexusNullDef<any> {\n  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.Null\n}\n\nexport function isNexusWrappingType(\n  obj: any\n): obj is NexusListDef<any> | NexusNullDef<any> | NexusNonNullDef<any> {\n  return isNexusListTypeDef(obj) || isNexusNullTypeDef(obj) || isNexusNonNullTypeDef(obj)\n}\n\nexport function isNexusExtendInputTypeDef(obj: any): obj is NexusExtendInputTypeDef<string> {\n  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.ExtendInputObject\n}\nexport function isNexusExtendTypeDef(obj: any): obj is NexusExtendTypeDef<string> {\n  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.ExtendObject\n}\n\nexport function isNexusEnumTypeDef(obj: any): obj is NexusEnumTypeDef<string> {\n  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.Enum\n}\nexport function isNexusInputObjectTypeDef(obj: any): obj is NexusInputObjectTypeDef<string> {\n  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.InputObject\n}\nexport function isNexusObjectTypeDef(obj: any): obj is NexusObjectTypeDef<string> {\n  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.Object\n}\nexport function isNexusScalarTypeDef(obj: any): obj is NexusScalarTypeDef<string> {\n  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.Scalar\n}\nexport function isNexusUnionTypeDef(obj: any): obj is NexusUnionTypeDef<string> {\n  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.Union\n}\nexport function isNexusInterfaceTypeDef(obj: any): obj is NexusInterfaceTypeDef<string> {\n  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.Interface\n}\nexport function isNexusArgDef(obj: any): obj is NexusArgDef<AllInputTypes> {\n  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.Arg\n}\n\nexport function isNexusNamedOuputTypeDef(obj: any): obj is AllNexusNamedOutputTypeDefs {\n  return isNexusNamedTypeDef(obj) && !isNexusInputObjectTypeDef(obj)\n}\nexport function isNexusNamedInputTypeDef(obj: any): obj is AllNexusNamedInputTypeDefs {\n  return isNexusNamedTypeDef(obj) && !isNexusObjectTypeDef(obj) && !isNexusInterfaceTypeDef(obj)\n}\n\nexport function isNexusDynamicOutputProperty<T extends string>(obj: any): obj is DynamicOutputPropertyDef<T> {\n  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.DynamicOutputProperty\n}\nexport function isNexusDynamicOutputMethod<T extends string>(obj: any): obj is DynamicOutputMethodDef<T> {\n  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.DynamicOutputMethod\n}\nexport function isNexusDynamicInputMethod<T extends string>(obj: any): obj is DynamicInputMethodDef<T> {\n  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.DynamicInput\n}\nexport function isNexusPrintedGenTyping(obj: any): obj is PrintedGenTyping {\n  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.PrintedGenTyping\n}\nexport function isNexusPrintedGenTypingImport(obj: any): obj is PrintedGenTypingImport {\n  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.PrintedGenTypingImport\n}\n\nexport function isNexusPlugin(obj: any): obj is NexusPlugin {\n  return isNexusStruct(obj) && obj[NexusWrappedSymbol] === NexusTypes.Plugin\n}\n\nexport type NexusWrapKind = 'NonNull' | 'Null' | 'List'\nexport type NexusFinalWrapKind = 'NonNull' | 'List'\n\nexport function unwrapGraphQLDef(typeDef: GraphQLType): {\n  namedType: GraphQLNamedType\n  wrapping: NexusFinalWrapKind[]\n} {\n  const wrapping: NexusFinalWrapKind[] = []\n  let namedType = typeDef\n  while (isWrappingType(namedType)) {\n    if (isListType(namedType)) {\n      wrapping.unshift('List')\n    } else if (isNonNullType(namedType)) {\n      wrapping.unshift('NonNull')\n    } else {\n      throw new Unreachable(namedType)\n    }\n    namedType = namedType.ofType\n  }\n  return { namedType, wrapping }\n}\n\n/** Unwraps any wrapped Nexus or GraphQL types, turning into a list of wrapping */\nexport function unwrapNexusDef(\n  typeDef: AllNexusTypeDefs | AllNexusArgsDefs | GraphQLType | NexusMetaType | string\n): {\n  namedType: AllNexusNamedTypeDefs | AllNexusArgsDefs | GraphQLNamedType | string\n  wrapping: NexusWrapKind[]\n} {\n  const wrapping: NexusWrapKind[] = []\n  let namedType = typeDef\n  while (isNexusWrappingType(namedType) || isWrappingType(namedType) || isNexusMetaType(namedType)) {\n    if (isNexusMetaType(namedType)) {\n      namedType = resolveNexusMetaType(namedType)\n    } else if (isWrappingType(namedType)) {\n      if (isListType(namedType)) {\n        wrapping.unshift('List')\n      } else if (isNonNullType(namedType)) {\n        wrapping.unshift('NonNull')\n      } else {\n        throw new Unreachable(namedType)\n      }\n      namedType = namedType.ofType\n    } else {\n      if (isNexusNonNullTypeDef(namedType)) {\n        wrapping.unshift('NonNull')\n      }\n      if (isNexusNullTypeDef(namedType)) {\n        wrapping.unshift('Null')\n      }\n      if (isNexusListTypeDef(namedType)) {\n        wrapping.unshift('List')\n      }\n      namedType = namedType.ofNexusType\n    }\n  }\n  return { namedType, wrapping }\n}\n\n/** Takes the named type, and applies any of the NexusFinalWrapKind to create a properly wrapped GraphQL type. */\nexport function rewrapAsGraphQLType(baseType: GraphQLNamedType, wrapping: NexusFinalWrapKind[]): GraphQLType {\n  let finalType: GraphQLType = baseType\n  wrapping.forEach((wrap) => {\n    if (wrap === 'List') {\n      finalType = new GraphQLList(finalType)\n    } else if (wrap === 'NonNull') {\n      if (!isNonNullType(finalType)) {\n        finalType = new GraphQLNonNull(finalType)\n      }\n    } else {\n      throw new Unreachable(wrap)\n    }\n  })\n  return finalType\n}\n\n/**\n * Apply the wrapping consistently to the arg `type`\n *\n * NonNull(list(stringArg())) -> arg({ type: nonNull(list('String')) })\n */\nexport function normalizeArgWrapping(argVal: AllNexusArgsDefs): NexusArgDef<AllInputTypes> {\n  if (isNexusArgDef(argVal)) {\n    return argVal\n  }\n  if (isNexusWrappingType(argVal)) {\n    let { namedType, wrapping } = unwrapNexusDef(argVal)\n    if (isNexusArgDef(namedType)) {\n      const config = namedType.value\n      return arg({ ...config, type: applyNexusWrapping(config.type, wrapping) })\n    }\n    return arg({ type: applyNexusWrapping(namedType, wrapping) })\n  }\n  return arg({ type: argVal })\n}\n\n/**\n * Applies the ['List', 'NonNull', 'Nullable']\n *\n * @param toWrap\n * @param wrapping\n */\nexport function applyNexusWrapping(toWrap: any, wrapping: NexusWrapKind[]) {\n  let finalType = toWrap\n  wrapping.forEach((wrap) => {\n    if (wrap === 'List') {\n      finalType = list(finalType)\n    } else if (wrap === 'NonNull') {\n      finalType = nonNull(finalType)\n    } else if (wrap === 'Null') {\n      finalType = nullable(finalType)\n    } else {\n      throw new Unreachable(wrap)\n    }\n  })\n  return finalType\n}\n\n/**\n * Takes the \"nonNullDefault\" value, the chained wrapping, and the field wrapping, to determine the proper\n * list of wrapping to apply to the field\n */\nexport function finalizeWrapping(\n  nonNullDefault: boolean,\n  typeWrapping: NexusWrapKind[] | ReadonlyArray<NexusWrapKind>,\n  chainWrapping?: NexusWrapKind[]\n): NexusFinalWrapKind[] {\n  let finalChain: NexusFinalWrapKind[] = []\n  const allWrapping = typeWrapping.concat(chainWrapping ?? [])\n  // Ensure the first item is wrapped, if we're not guarding\n  if (nonNullDefault && (!allWrapping[0] || allWrapping[0] === 'List')) {\n    allWrapping.unshift('NonNull')\n  }\n  for (let i = 0; i < allWrapping.length; i++) {\n    const current = allWrapping[i]\n    const next = allWrapping[i + 1]\n    if (current === 'Null') {\n      continue\n    } else if (current === 'NonNull') {\n      finalChain.push('NonNull')\n    } else if (current === 'List') {\n      finalChain.push('List')\n      if (nonNullDefault && (next === 'List' || !next)) {\n        finalChain.push('NonNull')\n      }\n    }\n  }\n  return finalChain\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1726, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/extensions.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/extensions.ts"],"sourcesContent":["import { defaultFieldResolver, GraphQLNamedType } from 'graphql'\nimport type { DynamicFieldDefs, SchemaConfig } from './builder'\nimport type { SourceTypings } from './definitions/_types'\nimport type { NexusOutputFieldConfig } from './definitions/definitionBlocks'\nimport type { NexusInputObjectTypeConfig } from './definitions/inputObjectType'\nimport type { NexusInterfaceTypeConfig } from './definitions/interfaceType'\nimport type { NexusObjectTypeConfig } from './definitions/objectType'\n\n/** @internal */\nexport function hasNexusExtension(val: any): val is any {\n  return Boolean(val)\n}\n\nexport type NexusGraphQLNamedType = GraphQLNamedType & {\n  extensions?: {\n    nexus?: {\n      config: any\n    }\n  }\n}\n\nexport type NexusTypeExtensions = NexusObjectTypeExtension | NexusInterfaceTypeExtension\n\n/** Container object living on `fieldDefinition.extensions.nexus` */\nexport class NexusFieldExtension<TypeName extends string = any, FieldName extends string = any> {\n  readonly config: Omit<NexusOutputFieldConfig<TypeName, FieldName>, 'resolve'>\n  /** Whether the user has provided a custom \"resolve\" function, or whether we're using GraphQL's defaultResolver */\n  readonly hasDefinedResolver: boolean\n  constructor(config: NexusOutputFieldConfig<TypeName, FieldName>) {\n    const { resolve, ...rest } = config\n    this.config = rest\n    this.hasDefinedResolver = Boolean(resolve && resolve !== defaultFieldResolver)\n  }\n  /** Called when there are modifications on the interface fields */\n  modify(modifications: Partial<NexusOutputFieldConfig<any, any>>) {\n    return new NexusFieldExtension({ ...this.config, ...modifications })\n  }\n}\n\n/** Container object living on `inputObjectType.extensions.nexus` */\nexport class NexusInputObjectTypeExtension<TypeName extends string = any> {\n  readonly config: Omit<NexusInputObjectTypeConfig<TypeName>, 'definition'>\n  constructor(config: NexusInputObjectTypeConfig<TypeName>) {\n    const { definition, ...rest } = config\n    this.config = rest\n  }\n}\n\n/** Container object living on `objectType.extensions.nexus` */\nexport class NexusObjectTypeExtension<TypeName extends string = any> {\n  readonly config: Omit<NexusObjectTypeConfig<TypeName>, 'definition' | 'isTypeOf'>\n  constructor(config: NexusObjectTypeConfig<TypeName>) {\n    const { definition, ...rest } = config\n    this.config = rest as any\n  }\n}\n\n/** Container object living on `interfaceType.extensions.nexus` */\nexport class NexusInterfaceTypeExtension<TypeName extends string = any> {\n  readonly config: Omit<NexusInterfaceTypeConfig<TypeName>, 'definition' | 'resolveType'>\n  constructor(config: NexusInterfaceTypeConfig<TypeName>) {\n    const { definition, ...rest } = config\n    this.config = rest as any\n  }\n}\n\nexport interface NexusSchemaExtensionConfig extends Omit<SchemaConfig, 'types'> {\n  dynamicFields: DynamicFieldDefs\n  sourceTypings: SourceTypings\n}\n\n/**\n * Container object living on `schema.extensions.nexus`. Keeps track of metadata from the builder so we can\n * use it when we\n */\nexport class NexusSchemaExtension {\n  constructor(readonly config: NexusSchemaExtensionConfig) {}\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA,OAAO,EAAE,oBAAoB,EAAoB,MAAM,SAAS,CAAA;;;AAS1D,SAAU,iBAAiB,CAAC,GAAQ;IACxC,OAAO,OAAO,CAAC,GAAG,CAAC,CAAA;AACrB,CAAC;AAaK,MAAO,mBAAmB;IAI9B,YAAY,MAAmD,CAAA;QAC7D,MAAM,EAAE,OAAO,EAAA,GAAc,MAAM,EAAf,IAAI,GAAA,IAAA,mMAAA,EAAK,MAAM,EAA7B;YAAA;SAAoB,CAAS,CAAA;QACnC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAA;QAClB,IAAI,CAAC,kBAAkB,GAAG,OAAO,CAAC,OAAO,IAAI,OAAO,KAAK,+NAAoB,CAAC,CAAA;IAChF,CAAC;IACD,gEAAA,EAAkE,CAClE,MAAM,CAAC,aAAwD,EAAA;QAC7D,OAAO,IAAI,mBAAmB,CAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAM,IAAI,CAAC,MAAM,GAAK,aAAa,EAAG,CAAA;IACtE,CAAC;CACF;AAGK,MAAO,6BAA6B;IAExC,YAAY,MAA4C,CAAA;QACtD,MAAM,EAAE,UAAU,EAAA,GAAc,MAAM,EAAf,IAAI,GAAA,IAAA,mMAAA,EAAK,MAAM,EAAhC;YAAA;SAAuB,CAAS,CAAA;QACtC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAA;IACpB,CAAC;CACF;AAGK,MAAO,wBAAwB;IAEnC,YAAY,MAAuC,CAAA;QACjD,MAAM,EAAE,UAAU,EAAA,GAAc,MAAM,EAAf,IAAI,GAAA,IAAA,mMAAA,EAAK,MAAM,EAAhC;YAAA;SAAuB,CAAS,CAAA;QACtC,IAAI,CAAC,MAAM,GAAG,IAAW,CAAA;IAC3B,CAAC;CACF;AAGK,MAAO,2BAA2B;IAEtC,YAAY,MAA0C,CAAA;QACpD,MAAM,EAAE,UAAU,EAAA,GAAc,MAAM,EAAf,IAAI,GAAA,IAAA,mMAAA,EAAK,MAAM,EAAhC;YAAA;SAAuB,CAAS,CAAA;QACtC,IAAI,CAAC,MAAM,GAAG,IAAW,CAAA;IAC3B,CAAC;CACF;AAWK,MAAO,oBAAoB;IAC/B,YAAqB,MAAkC,CAAA;QAAlC,IAAA,CAAA,MAAM,GAAN,MAAM,CAA4B;IAAG,CAAC;CAC5D"}},
    {"offset": {"line": 1792, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/plugin.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/plugin.ts"],"sourcesContent":["import type { GraphQLFieldResolver, GraphQLInterfaceType, GraphQLResolveInfo, GraphQLSchema } from 'graphql'\nimport type { PluginBuilderLens, SchemaConfig } from './builder'\nimport {\n  Maybe,\n  NexusGraphQLFieldConfig,\n  NexusGraphQLInterfaceTypeConfig,\n  NexusGraphQLObjectTypeConfig,\n  NexusTypes,\n  Omit,\n  withNexusSymbol,\n} from './definitions/_types'\nimport type {\n  InputDefinitionBlock,\n  NexusOutputFieldDef,\n  NexusInputFieldDef,\n} from './definitions/definitionBlocks'\nimport type { NexusInputObjectTypeConfig } from './definitions/inputObjectType'\nimport type { NexusObjectTypeConfig, ObjectDefinitionBlock } from './definitions/objectType'\nimport type { NexusSchemaExtension } from './extensions'\nimport { isPromiseLike, PrintedGenTyping, PrintedGenTypingImport, venn } from './utils'\nimport type { NexusFinalArgConfig } from './definitions/args'\nimport type { UnwrapPromise } from './typeHelpersInternal'\n\nexport { PluginBuilderLens }\n\nexport type CreateFieldResolverInfo<FieldExt = any, TypeExt = any> = {\n  /** The internal Nexus \"builder\" object */\n  builder: PluginBuilderLens\n  /** Info about the GraphQL Field we're decorating. Always guaranteed to exist, even for non-Nexus GraphQL types */\n  fieldConfig: Omit<NexusGraphQLFieldConfig, 'resolve' | 'extensions'> & {\n    extensions?: Maybe<{ nexus?: { config: FieldExt } }>\n  }\n  /** The config provided to the Nexus type containing the field. Will not exist if this is a non-Nexus GraphQL type. */\n  parentTypeConfig: (\n    | Omit<NexusGraphQLObjectTypeConfig, 'fields' | 'extensions'>\n    | (Omit<NexusGraphQLInterfaceTypeConfig, 'fields' | 'extensions'> & {\n        interfaces: readonly GraphQLInterfaceType[]\n      })\n  ) & {\n    extensions?: Maybe<{ nexus?: { config: TypeExt } }>\n  }\n  /** The root-level SchemaConfig passed */\n  schemaConfig: Omit<SchemaConfig, 'types'>\n  /** Nexus specific metadata provided to the schema. */\n  schemaExtension: NexusSchemaExtension\n}\n\nexport type StringLike = PrintedGenTypingImport | PrintedGenTyping | string\n\nexport interface PluginConfig {\n  /** A name for the plugin, useful for errors, etc. */\n  name: string\n  /** A description for the plugin */\n  description?: Maybe<string>\n  /** Any type definitions we want to add to output field definitions */\n  fieldDefTypes?: StringLike | StringLike[]\n  /** Any type definitions we want to add to input field definitions */\n  inputFieldDefTypes?: StringLike | StringLike[]\n  /** Any type definitions we want to add to the type definition option */\n  objectTypeDefTypes?: StringLike | StringLike[]\n  /** Any type definitions we want to add to the input type definition option */\n  inputObjectTypeDefTypes?: StringLike | StringLike[]\n  /** Any type definitions we want to add to the arg definition option */\n  argTypeDefTypes?: StringLike | StringLike[]\n  /**\n   * Executed once, just before the types are walked. Useful for defining custom extensions to the\n   * \"definition\" builders that are needed while traversing the type definitions, as are defined by\n   * `dynamicOutput{Method,Property}` / `dynamicInput{Method,Property}`\n   */\n  /**\n   * The onInstall event occurs before type walking which means inline types are not visible at this point\n   * yet. `builderLens.hasType` will only return true for types the user has defined top level in their app,\n   * and any types added by upstream plugins.\n   */\n  onInstall?: (builder: PluginBuilderLens) => void\n  /**\n   * Executed once, just after types have been walked but also before the schema definition types are\n   * materialized into GraphQL types. Use this opportunity to add / modify / remove any types before we go\n   * through the resolution step.\n   */\n  onBeforeBuild?: (builder: PluginBuilderLens) => void\n  /** After the schema is built, provided the Schema to do any final config validation. */\n  onAfterBuild?: (schema: GraphQLSchema) => void\n  /** Called when the `.addField` is called internally in the builder, before constructing the field */\n  onAddOutputField?: (field: NexusOutputFieldDef) => NexusOutputFieldDef | void\n  /** Called when the `.addField` is called internally in the builder, before constructing the field */\n  onAddInputField?: (field: NexusInputFieldDef) => NexusInputFieldDef | void\n  /** Called just before a Nexus arg is constructed into an GraphQLArgumentConfig */\n  onAddArg?: (arg: NexusFinalArgConfig) => NexusFinalArgConfig | void\n  /** Called immediately after the object is defined, allows for using metadata to define the shape of the object. */\n  onObjectDefinition?: (\n    block: ObjectDefinitionBlock<string>,\n    objectConfig: NexusObjectTypeConfig<string>\n  ) => void\n  /**\n   * Called immediately after the input object is defined, allows for using metadata to define the shape of\n   * the input object\n   */\n  onInputObjectDefinition?: (\n    block: InputDefinitionBlock<any>,\n    objectConfig: NexusInputObjectTypeConfig<any>\n  ) => void\n  /**\n   * If a type is not defined in the schema, our plugins can register an `onMissingType` handler, which will\n   * intercept the missing type name and give us an opportunity to respond with a valid type.\n   */\n  onMissingType?: (missingTypeName: string, builder: PluginBuilderLens) => any\n  /**\n   * Executed any time a field resolver is created. Returning a function here will add its in the stack of\n   * middlewares with the (root, args, ctx, info, next) signature, where the `next` is the next middleware or\n   * resolver to be executed.\n   */\n  onCreateFieldResolver?: (createResolverInfo: CreateFieldResolverInfo) => MiddlewareFn | undefined\n  /**\n   * Executed any time a \"subscribe\" handler is created. Returning a function here will add its in the stack\n   * of middlewares with the (root, args, ctx, info, next) signature, where the `next` is the next middleware\n   * or resolver to be executed.\n   */\n  onCreateFieldSubscribe?: (createSubscribeInfo: CreateFieldResolverInfo) => MiddlewareFn | undefined\n  /**\n   * Executed when a field is going to be printed to the nexus \"generated types\". Gives an opportunity to\n   * override the standard behavior for printing our inferred type info\n   */\n  // onPrint?: (visitor: Visitor<ASTKindToNode>) => void;\n}\n\nexport function completeValue<T, R>(\n  valOrPromise: PromiseLike<T> | T,\n  onSuccess: (completedVal: T) => R\n): R | UnwrapPromise<R> | PromiseLike<UnwrapPromise<R>> | PromiseLike<UnwrapPromise<R>>\n\nexport function completeValue<T, R, E>(\n  valOrPromise: PromiseLike<T> | T,\n  onSuccess: (completedVal: T) => R,\n  onError: (err: any) => R\n): R | UnwrapPromise<R> | PromiseLike<UnwrapPromise<R>> | PromiseLike<UnwrapPromise<R>>\n\n/**\n * Helper for allowing plugins to fulfill the return of the `next` resolver, without paying the cost of the\n * Promise if not required.\n */\nexport function completeValue<T, R>(\n  valOrPromise: PromiseLike<T> | T,\n  onSuccess: (completedVal: T) => R,\n  onError?: (errVal: any) => R\n) {\n  if (isPromiseLike(valOrPromise)) {\n    return valOrPromise.then(onSuccess, onError)\n  }\n  // No need to handle onError, this should just be a try/catch inside the `onSuccess` block\n  const result = onSuccess(valOrPromise)\n\n  // If the result of the synchronous call is a promise, we want to unwrap it, for\n  // the return value types consistency\n  if (isPromiseLike(result)) {\n    return result.then((o) => o)\n  }\n  return result\n}\n\nexport type MiddlewareFn = (\n  source: any,\n  args: any,\n  context: any,\n  info: GraphQLResolveInfo,\n  next: GraphQLFieldResolver<any, any>\n) => any\n\n/**\n * Takes a list of middlewares and executes them sequentially, passing the \"next\" member of the chain to\n * execute as the 5th arg.\n *\n * @param middleware\n * @param resolver\n */\nexport function composeMiddlewareFns<T>(\n  middlewareFns: MiddlewareFn[],\n  resolver: GraphQLFieldResolver<any, any>\n) {\n  let lastResolver = resolver\n  for (const middleware of middlewareFns.reverse()) {\n    const currentNext = middleware\n    const previousNext = lastResolver\n    lastResolver = (root, args, ctx, info) => {\n      return currentNext(root, args, ctx, info, previousNext)\n    }\n  }\n  return lastResolver\n}\n\n/** A definition for a plugin. Should be passed to the `plugins: []` option on makeSchema */\nexport class NexusPlugin {\n  constructor(readonly config: PluginConfig) {}\n}\nwithNexusSymbol(NexusPlugin, NexusTypes.Plugin)\n\n/**\n * A plugin defines configuration which can document additional metadata options for a type definition. This\n * metadata can be used to decorate the \"resolve\" function to provide custom functionality, such as logging,\n * error handling, additional type validation.\n *\n * You can specify options which can be defined on the schema, the type or the plugin. The config from each of\n * these will be passed in during schema construction time, and used to augment the field as necessary.\n *\n * You can either return a function, with the new definition of a resolver implementation, or you can return\n * an \"enter\" / \"leave\" pairing which will wrap the pre-execution of the resolver and the \"result\" of the\n * resolver, respectively.\n */\nexport function plugin(config: PluginConfig) {\n  validatePluginConfig(config)\n  return new NexusPlugin(config)\n}\nplugin.completeValue = completeValue\n\n// For backward compat\nexport const createPlugin = plugin\n\n/** Validate that the configuration given by a plugin is valid. */\nfunction validatePluginConfig(pluginConfig: PluginConfig): void {\n  const validRequiredProps = ['name']\n  const optionalPropFns: Array<keyof PluginConfig> = [\n    'onInstall',\n    'onCreateFieldResolver',\n    'onCreateFieldSubscribe',\n    'onBeforeBuild',\n    'onMissingType',\n    'onAfterBuild',\n    'onObjectDefinition',\n    'onAddOutputField',\n    'onAddInputField',\n    'onAddArg',\n    'onInputObjectDefinition',\n  ]\n  const validOptionalProps = [\n    'description',\n    'fieldDefTypes',\n    'inputFieldDefTypes',\n    'objectTypeDefTypes',\n    'inputObjectTypeDefTypes',\n    'argTypeDefTypes',\n    ...optionalPropFns,\n  ]\n\n  const validProps = [...validRequiredProps, ...validOptionalProps]\n  const givenProps = Object.keys(pluginConfig)\n\n  const printProps = (props: Iterable<string>): string => {\n    return [...props].join(', ')\n  }\n\n  const [missingRequiredProps, ,] = venn(validRequiredProps, givenProps)\n  if (missingRequiredProps.size > 0) {\n    throw new Error(\n      `Plugin \"${pluginConfig.name}\" is missing required properties: ${printProps(missingRequiredProps)}`\n    )\n  }\n\n  const nameType = typeof pluginConfig.name\n  if (nameType !== 'string') {\n    throw new Error(\n      `Plugin \"${pluginConfig.name}\" is giving an invalid value for property name: expected \"string\" type, got ${nameType} type`\n    )\n  }\n\n  if (pluginConfig.name === '') {\n    throw new Error(\n      `Plugin \"${pluginConfig.name}\" is giving an invalid value for property name: empty string`\n    )\n  }\n\n  const [, , invalidGivenProps] = venn(validProps, givenProps)\n  if (invalidGivenProps.size > 0) {\n    console.error(\n      new Error(\n        `Plugin \"${pluginConfig.name}\" is giving unexpected properties: ${printProps(invalidGivenProps)}`\n      )\n    )\n  }\n\n  optionalPropFns.forEach((fnName) => {\n    const fnType = typeof pluginConfig[fnName]\n    if (fnType !== 'function' && fnType !== 'undefined') {\n      console.error(\n        new Error(\n          `Plugin \"${pluginConfig.name}\" is giving an invalid value for ${fnName} hook: expected \"function\" type, got ${fnType} type`\n        )\n      )\n    }\n  })\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1906, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/dynamicMethod.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/dynamicMethod.ts"],"sourcesContent":["import type { PluginBuilderLens } from './builder'\nimport type { InputDefinitionBlock, OutputDefinitionBlock } from './definitions/definitionBlocks'\nimport { NexusTypes, withNexusSymbol } from './definitions/_types'\nimport type { NexusWrapKind } from './definitions/wrapping'\n\nexport type OutputFactoryConfig<T> = {\n  /** The name of the type this field is being declared on */\n  typeName: string\n  stage: 'walk' | 'build'\n  args: any[]\n  builder: PluginBuilderLens\n  typeDef: OutputDefinitionBlock<any>\n  /** The list of chained wrapping calls leading up to this dynamic method */\n  wrapping?: NexusWrapKind[]\n}\n\nexport type InputFactoryConfig<T> = {\n  args: any[]\n  builder: PluginBuilderLens\n  typeDef: InputDefinitionBlock<any>\n  /** The name of the type this field is being declared on */\n  typeName: string\n  /** The list of chained wrapping calls leading up to this dynamic method */\n  wrapping?: NexusWrapKind[]\n}\n\nexport interface BaseExtensionConfig<T extends string> {\n  /** The name of the \"extension\", the field made available on the builders */\n  name: T\n  /** The full type definition for the options, including generic signature for the type */\n  typeDefinition?: string\n  /** Description inserted above the typeDefinition for the field, will be formatted as JSDOC by Nexus */\n  typeDescription?: string\n}\n\nexport interface DynamicOutputMethodConfig<T extends string> extends BaseExtensionConfig<T> {\n  /** Invoked when the field is called */\n  factory(config: OutputFactoryConfig<T>): any\n}\n\nexport interface DynamicInputMethodConfig<T extends string> extends BaseExtensionConfig<T> {\n  /** Invoked when the field is called */\n  factory(config: InputFactoryConfig<T>): any\n}\n\nexport class DynamicInputMethodDef<Name extends string> {\n  constructor(readonly name: Name, protected config: DynamicInputMethodConfig<Name>) {}\n  get value() {\n    return this.config\n  }\n}\nwithNexusSymbol(DynamicInputMethodDef, NexusTypes.DynamicInput)\n\nexport class DynamicOutputMethodDef<Name extends string> {\n  constructor(readonly name: Name, protected config: DynamicOutputMethodConfig<Name>) {}\n  get value() {\n    return this.config\n  }\n}\nwithNexusSymbol(DynamicOutputMethodDef, NexusTypes.DynamicOutputMethod)\n\n/**\n * Defines a new property on the object definition block for an output type, taking arbitrary input to define\n * additional types. See the connectionPlugin:\n *\n * T.connectionField('posts', { nullable: true, totalCount(root, args, ctx, info) { return\n * ctx.user.getTotalPostCount(root.id, args) }, nodes(root, args, ctx, info) { return\n * ctx.user.getPosts(root.id, args) } })\n */\nexport function dynamicOutputMethod<T extends string>(config: DynamicOutputMethodConfig<T>) {\n  return new DynamicOutputMethodDef(config.name, config)\n}\n\n/** Same as the outputFieldExtension, but for fields that should be added on as input types. */\nexport function dynamicInputMethod<T extends string>(config: DynamicInputMethodConfig<T>) {\n  return new DynamicInputMethodDef(config.name, config)\n}\n"],"names":[],"mappings":";;;;;;;;;;AAEA,OAAO,EAAE,UAAU,EAAE,eAAe,EAAE,MAAM,sBAAsB,CAAA;;AA2C5D,MAAO,qBAAqB;IAChC,YAAqB,IAAU,EAAY,MAAsC,CAAA;QAA5D,IAAA,CAAA,IAAI,GAAJ,IAAI,CAAM;QAAY,IAAA,CAAA,MAAM,GAAN,MAAM,CAAgC;IAAG,CAAC;IACrF,IAAI,KAAK,GAAA;QACP,OAAO,IAAI,CAAC,MAAM,CAAA;IACpB,CAAC;CACF;IACD,uPAAe,EAAC,qBAAqB,EAAE,kPAAU,CAAC,YAAY,CAAC,CAAA;AAEzD,MAAO,sBAAsB;IACjC,YAAqB,IAAU,EAAY,MAAuC,CAAA;QAA7D,IAAA,CAAA,IAAI,GAAJ,IAAI,CAAM;QAAY,IAAA,CAAA,MAAM,GAAN,MAAM,CAAiC;IAAG,CAAC;IACtF,IAAI,KAAK,GAAA;QACP,OAAO,IAAI,CAAC,MAAM,CAAA;IACpB,CAAC;CACF;IACD,uPAAe,EAAC,sBAAsB,EAAE,kPAAU,CAAC,mBAAmB,CAAC,CAAA;AAUjE,SAAU,mBAAmB,CAAmB,MAAoC;IACxF,OAAO,IAAI,sBAAsB,CAAC,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,CAAA;AACxD,CAAC;AAGK,SAAU,kBAAkB,CAAmB,MAAmC;IACtF,OAAO,IAAI,qBAAqB,CAAC,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,CAAA;AACvD,CAAC"}},
    {"offset": {"line": 1948, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/plugins/connectionPlugin.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/plugins/connectionPlugin.ts"],"sourcesContent":["import { defaultFieldResolver, GraphQLFieldResolver, GraphQLResolveInfo } from 'graphql'\nimport { ArgsRecord, intArg, stringArg } from '../definitions/args'\nimport type {\n  CommonFieldConfig,\n  FieldOutConfig,\n  FieldOutConfigWithName,\n} from '../definitions/definitionBlocks'\nimport { NexusNonNullDef, nonNull } from '../definitions/nonNull'\nimport { NexusNullDef, nullable } from '../definitions/nullable'\nimport { ObjectDefinitionBlock, objectType } from '../definitions/objectType'\nimport {\n  AllNexusNamedOutputTypeDefs,\n  AllNexusOutputTypeDefs,\n  applyNexusWrapping,\n} from '../definitions/wrapping'\nimport type { NonNullConfig } from '../definitions/_types'\nimport { dynamicOutputMethod } from '../dynamicMethod'\nimport { completeValue, plugin } from '../plugin'\nimport type {\n  ArgsValue,\n  FieldTypeName,\n  GetGen,\n  MaybePromise,\n  MaybePromiseDeep,\n  ResultValue,\n  SourceValue,\n} from '../typegenTypeHelpers'\nimport type { MaybePromiseLike } from '../typeHelpersInternal'\nimport { eachObj, getOwnPackage, isPromiseLike, mapObj, pathToArray, printedGenTypingImport } from '../utils'\n\nexport interface ConnectionPluginConfig {\n  /**\n   * The method name in the objectType definition block\n   *\n   * @default 'connectionField'\n   */\n  nexusFieldName?: string\n  /**\n   * Whether to expose the \"nodes\" directly on the connection for convenience.\n   *\n   * @default false\n   */\n  includeNodesField?: boolean\n  /**\n   * Any args to include by default on all connection fields, in addition to the ones in the spec.\n   *\n   * @default null\n   */\n  additionalArgs?: ArgsRecord\n  /**\n   * Set to true to disable forward pagination.\n   *\n   * @default false\n   */\n  disableForwardPagination?: boolean\n  /**\n   * Set to true to disable backward pagination.\n   *\n   * @default false\n   */\n  disableBackwardPagination?: boolean\n  /**\n   * Custom logic to validate the arguments.\n   *\n   * Defaults to requiring that either a `first` or `last` is provided, and that after / before must be paired\n   * with `first` or `last`, respectively.\n   */\n  validateArgs?: (args: Record<string, any>, info: GraphQLResolveInfo, root: unknown, ctx: unknown) => void\n  /**\n   * If disableForwardPagination or disableBackwardPagination are set to true, we require the `first` or\n   * `last` field as needed. Defaults to true, setting this to false will disable this behavior and make the\n   * field nullable.\n   */\n  strictArgs?: boolean\n  /**\n   * Default approach we use to transform a node into an unencoded cursor.\n   *\n   * Default is `cursor:${index}`\n   *\n   * @default field\n   */\n  cursorFromNode?: (\n    node: any,\n    args: PaginationArgs,\n    ctx: GetGen<'context'>,\n    info: GraphQLResolveInfo,\n    forCursor: { index: number; nodes: any[] }\n  ) => string | Promise<string>\n  /**\n   * Override the default behavior of determining hasNextPage / hasPreviousPage. Usually needed when\n   * customizing the behavior of `cursorFromNode`\n   */\n  pageInfoFromNodes?: (\n    allNodes: any[],\n    args: PaginationArgs,\n    ctx: GetGen<'context'>,\n    info: GraphQLResolveInfo\n  ) => MaybePromise<{ hasNextPage: boolean; hasPreviousPage: boolean }>\n  /** Conversion from a cursor string into an opaque token. Defaults to base64Encode(string) */\n  encodeCursor?: (value: string) => string\n  /** Conversion from an opaque token into a cursor string. Defaults to base64Decode(string) */\n  decodeCursor?: (cursor: string) => string\n  /** Extend *all* edges to include additional fields, beyond cursor and node */\n  extendEdge?: Record<\n    string,\n    Omit<FieldOutConfig<any, any>, 'resolve'> & {\n      /**\n       * Set requireResolver to false if you have already resolved this information during the resolve of the\n       * edges in the parent resolve method\n       *\n       * @default true\n       */\n      requireResolver?: boolean\n    }\n  >\n  /**\n   * Any additional fields to make available to the connection type, beyond edges / pageInfo / nodes.\n   *\n   * Any fields defined extended on the Connection type will automatically receive the args from the\n   * connection. If the field also defines args, they will be merged with the args of the connection, with the\n   * extension's field args taking precedence if there is a conflict.\n   */\n  extendConnection?: Record<\n    string,\n    Omit<FieldOutConfig<any, any>, 'resolve'> & {\n      /**\n       * Set requireResolver to false if you have already resolved this information during the resolve of the\n       * edges in the parent resolve method\n       *\n       * @default true\n       */\n      requireResolver?: boolean\n    }\n  >\n  /** Allows specifying a custom name for connection types. */\n  getConnectionName?(filedName: string, parentTypeName: string): string\n  /** Allows specifying a custom name for edge types. */\n  getEdgeName?(filedName: string, parentTypeName: string): string\n  /** Prefix for the Connection / Edge type */\n  typePrefix?: string\n  /**\n   * The path to the nexus package for typegen.\n   *\n   * This setting is only necessary when nexus is being wrapped by another library/framework such that `nexus`\n   * is not expected to be a direct dependency at the application level.\n   *\n   * @default 'nexus'\n   */\n  nexusSchemaImportId?: string\n  /**\n   * Configures the default \"nonNullDefaults\" settings for any connection types created globally by this\n   * config / connection field.\n   */\n  nonNullDefaults?: NonNullConfig\n  /** Allows specifying a custom cursor type, as the name of a scalar */\n  cursorType?:\n    | GetGen<'scalarNames'>\n    | NexusNullDef<GetGen<'scalarNames'>>\n    | NexusNonNullDef<GetGen<'scalarNames'>>\n}\n\n// Extract the node value from the connection for a given field.\nexport type NodeValue<TypeName extends string = any, FieldName extends string = any> = SourceValue<\n  EdgeTypeLookup<TypeName, FieldName>\n>['node']\n\nexport type ConnectionFieldConfig<TypeName extends string = any, FieldName extends string = any> = {\n  type: GetGen<'allOutputTypes', string> | AllNexusNamedOutputTypeDefs\n  /**\n   * Whether the connection field can be null\n   *\n   * @default (depends on whether nullability is configured in type or schema)\n   */\n  nullable?: boolean\n  /**\n   * Additional args to include for just this field\n   *\n   * @example\n   *   additionalArgs: {\n   *     orderBy: arg({ type: nonNull(SortOrderEnum) })\n   *   }\n   */\n  additionalArgs?: ArgsRecord\n  /**\n   * Whether to inherit \"additional args\" if they exist on the plugin definition\n   *\n   * @default false\n   */\n  inheritAdditionalArgs?: boolean\n  /**\n   * Approach we use to transform a node into a cursor.\n   *\n   * @default nodeField\n   */\n  cursorFromNode?: (\n    node: NodeValue<TypeName, FieldName>,\n    args: ArgsValue<TypeName, FieldName>,\n    ctx: GetGen<'context'>,\n    info: GraphQLResolveInfo,\n    forCursor: { index: number; nodes: NodeValue<TypeName, FieldName>[] }\n  ) => string | Promise<string>\n  /**\n   * Override the default behavior of determining hasNextPage / hasPreviousPage. Usually needed when\n   * customizing the behavior of `cursorFromNode`\n   */\n  pageInfoFromNodes?: (\n    nodes: NodeValue<TypeName, FieldName>[],\n    args: ArgsValue<TypeName, FieldName>,\n    ctx: GetGen<'context'>,\n    info: GraphQLResolveInfo\n  ) => MaybePromise<{ hasNextPage: boolean; hasPreviousPage: boolean }>\n  /**\n   * Whether the field allows for backward pagination\n   *\n   * @see https://relay.dev/graphql/connections.htm#sec-Backward-pagination-arguments\n   */\n  disableForwardPagination?: boolean\n  /**\n   * Whether the field allows for backward pagination\n   *\n   * @see https://relay.dev/graphql/connections.htm#sec-Forward-pagination-arguments\n   */\n  disableBackwardPagination?: boolean\n  /**\n   * If disableForwardPagination or disableBackwardPagination are set to true, we require the `first` or\n   * `last` field as needed. Defaults to true, setting this to false will disable this behavior and make the\n   * field nullable.\n   */\n  strictArgs?: boolean\n  /**\n   * Custom logic to validate the arguments.\n   *\n   * Defaults to requiring that either a `first` or `last` is provided, and that after / before must be paired\n   * with `first` or `last`, respectively.\n   */\n  validateArgs?: (\n    args: ArgsValue<TypeName, FieldName>,\n    info: GraphQLResolveInfo,\n    root: SourceValue<TypeName>,\n    ctx: GetGen<'context'>\n  ) => void\n  /**\n   * Dynamically adds additional fields to the current \"connection\" when it is defined. This will cause the\n   * resulting type to be prefix'ed with the name of the type/field it is branched off of, so as not to\n   * conflict with any non-extended connections.\n   */\n  extendConnection?: (def: ObjectDefinitionBlock<FieldTypeName<TypeName, FieldName>>) => void\n  /**\n   * Dynamically adds additional fields to the connection \"edge\" when it is defined. This will cause the\n   * resulting type to be prefix'ed with the name of the type/field it is branched off of, so as not to\n   * conflict with any non-extended connections.\n   */\n  extendEdge?: (\n    def: ObjectDefinitionBlock<FieldTypeName<FieldTypeName<TypeName, FieldName>, 'edges'>>\n  ) => void\n  /** Allows specifying a custom name for connection types. */\n  getConnectionName?(filedName: string, parentTypeName: string): string\n  /** Allows specifying a custom name for edge types. */\n  getEdgeName?(filedName: string, parentTypeName: string): string\n  /** Configures the default \"nonNullDefaults\" for connection type generated for this connection */\n  nonNullDefaults?: NonNullConfig\n  /**\n   * Allows specifying a custom cursor type, as the name of a scalar\n   *\n   * @example\n   *   cursorType: 'CustomString'\n   */\n  cursorType?:\n    | GetGen<'scalarNames'>\n    | NexusNullDef<GetGen<'scalarNames'>>\n    | NexusNonNullDef<GetGen<'scalarNames'>>\n  /**\n   * Defined automatically if you have extended the connectionPlugin globally\n   *\n   * If you wish to set \"requireResolver\" to false on the edge field definition in the connection plugin\n   */\n  edgeFields?: unknown\n} & (\n  | {\n      /**\n       * Nodes should resolve to an Array, with a length of one greater than the direction you are paginating.\n       *\n       * For example, if you're paginating forward, and assuming an Array with length 20:\n       *\n       * (first: 2) - [{id: 1}, {id: 2}, {id: 3}] - note: {id: 3} is extra\n       *\n       * (last: 2) - [{id: 18}, {id: 19}, {id: 20}] - note {id: 18} is extra\n       *\n       * We will then slice the array in the direction we're iterating, and if there are more than \"N\"\n       * results, we will assume there's a next page. If you set `assumeExactNodeCount: true` in the config,\n       * we will assume that a next page exists if the length >= the node count.\n       */\n      nodes: (\n        root: SourceValue<TypeName>,\n        args: ArgsValue<TypeName, FieldName>,\n        ctx: GetGen<'context'>,\n        info: GraphQLResolveInfo\n      ) => MaybePromise<Array<NodeValue<TypeName, FieldName>>>\n\n      // resolve XOR nodes\n      resolve?: never\n    }\n  | {\n      /**\n       * Implement the full resolve, including `edges` and `pageInfo`. Useful in more complex pagination\n       * cases, or if you want to use utilities from other libraries like GraphQL Relay JS, and only use Nexus\n       * for the construction and type-safety:\n       *\n       * Https://github.com/graphql/graphql-relay-js\n       */\n      resolve: (\n        root: SourceValue<TypeName>,\n        args: ArgsValue<TypeName, FieldName>,\n        ctx: GetGen<'context'>,\n        info: GraphQLResolveInfo\n      ) => MaybePromise<ResultValue<TypeName, FieldName>> | MaybePromiseDeep<ResultValue<TypeName, FieldName>>\n\n      // resolve XOR nodes\n      nodes?: never\n    }\n) &\n  Pick<CommonFieldConfig, 'deprecation' | 'description'> &\n  NexusGenPluginFieldConfig<TypeName, FieldName>\n\nexport const ForwardPaginateArgs = {\n  first: nullable(intArg({ description: 'Returns the first n elements from the list.' })),\n  after: nullable(\n    stringArg({ description: 'Returns the elements in the list that come after the specified cursor' })\n  ),\n}\n\nexport const ForwardOnlyStrictArgs = {\n  ...ForwardPaginateArgs,\n  first: nonNull(intArg({ description: 'Returns the first n elements from the list.' })),\n}\n\nexport const BackwardPaginateArgs = {\n  last: nullable(intArg({ description: 'Returns the last n elements from the list.' })),\n  before: nullable(\n    stringArg({ description: 'Returns the elements in the list that come before the specified cursor' })\n  ),\n}\n\nexport const BackwardOnlyStrictArgs = {\n  ...BackwardPaginateArgs,\n  last: nonNull(intArg({ description: 'Returns the last n elements from the list.' })),\n}\n\nfunction base64Encode(str: string) {\n  return Buffer.from(str, 'utf8').toString('base64')\n}\n\nfunction base64Decode(str: string) {\n  return Buffer.from(str, 'base64').toString('utf8')\n}\n\nexport type EdgeTypeLookup<TypeName extends string, FieldName extends string> = FieldTypeName<\n  FieldTypeName<TypeName, FieldName>,\n  'edges'\n>\n\nexport type EdgeFieldResolver<TypeName extends string, FieldName extends string, EdgeField extends string> = (\n  root: SourceValue<EdgeTypeLookup<TypeName, FieldName>>,\n  args: ArgsValue<TypeName, FieldName> & ArgsValue<EdgeTypeLookup<TypeName, FieldName>, EdgeField>,\n  context: GetGen<'context'>,\n  info: GraphQLResolveInfo\n) => MaybePromise<ResultValue<EdgeTypeLookup<TypeName, FieldName>, EdgeField>>\n\nexport type ConnectionFieldResolver<\n  TypeName extends string,\n  FieldName extends string,\n  ConnectionFieldName extends string\n> = (\n  root: SourceValue<TypeName>,\n  args: ArgsValue<FieldTypeName<TypeName, FieldName>, ConnectionFieldName>,\n  context: GetGen<'context'>,\n  info: GraphQLResolveInfo\n) => MaybePromise<ResultValue<FieldTypeName<TypeName, FieldName>, ConnectionFieldName>>\n\nexport type ConnectionNodesResolver<TypeName extends string, FieldName extends string> = (\n  root: SourceValue<TypeName>,\n  args: ArgsValue<TypeName, FieldName>,\n  context: GetGen<'context'>,\n  info: GraphQLResolveInfo\n) => MaybePromise<Array<NodeValue<TypeName, FieldName>>>\n\n// Used for type-safe extensions to pageInfo\nexport type PageInfoFieldResolver<\n  TypeName extends string,\n  FieldName extends string,\n  EdgeField extends string\n> = (\n  root: SourceValue<TypeName>,\n  args: ArgsValue<TypeName, FieldName>,\n  context: GetGen<'context'>,\n  info: GraphQLResolveInfo\n) => MaybePromise<ResultValue<TypeName, FieldName>['pageInfo'][EdgeField]>\n\nexport type EdgeLike = { cursor: string | PromiseLike<string>; node: any }\n\nexport const connectionPlugin = (connectionPluginConfig?: ConnectionPluginConfig) => {\n  const pluginConfig: ConnectionPluginConfig = { ...connectionPluginConfig }\n\n  // Define the plugin with the appropriate configuration.\n\n  return plugin({\n    name: 'ConnectionPlugin',\n    fieldDefTypes: [\n      printedGenTypingImport({\n        module: connectionPluginConfig?.nexusSchemaImportId ?? getOwnPackage().name,\n        bindings: ['core', 'connectionPluginCore'],\n      }),\n    ],\n    // Defines the field added to the definition block:\n    // t.connectionField('users', {\n    //   type: User\n    // })\n    onInstall(b) {\n      let dynamicConfig = []\n\n      const {\n        additionalArgs = {},\n        extendConnection: pluginExtendConnection,\n        extendEdge: pluginExtendEdge,\n        includeNodesField = false,\n        nexusFieldName = 'connectionField',\n      } = pluginConfig\n\n      // If to add fields to every connection, we require the resolver be defined on the\n      // field definition, unless fromResolve: true is passed in the config\n      if (pluginExtendConnection) {\n        eachObj(pluginExtendConnection, (val, key) => {\n          dynamicConfig.push(\n            `${key}${\n              val.requireResolver === false ? '?:' : ':'\n            } connectionPluginCore.ConnectionFieldResolver<TypeName, FieldName, \"${key}\">`\n          )\n        })\n      }\n\n      if (pluginExtendEdge) {\n        const edgeFields = mapObj(\n          pluginExtendEdge,\n          (val, key) =>\n            `${key}${\n              val.requireResolver === false ? '?:' : ':'\n            } connectionPluginCore.EdgeFieldResolver<TypeName, FieldName, \"${key}\">`\n        )\n        dynamicConfig.push(`edgeFields: { ${edgeFields.join(', ')} }`)\n      }\n\n      let printedDynamicConfig = ''\n      if (dynamicConfig.length > 0) {\n        printedDynamicConfig = ` & { ${dynamicConfig.join(', ')} }`\n      }\n\n      // Add the t.connectionField (or something else if we've changed the name)\n      b.addType(\n        dynamicOutputMethod({\n          name: nexusFieldName,\n          typeDescription: `\n            Adds a Relay-style connection to the type, with numerous options for configuration\n\n            @see https://nexusjs.org/docs/plugins/connection\n          `,\n          typeDefinition: `<FieldName extends string>(\n      fieldName: FieldName,\n      config: connectionPluginCore.ConnectionFieldConfig<TypeName, FieldName>${printedDynamicConfig}\n    ): void`,\n          factory({ typeName: parentTypeName, typeDef: t, args: factoryArgs, stage, builder, wrapping }) {\n            const [fieldName, fieldConfig] = factoryArgs as [string, ConnectionFieldConfig]\n            const targetType = fieldConfig.type\n\n            /* istanbul ignore if */\n            if (wrapping?.includes('List')) {\n              throw new Error(`Cannot chain .list with connectionField (on ${parentTypeName}.${fieldName})`)\n            }\n            const { targetTypeName, connectionName, edgeName } = getTypeNames(\n              fieldName,\n              parentTypeName,\n              fieldConfig,\n              pluginConfig\n            )\n\n            if (stage === 'build') {\n              assertCorrectConfig(parentTypeName, fieldName, pluginConfig, fieldConfig)\n            }\n\n            // Add the \"Connection\" type to the schema if it doesn't exist already\n            if (!b.hasType(connectionName)) {\n              b.addType(\n                objectType({\n                  name: connectionName,\n                  definition(t2) {\n                    t2.list.field('edges', {\n                      type: edgeName as any,\n                      description: `https://facebook.github.io/relay/graphql/connections.htm#sec-Edge-Types`,\n                    })\n                    t2.nonNull.field('pageInfo', {\n                      type: 'PageInfo' as any,\n                      description: `https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo`,\n                    })\n                    if (includeNodesField) {\n                      t2.list.field('nodes', {\n                        type: targetType,\n                        description: `Flattened list of ${targetTypeName} type`,\n                      })\n                    }\n                    if (pluginExtendConnection) {\n                      eachObj(pluginExtendConnection, (extensionFieldConfig, extensionFieldName) => {\n                        t2.field(extensionFieldName, extensionFieldConfig)\n                      })\n                    }\n                    provideSourceAndArgs(t2, () => {\n                      if (fieldConfig.extendConnection instanceof Function) {\n                        fieldConfig.extendConnection(t2)\n                      }\n                    })\n                  },\n                  nonNullDefaults: fieldConfig.nonNullDefaults ?? pluginConfig.nonNullDefaults,\n                })\n              )\n            }\n\n            // Add the \"Edge\" type to the schema if it doesn't exist already\n            if (!b.hasType(edgeName)) {\n              b.addType(\n                objectType({\n                  name: edgeName,\n                  definition(t2) {\n                    t2.field('cursor', {\n                      type: cursorType ?? nonNull('String'),\n                      description: 'https://facebook.github.io/relay/graphql/connections.htm#sec-Cursor',\n                    })\n                    t2.field('node', {\n                      type: targetType,\n                      description: 'https://facebook.github.io/relay/graphql/connections.htm#sec-Node',\n                    })\n                    if (pluginExtendEdge) {\n                      eachObj(pluginExtendEdge, (val, key) => {\n                        t2.field(key, val)\n                      })\n                    }\n                    provideArgs(t2, () => {\n                      if (fieldConfig.extendEdge instanceof Function) {\n                        fieldConfig.extendEdge(t2)\n                      }\n                    })\n                  },\n                  nonNullDefaults: fieldConfig.nonNullDefaults ?? pluginConfig.nonNullDefaults,\n                })\n              )\n            }\n\n            // Add the \"PageInfo\" type to the schema if it doesn't exist already\n            if (!b.hasType('PageInfo')) {\n              b.addType(\n                objectType({\n                  name: 'PageInfo',\n                  description:\n                    'PageInfo cursor, as defined in https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo',\n                  definition(t2) {\n                    t2.nonNull.field('hasNextPage', {\n                      type: 'Boolean',\n                      description: `Used to indicate whether more edges exist following the set defined by the clients arguments.`,\n                    })\n                    t2.nonNull.field('hasPreviousPage', {\n                      type: 'Boolean',\n                      description: `Used to indicate whether more edges exist prior to the set defined by the clients arguments.`,\n                    })\n                    t2.nullable.field('startCursor', {\n                      type: 'String',\n                      description: `The cursor corresponding to the first nodes in edges. Null if the connection is empty.`,\n                    })\n                    t2.nullable.field('endCursor', {\n                      type: 'String',\n                      description: `The cursor corresponding to the last nodes in edges. Null if the connection is empty.`,\n                    })\n                  },\n                })\n              )\n            }\n            const {\n              disableBackwardPagination,\n              disableForwardPagination,\n              validateArgs = defaultValidateArgs,\n              strictArgs = true,\n              cursorType,\n            } = {\n              ...pluginConfig,\n              ...fieldConfig,\n            }\n\n            let specArgs = {}\n            if (disableForwardPagination !== true && disableBackwardPagination !== true) {\n              specArgs = { ...ForwardPaginateArgs, ...BackwardPaginateArgs }\n            } else if (disableForwardPagination !== true) {\n              specArgs = strictArgs ? { ...ForwardOnlyStrictArgs } : { ...ForwardPaginateArgs }\n            } else if (disableBackwardPagination !== true) {\n              specArgs = strictArgs ? { ...BackwardOnlyStrictArgs } : { ...BackwardPaginateArgs }\n            }\n\n            // If we have additional args,\n\n            let fieldAdditionalArgs = {}\n            if (fieldConfig.additionalArgs) {\n              if (additionalArgs && fieldConfig.inheritAdditionalArgs) {\n                fieldAdditionalArgs = {\n                  ...additionalArgs,\n                  ...fieldConfig.additionalArgs,\n                }\n              } else {\n                fieldAdditionalArgs = {\n                  ...fieldConfig.additionalArgs,\n                }\n              }\n            } else if (additionalArgs) {\n              fieldAdditionalArgs = { ...additionalArgs }\n            }\n\n            const fieldArgs = {\n              ...fieldAdditionalArgs,\n              ...specArgs,\n            }\n\n            let resolveFn: GraphQLFieldResolver<any, any>\n            if (fieldConfig.resolve) {\n              if (includeNodesField) {\n                resolveFn = (root, args, ctx, info) => {\n                  return completeValue(fieldConfig.resolve(root, args, ctx, info), (val) => {\n                    if (val && val.nodes === undefined) {\n                      return withArgs(args, {\n                        get nodes() {\n                          return completeValue(val.edges, (edges) => edges.map((edge: any) => edge.node))\n                        },\n                        ...val,\n                      })\n                    }\n                    return withArgs(args, { ...val })\n                  })\n                }\n              } else {\n                resolveFn = fieldConfig.resolve\n              }\n            } else {\n              resolveFn = makeResolveFn(pluginConfig, fieldConfig)\n            }\n\n            let wrappedConnectionName: AllNexusOutputTypeDefs | string = connectionName\n            if (wrapping) {\n              if (typeof fieldConfig.nullable === 'boolean') {\n                throw new Error(\n                  '[connectionPlugin]: You cannot chain .null/.nonNull and also set the nullable in the connectionField definition.'\n                )\n              }\n              wrappedConnectionName = applyNexusWrapping(connectionName, wrapping)\n            } else {\n              if (fieldConfig.nullable === true) {\n                wrappedConnectionName = nullable(wrappedConnectionName as any)\n              } else if (fieldConfig.nullable === false) {\n                wrappedConnectionName = nonNull(wrappedConnectionName as any)\n              }\n            }\n            // Add the field to the type.\n            t.field(fieldName, {\n              ...nonConnectionFieldProps(fieldConfig),\n              args: fieldArgs,\n              type: wrappedConnectionName as any,\n              resolve(root, args: PaginationArgs, ctx, info) {\n                // TODO(2.0): Maybe switch the arguments around here to be consistent w/ resolver (breaking change)?\n                validateArgs(args, info, root, ctx)\n                return resolveFn(root, args, ctx, info)\n              },\n            })\n          },\n        })\n      )\n    },\n  })\n}\n\n// Extract all of the non-connection related field config we may want to apply for plugin purposes\nfunction nonConnectionFieldProps(fieldConfig: ConnectionFieldConfig) {\n  const {\n    additionalArgs,\n    cursorFromNode,\n    disableBackwardPagination,\n    disableForwardPagination,\n    extendConnection,\n    extendEdge,\n    inheritAdditionalArgs,\n    nodes,\n    pageInfoFromNodes,\n    resolve,\n    type,\n    validateArgs,\n    strictArgs,\n    nullable,\n    ...rest\n  } = fieldConfig\n  return rest\n}\n\nexport function makeResolveFn(\n  pluginConfig: ConnectionPluginConfig,\n  fieldConfig: ConnectionFieldConfig\n): GraphQLFieldResolver<any, any, any> {\n  const mergedConfig = { ...pluginConfig, ...fieldConfig }\n  return (root, args: PaginationArgs, ctx, info) => {\n    const { nodes: nodesResolve } = fieldConfig\n    const { decodeCursor = base64Decode, encodeCursor = base64Encode } = pluginConfig\n    const { pageInfoFromNodes = defaultPageInfoFromNodes, cursorFromNode = defaultCursorFromNode } =\n      mergedConfig\n    if (!nodesResolve) {\n      return null\n    }\n\n    const formattedArgs = { ...args }\n\n    if (args.before) {\n      formattedArgs.before = decodeCursor(args.before).replace(CURSOR_PREFIX, '')\n    }\n    if (args.after) {\n      formattedArgs.after = decodeCursor(args.after).replace(CURSOR_PREFIX, '')\n    }\n\n    if (args.last && !args.before && cursorFromNode === defaultCursorFromNode) {\n      throw new Error(`Cannot paginate backward without a \"before\" cursor by default.`)\n    }\n\n    // Local variable to cache the execution of fetching the nodes,\n    // which is needed for all fields.\n    let cachedNodes: MaybePromiseLike<Array<any>>\n    let cachedEdges: MaybePromiseLike<{\n      edges: EdgeLike[]\n      nodes: any[]\n    }>\n    let hasPromise = false\n\n    // Get all the nodes, before any pagination slicing\n    const resolveAllNodes = () => {\n      if (cachedNodes !== undefined) {\n        return cachedNodes\n      }\n\n      cachedNodes = completeValue(nodesResolve(root, formattedArgs, ctx, info) ?? null, (allNodes) => {\n        return allNodes ? Array.from(allNodes) : allNodes\n      })\n\n      return cachedNodes\n    }\n\n    const resolveEdgesAndNodes = () => {\n      if (cachedEdges !== undefined) {\n        return cachedEdges\n      }\n\n      cachedEdges = completeValue(resolveAllNodes(), (allNodes) => {\n        if (!allNodes) {\n          const arrPath = JSON.stringify(pathToArray(info.path))\n          console.warn(\n            `You resolved null/undefined from nodes() at path ${arrPath}, this is likely an error. Return an empty array to suppress this warning.`\n          )\n          return { edges: [], nodes: [] }\n        }\n\n        const resolvedEdgeList: MaybePromise<EdgeLike>[] = []\n        const resolvedNodeList: any[] = []\n\n        iterateNodes(allNodes, args, (maybeNode, i) => {\n          if (isPromiseLike(maybeNode)) {\n            hasPromise = true\n            resolvedNodeList.push(maybeNode)\n            resolvedEdgeList.push(\n              maybeNode.then((node) => {\n                return completeValue<string, any>(\n                  cursorFromNode(maybeNode, formattedArgs, ctx, info, {\n                    index: i,\n                    nodes: allNodes,\n                  }),\n                  (rawCursor) =>\n                    wrapEdge(pluginConfig, fieldConfig, formattedArgs, {\n                      cursor: encodeCursor(rawCursor),\n                      node,\n                    })\n                )\n              })\n            )\n          } else {\n            resolvedNodeList.push(maybeNode)\n            resolvedEdgeList.push(\n              wrapEdge(pluginConfig, fieldConfig, formattedArgs, {\n                node: maybeNode,\n                cursor: completeValue(\n                  cursorFromNode(maybeNode, formattedArgs, ctx, info, {\n                    index: i,\n                    nodes: allNodes,\n                  }),\n                  (rawCursor) => encodeCursor(rawCursor)\n                ),\n              })\n            )\n          }\n        })\n\n        if (hasPromise) {\n          return Promise.all([Promise.all(resolvedEdgeList), Promise.all(resolvedNodeList)]).then(\n            ([edges, nodes]) => ({ edges, nodes })\n          )\n        }\n\n        return {\n          nodes: resolvedNodeList,\n          // todo find type-safe way of doing this\n          edges: resolvedEdgeList as EdgeLike[],\n        }\n      })\n\n      return cachedEdges\n    }\n\n    const resolvePageInfo = () => {\n      return completeValue(resolveAllNodes(), (allNodes) =>\n        completeValue(resolveEdgesAndNodes(), ({ edges }) =>\n          completeValue(\n            allNodes\n              ? pageInfoFromNodes(allNodes, args, ctx, info)\n              : {\n                  hasNextPage: false,\n                  hasPreviousPage: false,\n                },\n            (basePageInfo) => ({\n              ...basePageInfo,\n              startCursor: edges?.[0]?.cursor ? edges[0].cursor : null,\n              endCursor: edges?.[edges.length - 1]?.cursor ?? null,\n            })\n          )\n        )\n      )\n    }\n\n    const connectionResult = withSource(root, formattedArgs, {\n      get nodes() {\n        return completeValue(resolveEdgesAndNodes(), (o) => o.nodes)\n      },\n      get edges() {\n        return completeValue(resolveEdgesAndNodes(), (o) => o.edges)\n      },\n      get pageInfo() {\n        return resolvePageInfo()\n      },\n    })\n\n    if (pluginConfig.extendConnection) {\n      Object.keys(pluginConfig.extendConnection).forEach((connectionField) => {\n        const resolve = (fieldConfig as any)[connectionField] ?? defaultFieldResolver\n        Object.defineProperty(connectionResult, connectionField, {\n          value: (args: object, ctx: unknown, info: GraphQLResolveInfo) => {\n            return resolve(root, { ...formattedArgs, ...args }, ctx, info)\n          },\n        })\n      })\n    }\n\n    return connectionResult\n  }\n}\n\nfunction wrapEdge<T extends object>(\n  pluginConfig: ConnectionPluginConfig,\n  fieldConfig: ConnectionFieldConfig,\n  formattedArgs: PaginationArgs,\n  edgeParentType: T\n): T {\n  const edge = withArgs(formattedArgs, edgeParentType)\n  if (pluginConfig.extendEdge) {\n    Object.keys(pluginConfig.extendEdge).forEach((edgeField) => {\n      const resolve = (fieldConfig as any).edgeFields?.[edgeField] ?? defaultFieldResolver\n      Object.defineProperty(edge, edgeField, {\n        value: (args: object, ctx: unknown, info: GraphQLResolveInfo) => {\n          return resolve(edge, { ...formattedArgs, ...args }, ctx, info)\n        },\n      })\n    })\n  }\n  return edge\n}\n\n/**\n * Adds __connectionArgs to the object representing the Connection type, so it can be accessed by other fields\n * in the top level\n *\n * @param args\n * @param connectionParentType\n */\nfunction withArgs<T extends object>(args: PaginationArgs, connectionParentType: T): T {\n  Object.defineProperty(connectionParentType, '__connectionArgs', {\n    value: args,\n    enumerable: false,\n  })\n  return connectionParentType\n}\n\n/**\n * Adds __connectionSource to the object representing the Connection type, so it can be accessed by other\n * fields in the top level\n *\n * @param args\n * @param connectionParentType\n */\nfunction withSource<T extends object>(source: unknown, args: PaginationArgs, connectionParentType: T): T {\n  Object.defineProperty(connectionParentType, '__connectionSource', {\n    value: source,\n    enumerable: false,\n  })\n  return withArgs(args, connectionParentType)\n}\n\n/** Takes __connectionArgs from the source object and merges with the args provided by the */\nfunction mergeArgs(obj: object, fieldArgs: ArgsValue<any, any>): ArgsValue<any, any> {\n  return { ...(obj as any).__connectionArgs, ...fieldArgs }\n}\n\n/**\n * Takes a \"builder\", and a function which takes a builder, and ensures that all fields defined within that\n * function invocation are provided the __connectionArgs defined by the connection\n */\nfunction provideArgs(block: ObjectDefinitionBlock<any>, fn: () => void) {\n  const fieldDef = block.field\n  block.field = function (\n    ...args:\n      | [name: string, config: FieldOutConfig<any, string>]\n      | [config: FieldOutConfigWithName<any, string>]\n  ) {\n    let config = args.length === 2 ? { name: args[0], ...args[1] } : args[0]\n\n    const { resolve = defaultFieldResolver } = config\n\n    fieldDef.call(this, {\n      ...config,\n      resolve(root, args, ctx, info) {\n        return resolve(root, mergeArgs(root, args), ctx, info)\n      },\n    })\n  }\n  fn()\n  block.field = fieldDef\n}\n\nfunction provideSourceAndArgs(block: ObjectDefinitionBlock<any>, fn: () => void) {\n  const fieldDef = block.field\n  block.field = function (\n    ...args:\n      | [name: string, config: FieldOutConfig<any, string>]\n      | [config: FieldOutConfigWithName<any, string>]\n  ) {\n    let config = args.length === 2 ? { name: args[0], ...args[1] } : args[0]\n\n    const { resolve = defaultFieldResolver } = config\n\n    fieldDef.call(this, {\n      ...config,\n      resolve(root, args, ctx, info) {\n        return resolve(root.__connectionSource, mergeArgs(root, args), ctx, info)\n      },\n    })\n  }\n  fn()\n  block.field = fieldDef\n}\n\nfunction iterateNodes(nodes: any[], args: PaginationArgs, cb: (node: any, i: number) => void) {\n  // If we want the first N of an array of nodes, it's pretty straightforward.\n  if (typeof args.first === 'number') {\n    const len = Math.min(args.first, nodes.length)\n    for (let i = 0; i < len; i++) {\n      cb(nodes[i], i)\n    }\n  } else if (typeof args.last === 'number') {\n    const len = Math.min(args.last, nodes.length)\n    for (let i = 0; i < len; i++) {\n      cb(nodes[i], i)\n    }\n  } else {\n    // Only happens if we have a custom validateArgs that ignores first/last\n    for (let i = 0; i < nodes.length; i++) {\n      cb(nodes[i], i)\n    }\n  }\n}\n\nexport type PaginationArgs = {\n  first?: number | null\n  after?: string | null\n  last?: number | null\n  before?: string | null\n}\n\nfunction defaultPageInfoFromNodes(nodes: any[], args: PaginationArgs) {\n  return {\n    hasNextPage: defaultHasNextPage(nodes, args),\n    hasPreviousPage: defaultHasPreviousPage(nodes, args),\n  }\n}\n\nfunction defaultHasNextPage(nodes: any[], args: PaginationArgs) {\n  // If we're paginating forward, and we don't have an \"after\", we'll assume that we don't have\n  // a previous page, otherwise we will assume we have one, unless the after cursor === \"0\".\n  if (typeof args.first === 'number') {\n    return nodes.length > args.first\n  }\n  // If we're paginating backward, and there are as many results as we asked for, then we'll assume\n  // that we have a previous page\n  if (typeof args.last === 'number') {\n    if (args.before && args.before !== '0') {\n      return true\n    }\n    return false\n  }\n  /* istanbul ignore next */\n  throw new Error('Unreachable')\n}\n\n/** A sensible default for determining \"previous page\". */\nfunction defaultHasPreviousPage(nodes: any[], args: PaginationArgs) {\n  // If we're paginating forward, and we don't have an \"after\", we'll assume that we don't have\n  // a previous page, otherwise we will assume we have one, unless the after cursor === \"0\".\n  if (typeof args.first === 'number') {\n    if (args.after && args.after !== '0') {\n      return true\n    }\n    return false\n  }\n  // If we're paginating backward, and there are as many results as we asked for, then we'll assume\n  // that we have a previous page\n  if (typeof args.last === 'number') {\n    return nodes.length >= args.last\n  }\n  /* istanbul ignore next */\n  throw new Error('Unreachable')\n}\n\nconst CURSOR_PREFIX = 'cursor:'\n\n// Assumes we're only paginating in one direction.\nfunction defaultCursorFromNode(\n  node: any,\n  args: PaginationArgs,\n  ctx: any,\n  info: GraphQLResolveInfo,\n  { index, nodes }: { index: number; nodes: any[] }\n) {\n  let cursorIndex = index\n  // If we're paginating forward, assume we're incrementing from the offset provided via \"after\",\n  // e.g. [0...20] (first: 5, after: \"cursor:5\") -> [cursor:6, cursor:7, cursor:8, cursor:9, cursor: 10]\n  if (typeof args.first === 'number') {\n    if (args.after) {\n      const offset = parseInt(args.after, 10)\n      cursorIndex = offset + index + 1\n    }\n  }\n\n  // If we're paginating backward, assume we're working backward from the assumed length\n  // e.g. [0...20] (last: 5, before: \"cursor:20\") -> [cursor:15, cursor:16, cursor:17, cursor:18, cursor:19]\n  if (typeof args.last === 'number') {\n    if (args.before) {\n      const offset = parseInt(args.before, 10)\n      const len = Math.min(nodes.length, args.last)\n      cursorIndex = offset - len + index\n    } else {\n      /* istanbul ignore next */\n      throw new Error('Unreachable')\n    }\n  }\n  return `${CURSOR_PREFIX}${cursorIndex}`\n}\n\nconst getTypeNames = (\n  fieldName: string,\n  parentTypeName: string,\n  fieldConfig: ConnectionFieldConfig,\n  pluginConfig: ConnectionPluginConfig\n) => {\n  const targetTypeName =\n    typeof fieldConfig.type === 'string' ? fieldConfig.type : (fieldConfig.type.name as string)\n\n  // If we have changed the config specific to this field, on either the connection,\n  // edge, or page info, then we need a custom type for the connection & edge.\n  let connectionName: string\n  if (fieldConfig.getConnectionName) {\n    connectionName = fieldConfig.getConnectionName(fieldName, parentTypeName)\n  } else if (pluginConfig.getConnectionName) {\n    connectionName = pluginConfig.getConnectionName(fieldName, parentTypeName)\n  } else if (isConnectionFieldExtended(fieldConfig)) {\n    connectionName = `${parentTypeName}${upperFirst(fieldName)}_Connection`\n  } else {\n    connectionName = `${pluginConfig.typePrefix || ''}${targetTypeName}Connection`\n  }\n\n  // If we have modified the \"edge\" at all, then we need\n  let edgeName\n  if (fieldConfig.getEdgeName) {\n    edgeName = fieldConfig.getEdgeName(fieldName, parentTypeName)\n  } else if (pluginConfig.getEdgeName) {\n    edgeName = pluginConfig.getEdgeName(fieldName, parentTypeName)\n  } else if (isEdgeFieldExtended(fieldConfig)) {\n    edgeName = `${parentTypeName}${upperFirst(fieldName)}_Edge`\n  } else {\n    edgeName = `${pluginConfig.typePrefix || ''}${targetTypeName}Edge`\n  }\n\n  return {\n    edgeName,\n    targetTypeName,\n    connectionName,\n  }\n}\n\nconst isConnectionFieldExtended = (fieldConfig: ConnectionFieldConfig) => {\n  if (fieldConfig.extendConnection || isEdgeFieldExtended(fieldConfig)) {\n    return true\n  }\n  return false\n}\n\nconst isEdgeFieldExtended = (fieldConfig: ConnectionFieldConfig) => {\n  if (fieldConfig.extendEdge || fieldConfig.cursorType) {\n    return true\n  }\n  return false\n}\n\nconst upperFirst = (fieldName: string) => {\n  return fieldName.slice(0, 1).toUpperCase().concat(fieldName.slice(1))\n}\n\n// Add some sanity checking beyond the normal type checks.\nconst assertCorrectConfig = (\n  typeName: string,\n  fieldName: string,\n  pluginConfig: ConnectionPluginConfig,\n  fieldConfig: any\n) => {\n  if (typeof fieldConfig.nodes !== 'function' && typeof fieldConfig.resolve !== 'function') {\n    console.error(\n      new Error(`Nexus Connection Plugin: Missing nodes or resolve property for ${typeName}.${fieldName}`)\n    )\n  }\n  eachObj(pluginConfig.extendConnection || {}, (val, key) => {\n    if (typeof fieldConfig[key] !== 'function' && val.requireResolver !== false) {\n      console.error(\n        new Error(\n          `Nexus Connection Plugin: Missing ${key} resolver property for ${typeName}.${fieldName}. Set requireResolver to \"false\" on the field config if you do not need a resolver.`\n        )\n      )\n    }\n  })\n  eachObj(pluginConfig.extendEdge || {}, (val, key) => {\n    if (typeof fieldConfig.edgeFields?.[key] !== 'function' && val.requireResolver !== false) {\n      console.error(\n        new Error(\n          `Nexus Connection Plugin: Missing edgeFields.${key} resolver property for ${typeName}.${fieldName}. Set requireResolver to \"false\" on the edge field config if you do not need a resolver.`\n        )\n      )\n    }\n  })\n}\n\nfunction defaultValidateArgs(args: Record<string, any> = {}, info: GraphQLResolveInfo) {\n  if (!(args.first || args.first === 0) && !(args.last || args.last === 0)) {\n    throw new Error(\n      `The ${info.parentType}.${info.fieldName} connection field requires a \"first\" or \"last\" argument`\n    )\n  }\n  if (args.first && args.last) {\n    throw new Error(\n      `The ${info.parentType}.${info.fieldName} connection field requires a \"first\" or \"last\" argument, not both`\n    )\n  }\n  if (args.first && args.before) {\n    throw new Error(\n      `The ${info.parentType}.${info.fieldName} connection field does not allow a \"before\" argument with \"first\"`\n    )\n  }\n  if (args.last && args.after) {\n    throw new Error(\n      `The ${info.parentType}.${info.fieldName} connection field does not allow a \"last\" argument with \"after\"`\n    )\n  }\n}\n\n// Provided for use if you create a custom implementation and want to call the original.\nconnectionPlugin.defaultCursorFromNode = defaultCursorFromNode\nconnectionPlugin.defaultValidateArgs = defaultValidateArgs\nconnectionPlugin.defaultHasPreviousPage = defaultHasPreviousPage\nconnectionPlugin.defaultHasNextPage = defaultHasNextPage\nconnectionPlugin.base64Encode = base64Encode\nconnectionPlugin.base64Decode = base64Decode\nconnectionPlugin.CURSOR_PREFIX = CURSOR_PREFIX\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2627, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/plugins/fieldAuthorizePlugin.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/plugins/fieldAuthorizePlugin.ts"],"sourcesContent":["import type { GraphQLResolveInfo } from 'graphql'\nimport { plugin } from '../plugin'\nimport type { ArgsValue, GetGen, MaybePromise, SourceValue } from '../typegenTypeHelpers'\nimport { printedGenTyping, printedGenTypingImport } from '../utils'\n\nconst FieldauthorizeResolverImport = printedGenTypingImport({\n  module: 'nexus/dist/plugins/fieldAuthorizePlugin',\n  bindings: ['FieldAuthorizeResolver'],\n})\n\nconst fieldDefTypes = printedGenTyping({\n  optional: true,\n  name: 'authorize',\n  description: `\n    Authorization for an individual field. Returning \"true\"\n    or \"Promise<true>\" means the field can be accessed.\n    Returning \"false\" or \"Promise<false>\" will respond\n    with a \"Not Authorized\" error for the field. \n    Returning or throwing an error will also prevent the \n    resolver from executing.\n  `,\n  type: 'FieldAuthorizeResolver<TypeName, FieldName>',\n  imports: [FieldauthorizeResolverImport],\n})\n\nexport type FieldAuthorizeResolver<TypeName extends string, FieldName extends string> = (\n  root: SourceValue<TypeName>,\n  args: ArgsValue<TypeName, FieldName>,\n  context: GetGen<'context'>,\n  info: GraphQLResolveInfo\n) => MaybePromise<boolean | Error>\n\nexport interface FieldAuthorizePluginErrorConfig {\n  error: Error\n  root: any\n  args: any\n  ctx: GetGen<'context'>\n  info: GraphQLResolveInfo\n}\n\nexport interface FieldAuthorizePluginConfig {\n  formatError?: (authConfig: FieldAuthorizePluginErrorConfig) => Error\n}\n\nexport const defaultFormatError = ({ error }: FieldAuthorizePluginErrorConfig): Error => {\n  const err: Error & { originalError?: Error } = new Error('Not authorized')\n  err.originalError = error\n  return err\n}\n\nexport const fieldAuthorizePlugin = (authConfig: FieldAuthorizePluginConfig = {}) => {\n  const { formatError = defaultFormatError } = authConfig\n  const ensureError =\n    (root: any, args: any, ctx: GetGen<'context'>, info: GraphQLResolveInfo) => (error: Error) => {\n      const finalErr = formatError({ error, root, args, ctx, info })\n      if (finalErr instanceof Error) {\n        throw finalErr\n      }\n      console.error(`Non-Error value ${finalErr} returned from custom formatError in authorize plugin`)\n      throw new Error('Not authorized')\n    }\n  let hasWarned = false\n  return plugin({\n    name: 'NexusAuthorize',\n    description: 'The authorize plugin provides field-level authorization for a schema.',\n    fieldDefTypes: fieldDefTypes,\n    onCreateFieldResolver(config) {\n      const authorize = config.fieldConfig.extensions?.nexus?.config.authorize\n      // If the field doesn't have an authorize field, don't worry about wrapping the resolver\n      if (authorize == null) {\n        return\n      }\n      // If it does have this field, but it's not a function, it's wrong - let's provide a warning\n      if (typeof authorize !== 'function') {\n        console.error(\n          new Error(\n            `The authorize property provided to ${config.fieldConfig.name} with type ${\n              config.fieldConfig.type\n            } should be a function, saw ${typeof authorize}`\n          )\n        )\n        return\n      }\n      // If they have it, but didn't explicitly specify a plugins array, warn them.\n      if (!config.schemaConfig.plugins?.find((p) => p.config.name === 'NexusAuthorize')) {\n        if (!hasWarned) {\n          console.warn(\n            'The GraphQL Nexus \"authorize\" feature has been moved to a plugin, add [fieldAuthorizePlugin()] to your makeSchema plugin config to remove this warning.'\n          )\n          hasWarned = true\n        }\n      }\n      // The authorize wrapping resolver.\n      return function (root, args, ctx, info, next) {\n        let toComplete\n        try {\n          toComplete = authorize(root, args, ctx, info)\n        } catch (e) {\n          toComplete = Promise.reject(e)\n        }\n        return plugin.completeValue(\n          toComplete,\n          (authResult) => {\n            if (authResult === true) {\n              return next(root, args, ctx, info)\n            }\n            const finalFormatError = ensureError(root, args, ctx, info)\n            if (authResult instanceof Error) {\n              finalFormatError(authResult)\n            }\n            if (authResult === false) {\n              finalFormatError(new Error('Not authorized'))\n            }\n            const {\n              fieldName,\n              parentType: { name: parentTypeName },\n            } = info\n            finalFormatError(\n              new Error(\n                `Nexus authorize for ${parentTypeName}.${fieldName} Expected a boolean or Error, saw ${authResult}`\n              )\n            )\n          },\n          (err) => {\n            ensureError(root, args, ctx, info)(err)\n          }\n        )\n      }\n    },\n  })\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2736, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/plugins/nullabilityGuardPlugin.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/plugins/nullabilityGuardPlugin.ts"],"sourcesContent":["import {\n  GraphQLNullableType,\n  GraphQLOutputType,\n  GraphQLResolveInfo,\n  isEnumType,\n  isInterfaceType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n  isWrappingType,\n} from 'graphql'\nimport { forEach } from 'iterall'\nimport type { GraphQLPossibleOutputs } from '../definitions/_types'\nimport type { NexusGraphQLNamedType } from '../extensions'\nimport { CreateFieldResolverInfo, plugin } from '../plugin'\nimport type { AllOutputTypes, GetGen, GetGen2 } from '../typegenTypeHelpers'\nimport { isPromiseLike, printedGenTyping } from '../utils'\n\nexport interface NullabilityPluginFallbackFn {\n  ctx: GetGen<'context'>\n  info: GraphQLResolveInfo\n  type: GraphQLPossibleOutputs\n}\n\nexport interface NullabilityPluginOnGuardedConfig {\n  fallback: any\n  ctx: GetGen<'context'>\n  info: GraphQLResolveInfo\n  type: GraphQLNullableType\n}\n\nexport type NullFallbackValues = Partial<{\n  [K in AllOutputTypes]: (obj: NullabilityPluginFallbackFn) => GetGen2<'rootTypes', K>\n}>\n\nexport type NullabilityGuardConfig = {\n  /** Whether we should guard against non-null values. Defaults to \"true\" if NODE_ENV === \"production\", false otherwise. */\n  shouldGuard?: boolean\n  /**\n   * When a nullish value is \"guarded\", meaning it is coerced into an acceptable non-null value, this function\n   * will be called if supplied.\n   */\n  onGuarded?: (obj: NullabilityPluginOnGuardedConfig) => void\n  /** A mapping of typename to the value that should be used in the case of a null value. */\n  fallbackValues?: NullFallbackValues\n}\n\nconst fieldDefTypes = printedGenTyping({\n  name: 'skipNullGuard',\n  optional: true,\n  type: 'boolean',\n  description: `\n    The nullability guard can be helpful, but is also a potentially expensive operation for lists.\n    We need to iterate the entire list to check for null items to guard against. Set this to true\n    to skip the null guard on a specific field if you know there's no potential for unsafe types.\n  `,\n})\n\nexport const nullabilityGuardPlugin = (pluginConfig: NullabilityGuardConfig) => {\n  const {\n    shouldGuard = process.env.NODE_ENV === 'production',\n    fallbackValues = {},\n    onGuarded = (obj: NullabilityPluginOnGuardedConfig) => {\n      console.warn(`Nullability guard called for ${obj.info.parentType.name}.${obj.info.fieldName}`)\n    },\n  } = pluginConfig\n  const finalPluginConfig: Required<NullabilityGuardConfig> = {\n    shouldGuard,\n    onGuarded,\n    fallbackValues,\n  }\n  return plugin({\n    name: 'NullabilityGuard',\n    description: 'If we have a nullable field, we want to guard against this being an issue in production.',\n    fieldDefTypes,\n    onCreateFieldResolver(config: CreateFieldResolverInfo<{ skipNullGuard: boolean }>) {\n      if (config.fieldConfig.extensions?.nexus?.config.skipNullGuard) {\n        return\n      }\n      const { type } = config.fieldConfig\n      const { outerNonNull, hasListNonNull } = nonNullInfo(type)\n      if (outerNonNull || hasListNonNull) {\n        return (root, args, ctx, info, next) => {\n          return plugin.completeValue(\n            next(root, args, ctx, info),\n            nonNullGuard(\n              ctx,\n              info,\n              isNonNullType(type) ? type.ofType : type,\n              config,\n              finalPluginConfig,\n              outerNonNull\n            )\n          )\n        }\n      }\n    },\n    onAfterBuild(schema) {\n      Object.keys(schema.getTypeMap()).forEach((typeName) => {\n        const type = schema.getType(typeName) as NexusGraphQLNamedType\n        if (isScalarType(type)) {\n          if (fallbackValues[type.name as keyof typeof fallbackValues]) {\n            return\n          }\n          console.error(\n            `No nullability guard was provided for Scalar ${type.name}. ` +\n              `Provide one in the nullabilityGuard config to remove this warning.`\n          )\n        }\n      })\n      if (pluginConfig.fallbackValues) {\n        Object.keys(pluginConfig.fallbackValues).forEach((name) => {\n          const type = schema.getType(name) as NexusGraphQLNamedType\n          if (!type) {\n            return console.error(`Unknown type ${name} provided in nullabilityGuard fallbackValues config.`)\n          }\n        })\n      }\n    },\n  })\n}\n\nconst isNullish = (val: any): boolean => val === null || val === undefined || val !== val\n\nconst nonNullGuard = (\n  ctx: GetGen<'context'>,\n  info: GraphQLResolveInfo,\n  type: GraphQLOutputType,\n  config: CreateFieldResolverInfo,\n  pluginConfig: Required<NullabilityGuardConfig>,\n  outerNonNull: boolean\n) => {\n  const { onGuarded, fallbackValues, shouldGuard } = pluginConfig\n  const guardResult = (fallback: any) => {\n    onGuarded({ ctx, info, type, fallback })\n    return shouldGuard ? fallback : null\n  }\n  return (val: any) => {\n    // If it's a list type, return [] if the value is null,\n    // otherwise recurse into resolving the individual type.\n    if (isListType(type)) {\n      if (isNullish(val)) {\n        return outerNonNull ? guardResult([]) : null\n      }\n      let hasPromise = false\n      const listMembers: any[] = []\n      const listCompleter = nonNullGuard(\n        ctx,\n        info,\n        isNonNullType(type.ofType) ? type.ofType.ofType : type.ofType,\n        config,\n        pluginConfig,\n        isNonNullType(type.ofType)\n      )\n      forEach(val as any, (item) => {\n        if (!hasPromise && isPromiseLike(item)) {\n          hasPromise = true\n        }\n        listMembers.push(plugin.completeValue(item, listCompleter))\n      })\n      return hasPromise ? Promise.all(listMembers) : listMembers\n    }\n    if (!isNullish(val) || outerNonNull === false) {\n      return val\n    }\n    const typeName = type.name as keyof typeof fallbackValues\n    const fallbackFn = fallbackValues[typeName]\n    const fallbackValue = typeof fallbackFn === 'function' ? fallbackFn({ type, info, ctx }) : null\n\n    if (!isNullish(fallbackValue)) {\n      return guardResult(fallbackValue)\n    }\n    // If it's an object, just return an empty object and let the scalar fallbacks take care of the rest\n    if (isObjectType(type)) {\n      return guardResult({})\n    }\n    // If it's an enum, return the first member\n    if (isEnumType(type)) {\n      return guardResult(type.getValues()[0].value)\n    }\n    // If It's a union or interface, return the first type\n    if (isUnionType(type) || isInterfaceType(type)) {\n      const possibleTypes = info.schema.getPossibleTypes(type)\n      return guardResult({ __typename: possibleTypes[0].name })\n    }\n    // Otherwise, fail?\n    return val\n  }\n}\n\ninterface NonNullInfo {\n  outerNonNull: boolean\n  hasListNonNull: boolean\n}\n\nconst nonNullInfo = (type: GraphQLOutputType): NonNullInfo => {\n  let outerNonNull = false\n  let hasListNonNull = false\n  if (isNonNullType(type)) {\n    outerNonNull = true\n    type = type.ofType\n  }\n  while (isWrappingType(type)) {\n    type = type.ofType\n    if (isNonNullType(type)) {\n      hasListNonNull = true\n    }\n  }\n  return {\n    outerNonNull,\n    hasListNonNull,\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2889, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/plugins/queryComplexityPlugin.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/plugins/queryComplexityPlugin.ts"],"sourcesContent":["import type { GraphQLField } from 'graphql'\nimport type { ArgsValue, GetGen, SourceValue } from '../core'\nimport { plugin } from '../plugin'\nimport { printedGenTyping, printedGenTypingImport } from '../utils'\n\nconst QueryComplexityImport = printedGenTypingImport({\n  module: 'nexus/dist/plugins/queryComplexityPlugin',\n  bindings: ['QueryComplexity'],\n})\n\nconst fieldDefTypes = printedGenTyping({\n  optional: true,\n  name: 'complexity',\n  description: `\n    The complexity for an individual field. Return a number\n    or a function that returns a number to specify the\n    complexity for this field.\n  `,\n  type: 'QueryComplexity<TypeName, FieldName>',\n  imports: [QueryComplexityImport],\n})\n\nexport type QueryComplexityEstimatorArgs<TypeName extends string, FieldName extends string> = {\n  type: SourceValue<TypeName>\n  field: GraphQLField<SourceValue<TypeName>, GetGen<'context'>, ArgsValue<TypeName, FieldName>>\n  args: ArgsValue<TypeName, FieldName>\n  childComplexity: number\n}\n\nexport type QueryComplexityEstimator<TypeName extends string, FieldName extends string> = (\n  options: QueryComplexityEstimatorArgs<TypeName, FieldName>\n) => number | void\n\nexport type QueryComplexity<TypeName extends string, FieldName extends string> =\n  | number\n  | QueryComplexityEstimator<TypeName, FieldName>\n\nexport const queryComplexityPlugin = () => {\n  return plugin({\n    name: 'query-complexity',\n    description: `\n      The query complexity plugin allows defining field-level complexity values that\n      works with the graphql-query-complexity library.\n    `,\n    fieldDefTypes,\n    onCreateFieldResolver(config) {\n      // Look for complexity property defined in the nexus config\n      const complexity = config.fieldConfig.extensions?.nexus?.config.complexity\n      // Skip if field doesn't have complexity property\n      if (complexity == null) {\n        return\n      }\n      // If the complexity is not a number or a function that returns a number, provide a warning\n      if (typeof complexity !== 'number' && typeof complexity !== 'function') {\n        const parentName = config.parentTypeConfig.name\n        const fieldName = config.fieldConfig.extensions?.nexus?.config.name\n        console.error(\n          new Error(\n            `The complexity property provided to ${parentName}.${fieldName} should be a number or a function that returns a number, saw ${typeof complexity}`\n          )\n        )\n        return\n      }\n      // Mutate the field config's extensions property with new complexity field.\n      // graphql-query-complexity will look for this property to estimate complexity\n      config.fieldConfig.extensions = {\n        ...config.fieldConfig.extensions,\n        complexity,\n      } as any\n\n      return undefined\n    },\n  })\n}\n"],"names":[],"mappings":";;;;AAEA,OAAO,EAAE,MAAM,EAAE,MAAM,WAAW,CAAA;AAClC,OAAO,EAAE,gBAAgB,EAAE,sBAAsB,EAAE,MAAM,UAAU,CAAA;;;AAEnE,MAAM,qBAAqB,OAAG,8OAAsB,EAAC;IACnD,MAAM,EAAE,0CAA0C;IAClD,QAAQ,EAAE;QAAC,iBAAiB;KAAC;CAC9B,CAAC,CAAA;AAEF,MAAM,aAAa,OAAG,wOAAgB,EAAC;IACrC,QAAQ,EAAE,IAAI;IACd,IAAI,EAAE,YAAY;IAClB,WAAW,EAAE,CAAA;;;;GAIZ;IACD,IAAI,EAAE,sCAAsC;IAC5C,OAAO,EAAE;QAAC,qBAAqB;KAAC;CACjC,CAAC,CAAA;AAiBK,MAAM,qBAAqB,GAAG,GAAG,EAAE;IACxC,WAAO,+NAAM,EAAC;QACZ,IAAI,EAAE,kBAAkB;QACxB,WAAW,EAAE,CAAA;;;KAGZ;QACD,aAAa;QACb,qBAAqB,EAAC,MAAM;;YAC1B,2DAA2D;YAC3D,MAAM,UAAU,GAAG,CAAA,KAAA,CAAA,KAAA,MAAM,CAAC,WAAW,CAAC,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,KAAK,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,MAAM,CAAC,UAAU,CAAA;YAC1E,iDAAiD;YACjD,IAAI,UAAU,IAAI,IAAI,EAAE;gBACtB,OAAM;aACP;YACD,2FAA2F;YAC3F,IAAI,OAAO,UAAU,KAAK,QAAQ,IAAI,OAAO,UAAU,KAAK,UAAU,EAAE;gBACtE,MAAM,UAAU,GAAG,MAAM,CAAC,gBAAgB,CAAC,IAAI,CAAA;gBAC/C,MAAM,SAAS,GAAG,CAAA,KAAA,CAAA,KAAA,MAAM,CAAC,WAAW,CAAC,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,KAAK,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,MAAM,CAAC,IAAI,CAAA;gBACnE,OAAO,CAAC,KAAK,CACX,IAAI,KAAK,CACP,CAAA,oCAAA,EAAuC,UAAU,CAAA,CAAA,EAAI,SAAS,CAAA,6DAAA,EAAgE,OAAO,UAAU,EAAE,CAClJ,CACF,CAAA;gBACD,OAAM;aACP;YACD,2EAA2E;YAC3E,8EAA8E;YAC9E,MAAM,CAAC,WAAW,CAAC,UAAU,GAAG,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAC3B,MAAM,CAAC,WAAW,CAAC,UAAU,GAAA;gBAChC,UAAU;YAAA,EACJ,CAAA;YAER,OAAO,SAAS,CAAA;QAClB,CAAC;KACF,CAAC,CAAA;AACJ,CAAC,CAAA"}},
    {"offset": {"line": 2952, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/plugins/declarativeWrappingPlugin.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/plugins/declarativeWrappingPlugin.ts"],"sourcesContent":["import type { NexusFinalArgConfig } from '../definitions/args'\nimport type { NexusInputFieldDef, NexusOutputFieldDef } from '../definitions/definitionBlocks'\nimport { list } from '../definitions/list'\nimport { nonNull } from '../definitions/nonNull'\nimport { nullable } from '../definitions/nullable'\nimport { plugin } from '../plugin'\nimport { printedGenTyping } from '../utils'\nimport { isNexusWrappingType } from '../definitions/wrapping'\nimport { messages } from '../messages'\n\ninterface DeclarativeWrappingApi {\n  nullable?: boolean\n  list?: true | boolean[]\n  required?: boolean\n}\n\nconst DeclarativeWrapping = [\n  printedGenTyping({\n    name: 'nullable',\n    type: 'boolean',\n    optional: true,\n    description: `\\\nWhether the type can be null\n@default (depends on whether nullability is configured in type or schema)\n@see declarativeWrappingPlugin\n`,\n  }),\n  printedGenTyping({\n    name: 'list',\n    type: 'true | boolean[]',\n    optional: true,\n    description: `\\\nWhether the type is list of values, or just a single value.\n\nIf list is true, we assume the type is a list. If list is an array,\nwe'll assume that it's a list with the depth. The boolean indicates whether\nthe type is required (non-null), where true = nonNull, false = nullable.\n\n@see declarativeWrappingPlugin\n`,\n  }),\n  printedGenTyping({\n    name: 'required',\n    type: 'boolean',\n    optional: true,\n    description: `\\\nWhether the type should be non null, \\`required: true\\` = \\`nullable: false\\`\n@default (depends on whether nullability is configured in type or schema)\n\n@see declarativeWrappingPlugin\n`,\n  }),\n]\n\nexport type DeclarativeWrappingPluginConfig = {\n  /** Whether we should warn, the default when not otherwise specified. */\n  shouldWarn?: boolean\n  /** Whether we should completely disable the plugin, not install types, and throw when we encounter any issues. */\n  disable?: boolean\n}\n\nexport const declarativeWrappingPlugin = (config: DeclarativeWrappingPluginConfig = {}) => {\n  let hasWarned = false\n\n  return plugin({\n    name: 'declarativeWrapping',\n    fieldDefTypes: config.disable ? undefined : DeclarativeWrapping,\n    argTypeDefTypes: config.disable ? undefined : DeclarativeWrapping,\n    inputFieldDefTypes: config.disable ? undefined : DeclarativeWrapping,\n    description: 'Provides a declarative nullable/list API, available by default pre-0.19',\n    onAddOutputField(field) {\n      return {\n        ...field,\n        type: maybeWrapType(field, config),\n      }\n    },\n    onAddInputField(field) {\n      return {\n        ...field,\n        type: maybeWrapType(field, config),\n      }\n    },\n    onAddArg(arg) {\n      return {\n        ...arg,\n        type: maybeWrapType(arg, config),\n      }\n    },\n  })\n\n  function maybeWrapType(\n    field: NexusOutputFieldDef & DeclarativeWrappingApi,\n    config: DeclarativeWrappingPluginConfig\n  ): NexusOutputFieldDef['type']\n  function maybeWrapType(\n    field: NexusInputFieldDef & DeclarativeWrappingApi,\n    config: DeclarativeWrappingPluginConfig\n  ): NexusInputFieldDef['type']\n  function maybeWrapType(\n    field: NexusFinalArgConfig & DeclarativeWrappingApi,\n    config: DeclarativeWrappingPluginConfig\n  ): NexusFinalArgConfig['type']\n  function maybeWrapType(\n    field: (NexusOutputFieldDef | NexusInputFieldDef | NexusFinalArgConfig) & DeclarativeWrappingApi,\n    config: DeclarativeWrappingPluginConfig\n  ) {\n    if (field.list == null && field.nullable == null && field.required == null) {\n      return field.type\n    }\n    const used: string[] = []\n    if (field.list != null) {\n      used.push('list')\n    }\n    if (field.nullable != null) {\n      used.push('nullable')\n    }\n    if (field.required != null) {\n      used.push('required')\n    }\n    if (config.disable || config.shouldWarn) {\n      const d = field as NexusFinalArgConfig | NexusOutputFieldDef | NexusInputFieldDef\n      let location =\n        d.configFor === 'arg'\n          ? `'${d.parentType}.${d.fieldName}' field's '${d.argName}' argument`\n          : `'${d.parentType}.${d.type}' field`\n\n      if (config.disable) {\n        throw new Error(messages.removedDeclarativeWrapping(location, used))\n      } else {\n        if (hasWarned) {\n          console.warn(messages.removedDeclarativeWrappingShort(location, used))\n        } else {\n          console.warn(messages.removedDeclarativeWrapping(location, used))\n        }\n      }\n    }\n\n    if (\n      isNexusWrappingType(field.type) &&\n      (field.list != null || field.nullable != null || field.required != null)\n    ) {\n      let errorStr =\n        field.configFor === 'arg'\n          ? `the arg '${field.argName}' of the field '${field.parentType}.${field.fieldName}'.`\n          : `the field '${field.parentType}.${field.name}'.`\n      let usedProp = field.list != null ? 'list' : field.nullable != null ? 'nullable' : 'required'\n      throw new Error(\n        `[declarativeWrappingPlugin] It looks like you used \\`${usedProp}\\` and wrapped the type of ` +\n          errorStr +\n          ' You should only do one or the other'\n      )\n    }\n\n    let type = field.type\n    if (field.list === true) {\n      if (field.nullable === false || field.required === true) {\n        type = nonNull(type)\n      }\n      type = list(type)\n    } else if (Array.isArray(field.list)) {\n      for (const isNonNull of field.list) {\n        if (isNonNull === true) {\n          type = list(nonNull(type))\n        } else {\n          type = list(nullable(type))\n        }\n      }\n    }\n    /* istanbul ignore if */\n    if (field.required != null && field.nullable != null) {\n      let errorSuffix =\n        field.configFor === 'arg'\n          ? ` on ${field.parentType}.${field.fieldName} arg ${field.argName}`\n          : ` on ${field.parentType}.${field.name}`\n      throw new Error(`Cannot set both required & nullable wrapping modifiers on ${errorSuffix}`)\n    }\n    if (field.nullable === true || field.required === false) {\n      type = nullable(type)\n    } else if (field.nullable === false || field.required === true) {\n      type = nonNull(type)\n    }\n    return type\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3096, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/plugins/index.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/plugins/index.ts"],"sourcesContent":["export { connectionPlugin } from './connectionPlugin'\nexport * as connectionPluginCore from './connectionPlugin'\n\nexport { fieldAuthorizePlugin } from './fieldAuthorizePlugin'\nexport * as fieldAuthorizePluginCore from './fieldAuthorizePlugin'\n\nexport { nullabilityGuardPlugin } from './nullabilityGuardPlugin'\nexport * as nullabilityGuardPluginCore from './nullabilityGuardPlugin'\n\nexport { queryComplexityPlugin } from './queryComplexityPlugin'\nexport * as queryComplexityPluginCore from './queryComplexityPlugin'\n\nexport { declarativeWrappingPlugin } from './declarativeWrappingPlugin'\n"],"names":[],"mappings":";AAAA,OAAO,EAAE,gBAAgB,EAAE,MAAM,oBAAoB,CAAA;AAGrD,OAAO,EAAE,oBAAoB,EAAE,MAAM,wBAAwB,CAAA;AAG7D,OAAO,EAAE,sBAAsB,EAAE,MAAM,0BAA0B,CAAA;AAGjE,OAAO,EAAE,qBAAqB,EAAE,MAAM,yBAAyB,CAAA;AAG/D,OAAO,EAAE,yBAAyB,EAAE,MAAM,6BAA6B,CAAA"}},
    {"offset": {"line": 3119, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/definitions/enumType.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/definitions/enumType.ts"],"sourcesContent":["import { assertValidName, GraphQLEnumTypeConfig, GraphQLEnumValueConfig } from 'graphql'\nimport { arg, NexusArgDef, NexusAsArgConfig } from './args'\nimport { Maybe, NexusTypes, SourceTypingDef, withNexusSymbol } from './_types'\n\ntype TypeScriptEnumLike = {\n  [key: number]: string\n}\n\nexport interface EnumMemberInfo {\n  /** The external \"value\" of the enum as displayed in the SDL */\n  name: string\n  /** The internal representation of the enum */\n  value?: string | number | object | boolean\n  /** The description to annotate the GraphQL SDL */\n  description?: Maybe<string>\n  /**\n   * Info about a field deprecation. Formatted as a string and provided with the deprecated directive on\n   * field/enum types and as a comment on input fields.\n   */\n  deprecation?: Maybe<string> // | DeprecationInfo;\n  /**\n   * Custom extensions, as supported in graphql-js\n   *\n   * @see https://github.com/graphql/graphql-js/issues/1527\n   */\n  extensions?: GraphQLEnumValueConfig['extensions']\n}\n\nexport interface NexusEnumTypeConfig<TypeName extends string> {\n  name: TypeName\n  /** The description to annotate the GraphQL SDL */\n  description?: Maybe<string>\n  /** Source type information for this type */\n  sourceType?: SourceTypingDef\n  /** All members of the enum, either as an array of strings/definition objects, as an object, or as a TypeScript enum */\n  members:\n    | ReadonlyArray<string | EnumMemberInfo>\n    | Record<string, string | number | object | boolean>\n    | TypeScriptEnumLike\n  /**\n   * Custom extensions, as supported in graphql-js\n   *\n   * @see https://github.com/graphql/graphql-js/issues/1527\n   */\n  extensions?: GraphQLEnumTypeConfig['extensions']\n  /** Adds this type as a method on the Object/Interface definition blocks */\n  asNexusMethod?: string\n}\n\nexport class NexusEnumTypeDef<TypeName extends string> {\n  constructor(readonly name: TypeName, protected config: NexusEnumTypeConfig<string>) {\n    assertValidName(name)\n  }\n  get value() {\n    return this.config\n  }\n  /**\n   * Wraps the current enum as an argument, useful if you're defining the enumType inline for an individual field.\n   *\n   * @example\n   *   args: {\n   *     sort: enumType(config).asArg({ default: 'someValue' })\n   *   }\n   */\n  asArg(cfg?: NexusAsArgConfig<TypeName>): NexusArgDef<any> {\n    return arg({ ...cfg, type: this })\n  }\n}\nwithNexusSymbol(NexusEnumTypeDef, NexusTypes.Enum)\n\nexport function enumType<TypeName extends string>(config: NexusEnumTypeConfig<TypeName>) {\n  return new NexusEnumTypeDef(config.name, config)\n}\n"],"names":[],"mappings":";;;;;;AAAA,OAAO,EAAE,eAAe,EAAiD,MAAM,SAAS,CAAA;AACxF,OAAO,EAAE,GAAG,EAAiC,MAAM,QAAQ,CAAA;AAC3D,OAAO,EAAS,UAAU,EAAmB,eAAe,EAAE,MAAM,UAAU,CAAA;;;;AA+CxE,MAAO,gBAAgB;IAC3B,YAAqB,IAAc,EAAY,MAAmC,CAAA;QAA7D,IAAA,CAAA,IAAI,GAAJ,IAAI,CAAU;QAAY,IAAA,CAAA,MAAM,GAAN,MAAM,CAA6B;YAChF,kOAAe,EAAC,IAAI,CAAC,CAAA;IACvB,CAAC;IACD,IAAI,KAAK,GAAA;QACP,OAAO,IAAI,CAAC,MAAM,CAAA;IACpB,CAAC;IACD;;;;;;;OAOG,CACH,KAAK,CAAC,GAAgC,EAAA;QACpC,WAAO,yOAAG,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAM,GAAG,GAAA;YAAE,IAAI,EAAE,IAAI;QAAA,GAAG,CAAA;IACpC,CAAC;CACF;IACD,uPAAe,EAAC,gBAAgB,EAAE,kPAAU,CAAC,IAAI,CAAC,CAAA;AAE5C,SAAU,QAAQ,CAA0B,MAAqC;IACrF,OAAO,IAAI,gBAAgB,CAAC,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,CAAA;AAClD,CAAC"}},
    {"offset": {"line": 3161, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/definitions/inputObjectType.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/definitions/inputObjectType.ts"],"sourcesContent":["import { assertValidName, GraphQLInputObjectTypeConfig } from 'graphql'\nimport { arg, NexusArgDef, NexusAsArgConfig } from './args'\nimport type { InputDefinitionBlock } from './definitionBlocks'\nimport { Maybe, NexusTypes, NonNullConfig, withNexusSymbol } from './_types'\n\nexport type NexusInputObjectTypeConfig<TypeName extends string> = {\n  /** Name of the input object type */\n  name: TypeName\n  /** Definition block for the input type */\n  definition(t: InputDefinitionBlock<TypeName>): void\n  /** The description to annotate the GraphQL SDL */\n  description?: Maybe<string>\n  /**\n   * Configures the nullability for the type, check the documentation's \"Getting Started\" section to learn\n   * more about GraphQL Nexus's assumptions and configuration on nullability.\n   */\n  nonNullDefaults?: NonNullConfig\n  /**\n   * Custom extensions, as supported in graphql-js\n   *\n   * @see https://github.com/graphql/graphql-js/issues/1527\n   */\n  extensions?: GraphQLInputObjectTypeConfig['extensions']\n  /** Adds this type as a method on the Object/Interface definition blocks */\n  asNexusMethod?: string\n} & NexusGenPluginInputTypeConfig<TypeName>\n\nexport class NexusInputObjectTypeDef<TypeName extends string> {\n  constructor(readonly name: TypeName, protected config: NexusInputObjectTypeConfig<any>) {\n    assertValidName(name)\n  }\n  get value() {\n    return this.config\n  }\n  /**\n   * Shorthand for wrapping the current InputObject in an \"arg\", useful if you need to add a description.\n   *\n   * @example\n   *   inputObject(config).asArg({\n   *     description: 'Define sort the current field',\n   *   })\n   */\n  asArg(cfg?: NexusAsArgConfig<TypeName>): NexusArgDef<any> {\n    return arg({ ...cfg, type: this })\n  }\n}\nwithNexusSymbol(NexusInputObjectTypeDef, NexusTypes.InputObject)\n\nexport function inputObjectType<TypeName extends string>(config: NexusInputObjectTypeConfig<TypeName>) {\n  return new NexusInputObjectTypeDef(config.name, config)\n}\n"],"names":[],"mappings":";;;;;;AAAA,OAAO,EAAE,eAAe,EAAgC,MAAM,SAAS,CAAA;AACvE,OAAO,EAAE,GAAG,EAAiC,MAAM,QAAQ,CAAA;AAE3D,OAAO,EAAS,UAAU,EAAiB,eAAe,EAAE,MAAM,UAAU,CAAA;;;;AAwBtE,MAAO,uBAAuB;IAClC,YAAqB,IAAc,EAAY,MAAuC,CAAA;QAAjE,IAAA,CAAA,IAAI,GAAJ,IAAI,CAAU;QAAY,IAAA,CAAA,MAAM,GAAN,MAAM,CAAiC;YACpF,kOAAe,EAAC,IAAI,CAAC,CAAA;IACvB,CAAC;IACD,IAAI,KAAK,GAAA;QACP,OAAO,IAAI,CAAC,MAAM,CAAA;IACpB,CAAC;IACD;;;;;;;OAOG,CACH,KAAK,CAAC,GAAgC,EAAA;QACpC,WAAO,yOAAG,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAM,GAAG,GAAA;YAAE,IAAI,EAAE,IAAI;QAAA,GAAG,CAAA;IACpC,CAAC;CACF;IACD,uPAAe,EAAC,uBAAuB,EAAE,kPAAU,CAAC,WAAW,CAAC,CAAA;AAE1D,SAAU,eAAe,CAA0B,MAA4C;IACnG,OAAO,IAAI,uBAAuB,CAAC,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,CAAA;AACzD,CAAC"}},
    {"offset": {"line": 3203, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/definitions/scalarType.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/definitions/scalarType.ts"],"sourcesContent":["import { assertValidName, GraphQLNamedType, GraphQLScalarTypeConfig } from 'graphql'\nimport type { AllNexusInputTypeDefs, AllNexusOutputTypeDefs } from '../core'\nimport { decorateType } from './decorateType'\nimport { GraphQLNamedOutputType, Maybe, NexusTypes, SourceTypingDef, withNexusSymbol } from './_types'\n\nexport interface ScalarBase\n  extends Pick<\n    GraphQLScalarTypeConfig<any, any>,\n    'description' | 'serialize' | 'parseValue' | 'parseLiteral'\n  > {}\n\nexport interface ScalarConfig {\n  /** Any deprecation info for this scalar type */\n  deprecation?: Maybe<string> // | DeprecationInfo;\n  /** Adds this type as a method on the Object/Interface definition blocks */\n  asNexusMethod?: string\n  /** Source type information for this type */\n  sourceType?: SourceTypingDef\n  /**\n   * Custom extensions, as supported in graphql-js\n   *\n   * @see https://github.com/graphql/graphql-js/issues/1527\n   */\n  extensions?: GraphQLScalarTypeConfig<any, any>['extensions']\n}\n\nexport interface NexusScalarTypeConfig<T extends string> extends ScalarBase, ScalarConfig {\n  /** The name of the scalar type */\n  name: T\n}\n\nexport class NexusScalarTypeDef<TypeName extends string> {\n  constructor(readonly name: TypeName, protected config: NexusScalarTypeConfig<string>) {\n    assertValidName(name)\n  }\n  get value() {\n    return this.config\n  }\n}\n\nwithNexusSymbol(NexusScalarTypeDef, NexusTypes.Scalar)\n\nexport function scalarType<TypeName extends string>(options: NexusScalarTypeConfig<TypeName>) {\n  return new NexusScalarTypeDef(options.name, options)\n}\n\nexport function asNexusMethod<T extends GraphQLNamedType>(\n  namedType: T,\n  methodName: string,\n  sourceType?: SourceTypingDef\n): T extends GraphQLNamedOutputType ? AllNexusOutputTypeDefs : AllNexusInputTypeDefs {\n  return decorateType(namedType, {\n    asNexusMethod: methodName,\n    sourceType,\n  }) as any\n}\n"],"names":[],"mappings":";;;;;;;;AAAA,OAAO,EAAE,eAAe,EAA6C,MAAM,SAAS,CAAA;AAEpF,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAA;AAC7C,OAAO,EAAiC,UAAU,EAAmB,eAAe,EAAE,MAAM,UAAU,CAAA;;;;AA4BhG,MAAO,kBAAkB;IAC7B,YAAqB,IAAc,EAAY,MAAqC,CAAA;QAA/D,IAAA,CAAA,IAAI,GAAJ,IAAI,CAAU;QAAY,IAAA,CAAA,MAAM,GAAN,MAAM,CAA+B;YAClF,kOAAe,EAAC,IAAI,CAAC,CAAA;IACvB,CAAC;IACD,IAAI,KAAK,GAAA;QACP,OAAO,IAAI,CAAC,MAAM,CAAA;IACpB,CAAC;CACF;IAED,uPAAe,EAAC,kBAAkB,EAAE,kPAAU,CAAC,MAAM,CAAC,CAAA;AAEhD,SAAU,UAAU,CAA0B,OAAwC;IAC1F,OAAO,IAAI,kBAAkB,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,CAAA;AACtD,CAAC;AAEK,SAAU,aAAa,CAC3B,SAAY,EACZ,UAAkB,EAClB,UAA4B;IAE5B,WAAO,0PAAY,EAAC,SAAS,EAAE;QAC7B,aAAa,EAAE,UAAU;QACzB,UAAU;KACX,CAAQ,CAAA;AACX,CAAC"}},
    {"offset": {"line": 3241, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/rebuildType.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/rebuildType.ts"],"sourcesContent":["import {\n  GraphQLEnumType,\n  GraphQLFieldConfigArgumentMap,\n  GraphQLFieldConfigMap,\n  GraphQLInputFieldConfigMap,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLNamedType,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLUnionType,\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n  defaultTypeResolver,\n} from 'graphql'\nimport type { MergeSchemaConfig } from './builder'\nimport { arg, ArgsRecord } from './definitions/args'\nimport type { InputDefinitionBlock } from './definitions/definitionBlocks'\nimport { enumType } from './definitions/enumType'\nimport { inputObjectType } from './definitions/inputObjectType'\nimport { InterfaceDefinitionBlock, interfaceType } from './definitions/interfaceType'\nimport { ObjectDefinitionBlock, objectType } from './definitions/objectType'\nimport { scalarType } from './definitions/scalarType'\nimport { unionType } from './definitions/unionType'\nimport { AllNexusArgsDefs, applyNexusWrapping, unwrapGraphQLDef } from './definitions/wrapping'\nimport type { Maybe, SourceTypingDef } from './definitions/_types'\nimport type { GetGen } from './typegenTypeHelpers'\nimport { graphql15InterfaceConfig, Unreachable } from './utils'\n\nexport interface RebuildConfig extends Omit<MergeSchemaConfig, 'schema'> {\n  captureLeafType?: (type: GraphQLNamedType) => void\n  asNexusMethod?: string\n  sourceType?: SourceTypingDef\n}\n\nexport function rebuildNamedType(type: GraphQLNamedType, config: RebuildConfig) {\n  if (isObjectType(type)) {\n    return rebuildObjectType(type, config)\n  } else if (isInputObjectType(type)) {\n    return rebuildInputObjectType(type, config)\n  } else if (isInterfaceType(type)) {\n    return rebuildInterfaceType(type, config)\n  } else if (isUnionType(type)) {\n    return rebuildUnionType(type, config)\n  } else if (isScalarType(type)) {\n    return rebuildScalarType(type, config)\n  } else if (isEnumType(type)) {\n    return rebuildEnumType(type, config)\n  }\n  throw new Unreachable(type)\n}\n\nexport function rebuildInputObjectType(type: GraphQLInputObjectType, config: RebuildConfig) {\n  const { name, fields, description, extensions } = type.toConfig()\n  return inputObjectType({\n    name,\n    description,\n    definition: (t) => {\n      rebuildInputDefinition(name, t, fields, config)\n    },\n    extensions,\n    nonNullDefaults: {\n      output: false,\n      input: false,\n    },\n  })\n}\n\nexport function rebuildUnionType(type: GraphQLUnionType, config: RebuildConfig) {\n  const { name, types, description, resolveType, extensions } = type.toConfig()\n  return unionType({\n    name,\n    description,\n    // @ts-ignore - todo, see why this is the case\n    resolveType: resolveType ?? defaultTypeResolver,\n    definition(t) {\n      t.members(\n        ...types.map((o) => {\n          config.captureLeafType?.(o)\n          return o.name as GetGen<'objectNames'>\n        })\n      )\n    },\n    extensions,\n  })\n}\n\nexport function rebuildScalarType(type: GraphQLScalarType, config: RebuildConfig) {\n  return scalarType({\n    ...type.toConfig(),\n    sourceType: config.sourceType,\n    asNexusMethod: config.asNexusMethod,\n  })\n}\n\nexport function rebuildEnumType(type: GraphQLEnumType, { sourceType, asNexusMethod }: RebuildConfig) {\n  const { name, values, ...config } = type.toConfig()\n  return enumType({\n    name,\n    ...config,\n    members: Object.entries(values).map(([valueName, config]) => {\n      return {\n        name: valueName,\n        deprecation: config.deprecationReason,\n        ...config,\n      }\n    }),\n    sourceType,\n    asNexusMethod,\n  })\n}\n\nexport function rebuildInterfaceType(type: GraphQLInterfaceType, config: RebuildConfig) {\n  const { name, fields, description, interfaces, extensions, resolveType } = graphql15InterfaceConfig(\n    type.toConfig()\n  )\n  return interfaceType({\n    name,\n    description,\n    // @ts-ignore - todo, see why this is the case\n    resolveType: resolveType ?? defaultTypeResolver,\n    definition: (t) => {\n      rebuildOutputDefinition(name, t, fields, interfaces, config)\n    },\n    nonNullDefaults: {\n      output: false,\n      input: false,\n    },\n    extensions,\n    sourceType: config.sourceType,\n    asNexusMethod: config.asNexusMethod,\n  })\n}\n\nexport function rebuildObjectType(type: GraphQLObjectType, config: RebuildConfig) {\n  const { name, fields, interfaces, description, extensions } = type.toConfig()\n  return objectType({\n    name,\n    description,\n    definition: (t) => {\n      rebuildOutputDefinition(name, t, fields, interfaces, config)\n    },\n    nonNullDefaults: {\n      output: false,\n      input: false,\n    },\n    extensions,\n    sourceType: config.sourceType,\n    asNexusMethod: config.asNexusMethod,\n  })\n}\n\nexport function rebuildOutputDefinition(\n  typeName: string,\n  t: ObjectDefinitionBlock<string> | InterfaceDefinitionBlock<string>,\n  fields: GraphQLFieldConfigMap<any, any>,\n  interfaces: ReadonlyArray<GraphQLInterfaceType>,\n  config: RebuildConfig\n) {\n  t.implements(\n    ...interfaces.map((i) => {\n      config.captureLeafType?.(i)\n      return i.name as GetGen<'interfaceNames'>\n    })\n  )\n  for (const [fieldName, fieldConfig] of Object.entries(fields)) {\n    if (config.skipFields?.[typeName] && config.skipFields?.[typeName].includes(fieldName)) {\n      continue\n    }\n    const { namedType, wrapping } = unwrapGraphQLDef(fieldConfig.type)\n    config.captureLeafType?.(namedType)\n    t.field(fieldName, {\n      type: applyNexusWrapping(namedType.name, wrapping),\n      description: fieldConfig.description,\n      deprecation: fieldConfig.deprecationReason,\n      extensions: fieldConfig.extensions,\n      args: rebuildArgs(typeName, fieldName, fieldConfig.args ?? {}, config),\n      resolve: fieldConfig.resolve,\n    })\n  }\n}\n\nexport function rebuildInputDefinition(\n  typeName: string,\n  t: InputDefinitionBlock<string>,\n  fields: GraphQLInputFieldConfigMap,\n  config: RebuildConfig\n) {\n  for (const [fieldName, fieldConfig] of Object.entries(fields)) {\n    if (config.skipFields?.[typeName] && config.skipFields?.[typeName].includes(fieldName)) {\n      continue\n    }\n    const { namedType, wrapping } = unwrapGraphQLDef(fieldConfig.type)\n    config.captureLeafType?.(namedType)\n    t.field(fieldName, {\n      type: applyNexusWrapping(namedType.name, wrapping),\n      description: fieldConfig.description,\n      default: fieldConfig.defaultValue,\n      extensions: fieldConfig.extensions,\n    })\n  }\n}\n\nexport function rebuildArgs(\n  typeName: string,\n  fieldName: string,\n  argMap: Maybe<GraphQLFieldConfigArgumentMap>,\n  config: RebuildConfig\n): Maybe<ArgsRecord> {\n  if (!argMap) {\n    return null\n  }\n  const rebuiltArgs: Record<string, AllNexusArgsDefs> = {}\n  for (const [argName, argConfig] of Object.entries(argMap)) {\n    if (config.skipArgs?.[typeName]?.[fieldName]) {\n      continue\n    }\n    const { namedType, wrapping } = unwrapGraphQLDef(argConfig.type)\n    config.captureLeafType?.(namedType)\n    rebuiltArgs[argName] = arg({\n      type: applyNexusWrapping(namedType.name, wrapping),\n      default: argConfig.defaultValue,\n      description: argConfig.description,\n      extensions: argConfig.extensions,\n    })\n  }\n  return rebuiltArgs\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3458, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/builder.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/builder.ts"],"sourcesContent":["import {\n  assertValidName,\n  defaultFieldResolver,\n  GraphQLBoolean,\n  GraphQLEnumType,\n  GraphQLEnumValueConfigMap,\n  GraphQLFieldConfig,\n  GraphQLFieldConfigArgumentMap,\n  GraphQLFieldConfigMap,\n  GraphQLFieldResolver,\n  GraphQLFloat,\n  GraphQLID,\n  GraphQLInputFieldConfig,\n  GraphQLInputFieldConfigMap,\n  GraphQLInputObjectType,\n  GraphQLInputType,\n  GraphQLInt,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLNamedType,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLOutputType,\n  GraphQLScalarType,\n  GraphQLSchema,\n  GraphQLSchemaConfig,\n  GraphQLString,\n  GraphQLType,\n  GraphQLUnionType,\n  isInputObjectType,\n  isInputType,\n  isInterfaceType,\n  isLeafType,\n  isNamedType,\n  isObjectType,\n  isOutputType,\n  isSchema,\n  isWrappingType,\n  printSchema,\n} from 'graphql'\nimport type { ArgsRecord, NexusFinalArgConfig } from './definitions/args'\nimport {\n  InputDefinitionBlock,\n  NexusInputFieldDef,\n  NexusOutputFieldConfig,\n  NexusOutputFieldDef,\n  OutputDefinitionBlock,\n} from './definitions/definitionBlocks'\nimport type { NexusEnumTypeConfig } from './definitions/enumType'\nimport type { NexusExtendInputTypeConfig, NexusExtendInputTypeDef } from './definitions/extendInputType'\nimport type { NexusExtendTypeConfig, NexusExtendTypeDef } from './definitions/extendType'\nimport type { NexusInputObjectTypeConfig } from './definitions/inputObjectType'\nimport {\n  FieldModificationDef,\n  Implemented,\n  InterfaceDefinitionBlock,\n  NexusInterfaceTypeConfig,\n  NexusInterfaceTypeDef,\n} from './definitions/interfaceType'\nimport { NexusObjectTypeConfig, NexusObjectTypeDef, ObjectDefinitionBlock } from './definitions/objectType'\nimport type { NexusScalarTypeConfig } from './definitions/scalarType'\nimport { NexusUnionTypeConfig, UnionDefinitionBlock, UnionMembers } from './definitions/unionType'\nimport {\n  AllNexusArgsDefs,\n  AllNexusNamedInputTypeDefs,\n  AllNexusNamedOutputTypeDefs,\n  AllNexusNamedTypeDefs,\n  AllNexusOutputTypeDefs,\n  finalizeWrapping,\n  isNexusDynamicInputMethod,\n  isNexusDynamicOutputMethod,\n  isNexusDynamicOutputProperty,\n  isNexusEnumTypeDef,\n  isNexusExtendInputTypeDef,\n  isNexusExtendTypeDef,\n  isNexusInputObjectTypeDef,\n  isNexusInterfaceTypeDef,\n  isNexusNamedInputTypeDef,\n  isNexusNamedOuputTypeDef,\n  isNexusNamedTypeDef,\n  isNexusObjectTypeDef,\n  isNexusPlugin,\n  isNexusScalarTypeDef,\n  isNexusUnionTypeDef,\n  isNexusWrappingType,\n  NexusFinalWrapKind,\n  NexusWrapKind,\n  normalizeArgWrapping,\n  rewrapAsGraphQLType,\n  unwrapGraphQLDef,\n  unwrapNexusDef,\n} from './definitions/wrapping'\nimport type {\n  MissingType,\n  NexusFeaturesInput,\n  NexusGraphQLFieldConfig,\n  NexusGraphQLInputObjectTypeConfig,\n  NexusGraphQLInterfaceTypeConfig,\n  NexusGraphQLObjectTypeConfig,\n  NexusGraphQLSchema,\n  NonNullConfig,\n  SourceTypings,\n  TypingImport,\n} from './definitions/_types'\nimport type { DynamicInputMethodDef, DynamicOutputMethodDef } from './dynamicMethod'\nimport type { DynamicOutputPropertyDef } from './dynamicProperty'\nimport {\n  hasNexusExtension,\n  NexusFieldExtension,\n  NexusInputObjectTypeExtension,\n  NexusInterfaceTypeExtension,\n  NexusObjectTypeExtension,\n  NexusSchemaExtension,\n} from './extensions'\nimport { messages } from './messages'\nimport {\n  composeMiddlewareFns,\n  CreateFieldResolverInfo,\n  MiddlewareFn,\n  NexusPlugin,\n  PluginConfig,\n} from './plugin'\nimport { declarativeWrappingPlugin } from './plugins'\nimport { fieldAuthorizePlugin } from './plugins/fieldAuthorizePlugin'\nimport type { SourceTypesConfigOptions } from './typegenAutoConfig'\nimport type { TypegenFormatFn } from './typegenFormatPrettier'\nimport type { AbstractTypeResolver, GetGen } from './typegenTypeHelpers'\nimport type { RequiredDeeply } from './typeHelpersInternal'\nimport {\n  casesHandled,\n  consoleWarn,\n  eachObj,\n  getArgNamedType,\n  getNexusNamedType,\n  graphql15InterfaceType,\n  invariantGuard,\n  isArray,\n  isObject,\n  objValues,\n  UNKNOWN_TYPE_SCALAR,\n} from './utils'\nimport {\n  NEXUS_BUILD,\n  isNexusMetaBuild,\n  isNexusMeta,\n  isNexusMetaType,\n  NexusMeta,\n  resolveNexusMetaType,\n} from './definitions/nexusMeta'\nimport { rebuildNamedType, RebuildConfig } from './rebuildType'\n\ntype NexusShapedOutput = {\n  name: string\n  definition: (t: ObjectDefinitionBlock<string>) => void\n}\n\ntype NexusShapedInput = {\n  name: string\n  definition: (t: InputDefinitionBlock<string>) => void\n}\n\nconst SCALARS: Record<string, GraphQLScalarType> = {\n  String: GraphQLString,\n  Int: GraphQLInt,\n  Float: GraphQLFloat,\n  ID: GraphQLID,\n  Boolean: GraphQLBoolean,\n}\n\ntype PossibleOutputType =\n  | string\n  | AllNexusNamedOutputTypeDefs\n  | Exclude<GraphQLOutputType, GraphQLNonNull<any> | GraphQLList<any>>\n\ntype PossibleInputType = string | AllNexusNamedInputTypeDefs | GraphQLType\n\nexport interface ConfiguredTypegen {\n  /** Path for the generated type defs */\n  outputPath: string\n  /**\n   * Determine the path the \"globals\" are output, useful when you have a monorepo setup and need to isolate\n   * the globals from the rest of the types in order to have multiple schemas/ts projects\n   */\n  globalsPath?: string\n  /**\n   * If globalsPath is defined, these headers are added to the \"globals\" generated file, rather than the\n   * typegen generated file\n   */\n  globalsHeaders?: string[]\n  /**\n   * If \"true\", declares dedicated interfaces for any inputs / args\n   *\n   * @default false\n   */\n  declareInputs?: boolean\n}\n\nexport interface MergeSchemaConfig {\n  /**\n   * GraphQL Schema to merge into the Nexus type definitions.\n   *\n   * We unwrap each type, preserve the \"nullable/nonNull\" status of any fields & arguments, and then combine\n   * with the local Nexus GraphQL types.\n   *\n   * If you have multiple schemas\n   */\n  schema: GraphQLSchema\n  /**\n   * If we want to \"merge\" specific types, provide a list of the types you wish to merge here.\n   *\n   * @default 'Query', 'Mutation'\n   */\n  mergeTypes?: string[] | true\n  /**\n   * If there are types that we don't want to include from the external schema in our final Nexus generated\n   * schema, provide them here.\n   */\n  skipTypes?: string[]\n  /**\n   * If there are certain \"fields\" that we want to skip, we can specify the fields here and we'll ensure they\n   * don't get merged into the schema\n   */\n  skipFields?: Record<string, string[]>\n  /**\n   * If there are certain arguments for any type fields that we want to skip, we can specify the fields here &\n   * ensure they don't get merged into the final schema.\n   *\n   * @example\n   *   skipArgs: {\n   *     Mutation: {\n   *       createAccount: ['internalId']\n   *     }\n   *   }\n   */\n  skipArgs?: Record<string, Record<string, string[]>>\n}\n\nexport interface BuilderConfigInput {\n  /**\n   * If we have an external schema that we want to \"merge into\" our local Nexus schema definitions, we can\n   * configure it here.\n   *\n   * If you have more than one schema that needs merging, you can look into using graphql-tools to pre-merge\n   * into a single schema: https://www.graphql-tools.com/docs/schema-merging\n   */\n  mergeSchema?: MergeSchemaConfig\n  /**\n   * Generated artifact settings. Set to false to disable all. Set to true to enable all and use default\n   * paths. Leave undefined for default behaviour of each artifact.\n   */\n  outputs?:\n    | boolean\n    | {\n        /**\n         * TypeScript declaration file generation settings. This file contains types reflected off your source\n         * code. It is how Nexus imbues dynamic code with static guarantees.\n         *\n         * Defaults to being enabled when `process.env.NODE_ENV !== \"production\"`. Set to true to enable and\n         * emit into default path (see below). Set to false to disable. Set to a string to specify absolute path.\n         *\n         * The default path is node_modules/@types/nexus-typegen/index.d.ts. This is chosen because TypeScript\n         * will pick it up without any configuration needed by you. For more details about the @types system\n         * refer to https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#types-typeroots-and-types\n         */\n        typegen?: boolean | string | ConfiguredTypegen\n        /**\n         * GraphQL SDL file generation toggle and location.\n         *\n         * Set to a string to enable and output to an absolute path. Set to true to enable at default path\n         * (schema.graphql in the current working directory) Set to false to disable\n         *\n         * Defaults to true in development and false otherwise.\n         *\n         * This file is not necessary but may be nice for teams wishing to review SDL in pull-requests or just\n         * generally transitioning from a schema-first workflow.\n         */\n        schema?: boolean | string\n      }\n  /**\n   * Whether the schema & types are generated when the server starts. Default is !process.env.NODE_ENV ||\n   * process.env.NODE_ENV === \"development\"\n   */\n  shouldGenerateArtifacts?: boolean\n  /** Register the Source Types */\n  sourceTypes?: SourceTypesConfigOptions\n  /**\n   * Adjust the Prettier options used while running prettier over the generated output.\n   *\n   * Can be an absolute path to a Prettier config file like .prettierrc or package.json with \"prettier\" field,\n   * or an object of Prettier options.\n   *\n   * If provided, you must have prettier available as an importable dep in your project.\n   */\n  prettierConfig?: string | object\n  /**\n   * Manually apply a formatter to the generated content before saving, see the `prettierConfig` option if you\n   * want to use Prettier.\n   */\n  formatTypegen?: TypegenFormatFn\n  /**\n   * Configures the default \"nonNullDefaults\" for the entire schema the type. Read more about how nexus\n   * handles nullability\n   */\n  nonNullDefaults?: NonNullConfig\n  /** List of plugins to apply to Nexus, with before/after hooks executed first to last: before -> resolve -> after */\n  plugins?: NexusPlugin[]\n  /** Provide if you wish to customize the behavior of the schema printing. Otherwise, uses `printSchema` from graphql-js */\n  customPrintSchemaFn?: typeof printSchema\n  /** Customize and toggle on or off various features of Nexus. */\n  features?: NexusFeaturesInput\n  /**\n   * Path to the module where your context type is exported\n   *\n   * @example\n   *   contextType: { module: path.join(__dirname, 'context.ts'), export: 'MyContextType' }\n   */\n  contextType?: TypingImport\n  /**\n   * If we wish to override the \"Root\" type for the schema, we can do so by specifying the rootTypes option,\n   * which will replace the default roots of Query / Mutation / Subscription\n   */\n  schemaRoots?: {\n    query?: GetGen<'allOutputTypes', string> | AllNexusOutputTypeDefs\n    mutation?: GetGen<'allOutputTypes', string> | AllNexusOutputTypeDefs\n    subscription?: GetGen<'allOutputTypes', string> | AllNexusOutputTypeDefs\n  }\n}\n\nexport interface BuilderConfig extends Omit<BuilderConfigInput, 'nonNullDefaults' | 'features' | 'plugins'> {\n  nonNullDefaults: RequiredDeeply<BuilderConfigInput['nonNullDefaults']>\n  features: RequiredDeeply<BuilderConfigInput['features']>\n  plugins: RequiredDeeply<BuilderConfigInput['plugins']>\n}\n\nexport type SchemaConfig = BuilderConfigInput & {\n  /**\n   * All of the GraphQL types. This is an any for simplicity of developer experience, if it's an object we get\n   * the values, if it's an array we flatten out the valid types, ignoring invalid ones.\n   */\n  types: any\n  /**\n   * Whether we should process.exit after the artifacts are generated. Useful if you wish to explicitly\n   * generate the test artifacts at a certain stage in a startup or build process.\n   *\n   * @default false\n   */\n  shouldExitAfterGenerateArtifacts?: boolean\n  /**\n   * Custom extensions, as [supported in\n   * graphql-js](https://github.com/graphql/graphql-js/blob/master/src/type/__tests__/extensions-test.js)\n   */\n  extensions?: GraphQLSchemaConfig['extensions']\n} & NexusGenPluginSchemaConfig\n\nexport interface TypegenInfo {\n  /** Headers attached to the generate type output */\n  headers: string[]\n  /** All imports for the source types / context */\n  imports: string[]\n  /** A map of all GraphQL types and what TypeScript types they should be represented by. */\n  sourceTypeMap: { [K in GetGen<'objectNames'>]?: string }\n  /** Info about where to import the context from */\n  contextTypeImport: TypingImport | undefined\n  /**\n   * The path to the nexus package for typegen.\n   *\n   * This setting is only necessary when nexus is being wrapped by another library/framework such that `nexus`\n   * is not expected to be a direct dependency at the application level.\n   */\n  nexusSchemaImportId?: string\n}\n\nexport type TypeToWalk =\n  | { type: 'input'; value: NexusShapedInput }\n  | { type: 'object'; value: NexusShapedOutput }\n  | { type: 'interface'; value: NexusInterfaceTypeConfig<any> }\n\nexport type DynamicInputFields = Record<string, DynamicInputMethodDef<string> | string>\n\nexport type DynamicOutputFields = Record<string, DynamicOutputMethodDef<string> | string>\n\nexport type DynamicOutputProperties = Record<string, DynamicOutputPropertyDef<string>>\n\nexport type TypeDef =\n  | GraphQLNamedType\n  | AllNexusNamedTypeDefs\n  | NexusExtendInputTypeDef<string>\n  | NexusExtendTypeDef<string>\n\nexport type DynamicBlockDef =\n  | DynamicInputMethodDef<string>\n  | DynamicOutputMethodDef<string>\n  | DynamicOutputPropertyDef<string>\n\nexport type NexusAcceptedTypeDef = TypeDef | DynamicBlockDef | NexusMeta\n\nexport type PluginBuilderLens = {\n  hasType: SchemaBuilder['hasType']\n  addType: SchemaBuilder['addType']\n  setConfigOption: SchemaBuilder['setConfigOption']\n  hasConfigOption: SchemaBuilder['hasConfigOption']\n  getConfigOption: SchemaBuilder['getConfigOption']\n}\n\n/**\n * Builds all of the types, properly accounts for any using \"mix\". Since the enum types are resolved\n * synchronously, these need to guard for circular references at this step, while fields will guard for it\n * during lazy evaluation.\n */\nexport class SchemaBuilder {\n  /** All objects containing a NEXUS_BUILD / NEXUS_TYPE symbol */\n  private nexusMetaObjects = new Set()\n  /** Used to check for circular references. */\n  private buildingTypes = new Set()\n  /** The \"final type\" map contains all types as they are built. */\n  private finalTypeMap: Record<string, GraphQLNamedType> = {}\n  /**\n   * The \"defined type\" map keeps track of all of the types that were defined directly as `GraphQL*Type`\n   * objects, so we don't accidentally overwrite any.\n   */\n  private definedTypeMap: Record<string, GraphQLNamedType> = {}\n  /**\n   * The \"pending type\" map keeps track of all types that were defined w/ GraphQL Nexus and haven't been\n   * processed into concrete types yet.\n   */\n  private pendingTypeMap: Record<string, AllNexusNamedTypeDefs | null> = {}\n  /** All \"extensions\" to types (adding fields on types from many locations) */\n  private typeExtendMap: Record<string, NexusExtendTypeConfig<string>[] | null> = {}\n  /** All \"extensions\" to input types (adding fields on types from many locations) */\n  private inputTypeExtendMap: Record<string, NexusExtendInputTypeConfig<string>[] | null> = {}\n  /**\n   * When we encounter \"named\" types from graphql-js, we keep them separate from Nexus definitions. This way\n   * we can have Nexus definitions take precedence without worrying about conflicts, particularly when we're\n   * looking to override behavior from inherited types.\n   */\n  private graphqlNamedTypeMap: Record<string, AllNexusNamedTypeDefs> = {}\n\n  /**\n   * If we're merging against a remote schema, the types from the schema are kept here, for fallbacks /\n   * merging when we're building the actual Schema\n   */\n  private graphqlMergeSchemaMap: Record<string, AllNexusNamedTypeDefs> = {}\n\n  private dynamicInputFields: DynamicInputFields = {}\n  private dynamicOutputFields: DynamicOutputFields = {}\n  private dynamicOutputProperties: DynamicOutputProperties = {}\n  private plugins: NexusPlugin[] = []\n\n  /** All types that need to be traversed for children types */\n  private typesToWalk: TypeToWalk[] = []\n\n  /** Root type mapping information annotated on the type definitions */\n  private sourceTypings: SourceTypings = {}\n\n  /** Array of missing types */\n  private missingTypes: Record<string, MissingType> = {}\n\n  /** Methods we are able to access to read/modify builder state from plugins */\n  private builderLens: PluginBuilderLens\n\n  /** Created just before types are walked, this keeps track of all of the resolvers */\n  private onMissingTypeFns: Exclude<PluginConfig['onMissingType'], undefined>[] = []\n\n  /** Executed just before types are walked */\n  private onBeforeBuildFns: Exclude<PluginConfig['onBeforeBuild'], undefined>[] = []\n\n  /** Executed as the field resolvers are included on the field */\n  private onCreateResolverFns: Exclude<PluginConfig['onCreateFieldResolver'], undefined>[] = []\n\n  /** Executed as the field \"subscribe\" fields are included on the schema */\n  private onCreateSubscribeFns: Exclude<PluginConfig['onCreateFieldSubscribe'], undefined>[] = []\n\n  /** Executed after the schema is constructed, for any final verification */\n  private onAfterBuildFns: Exclude<PluginConfig['onAfterBuild'], undefined>[] = []\n\n  /** Executed after the object is defined, allowing us to add additional fields to the object */\n  private onObjectDefinitionFns: Exclude<PluginConfig['onObjectDefinition'], undefined>[] = []\n\n  /** Executed after the object is defined, allowing us to add additional fields to the object */\n  private onInputObjectDefinitionFns: Exclude<PluginConfig['onInputObjectDefinition'], undefined>[] = []\n\n  /** Called immediately after the field is defined, allows for using metadata to define the shape of the field. */\n  private onAddArgFns: Exclude<PluginConfig['onAddArg'], undefined>[] = []\n\n  /** Called immediately after the field is defined, allows for using metadata to define the shape of the field. */\n  private onAddOutputFieldFns: Exclude<PluginConfig['onAddOutputField'], undefined>[] = []\n\n  /** Called immediately after the field is defined, allows for using metadata to define the shape of the field. */\n  private onAddInputFieldFns: Exclude<PluginConfig['onAddInputField'], undefined>[] = []\n\n  /** The `schemaExtension` is created just after the types are walked, but before the fields are materialized. */\n  private _schemaExtension?: NexusSchemaExtension\n\n  private config: BuilderConfig\n\n  private get schemaExtension() {\n    /* istanbul ignore next */\n    if (!this._schemaExtension) {\n      throw new Error('Cannot reference schemaExtension before it is created')\n    }\n    return this._schemaExtension\n  }\n\n  constructor(config: BuilderConfigInput) {\n    this.config = setConfigDefaults(config)\n    /** This array of plugin is used to keep retro-compatibility w/ older versions of nexus */\n    this.plugins = this.config.plugins.length > 0 ? this.config.plugins : [fieldAuthorizePlugin()]\n\n    if (!this.plugins.find((f) => f.config.name === 'declarativeWrapping')) {\n      this.plugins.push(declarativeWrappingPlugin({ disable: true }))\n    }\n\n    this.builderLens = Object.freeze({\n      hasType: this.hasType,\n      addType: this.addType,\n      setConfigOption: this.setConfigOption,\n      hasConfigOption: this.hasConfigOption,\n      getConfigOption: this.getConfigOption,\n    })\n\n    if (config.mergeSchema) {\n      this.graphqlMergeSchemaMap = this.handleMergeSchema(config.mergeSchema)\n    }\n  }\n\n  setConfigOption = <K extends keyof BuilderConfigInput>(key: K, value: BuilderConfigInput[K]) => {\n    this.config = {\n      ...this.config,\n      [key]: value,\n    }\n  }\n\n  hasConfigOption = (key: keyof BuilderConfigInput): boolean => {\n    return this.config.hasOwnProperty(key)\n  }\n\n  getConfigOption = <K extends keyof BuilderConfigInput>(key: K): BuilderConfigInput[K] => {\n    return this.config[key]\n  }\n\n  hasType = (typeName: string): boolean => {\n    return Boolean(\n      this.pendingTypeMap[typeName] ||\n        this.finalTypeMap[typeName] ||\n        this.graphqlNamedTypeMap[typeName] ||\n        this.graphqlMergeSchemaMap[typeName]\n    )\n  }\n\n  /**\n   * Add type takes a Nexus type, or a GraphQL type and pulls it into an internal \"type registry\". It also\n   * does an initial pass on any types that are referenced on the \"types\" field and pulls those in too, so\n   * you can define types anonymously, without exporting them.\n   */\n  private addType = (typeDef: NexusAcceptedTypeDef) => {\n    if (isNexusDynamicInputMethod(typeDef)) {\n      this.dynamicInputFields[typeDef.name] = typeDef\n      return\n    }\n    if (isNexusDynamicOutputMethod(typeDef)) {\n      this.dynamicOutputFields[typeDef.name] = typeDef\n      return\n    }\n    if (isNexusDynamicOutputProperty(typeDef)) {\n      this.dynamicOutputProperties[typeDef.name] = typeDef\n      return\n    }\n\n    if (isNexusMeta(typeDef)) {\n      this.addToNexusMeta(typeDef)\n      return\n    }\n\n    // Don't worry about internal types.\n    if (typeDef.name?.startsWith('__')) {\n      return\n    }\n\n    if (isNexusExtendTypeDef(typeDef)) {\n      const typeExtensions = (this.typeExtendMap[typeDef.name] = this.typeExtendMap[typeDef.name] || [])\n      typeExtensions.push(typeDef.value)\n      this.typesToWalk.push({ type: 'object', value: typeDef.value })\n      return\n    }\n\n    if (isNexusExtendInputTypeDef(typeDef)) {\n      const typeExtensions = (this.inputTypeExtendMap[typeDef.name] =\n        this.inputTypeExtendMap[typeDef.name] || [])\n      typeExtensions.push(typeDef.value)\n      this.typesToWalk.push({ type: 'input', value: typeDef.value })\n      return\n    }\n\n    // Check the \"defined\" type map for existing Nexus types. We are able to conflict with external types,\n    // as we assume that locally defined types take precedence.\n    const existingType = this.pendingTypeMap[typeDef.name]\n\n    // If we already have a \"Nexus\" type, but it's not the same, trigger mark as an error,\n    // otherwise early exit\n    if (existingType) {\n      if (existingType !== typeDef) {\n        throw extendError(typeDef.name)\n      }\n      return\n    }\n\n    if (isNexusNamedTypeDef(typeDef)) {\n      if (isNexusNamedOuputTypeDef(typeDef) && typeDef.value.asNexusMethod) {\n        this.dynamicOutputFields[typeDef.value.asNexusMethod] = typeDef.name\n      }\n      if (isNexusNamedInputTypeDef(typeDef) && typeDef.value.asNexusMethod) {\n        this.dynamicInputFields[typeDef.value.asNexusMethod] = typeDef.name\n      }\n      if (isNexusScalarTypeDef(typeDef) && typeDef.value.sourceType) {\n        this.sourceTypings[typeDef.name] = typeDef.value.sourceType\n      }\n    }\n\n    // If it's a concrete GraphQL type, we handle it directly by convering the\n    // type to a Nexus structure, and capturing all of the referenced types\n    // while we're reconstructing.\n    if (isNamedType(typeDef)) {\n      // If we've already captured the named type, we can skip it\n      if (this.graphqlNamedTypeMap[typeDef.name]) {\n        return\n      }\n\n      // If we've used decorateType to wrap, then we can grab the types off\n      if (typeDef.extensions?.nexus) {\n        const { asNexusMethod, sourceType } = Object(typeDef.extensions.nexus)\n        if (asNexusMethod) {\n          if (isInputType(typeDef)) {\n            this.dynamicInputFields[asNexusMethod] = typeDef.name\n          }\n          if (isOutputType(typeDef)) {\n            this.dynamicOutputFields[asNexusMethod] = typeDef.name\n          }\n        }\n        if (sourceType) {\n          this.sourceTypings[typeDef.name] = sourceType\n        }\n      }\n      this.graphqlNamedTypeMap[typeDef.name] = this.handleNativeType(typeDef, {\n        captureLeafType: (t) => {\n          if (!this.graphqlNamedTypeMap[t.name] && t.name !== typeDef.name) {\n            this.addType(t)\n          }\n        },\n      })\n      if (typeDef.extensions?.nexus) {\n        this.addType(this.graphqlNamedTypeMap[typeDef.name])\n      }\n      return\n    }\n\n    this.pendingTypeMap[typeDef.name] = typeDef\n\n    if (isNexusInputObjectTypeDef(typeDef)) {\n      this.typesToWalk.push({ type: 'input', value: typeDef.value })\n    }\n    if (isNexusObjectTypeDef(typeDef)) {\n      this.typesToWalk.push({ type: 'object', value: typeDef.value })\n    }\n    if (isNexusInterfaceTypeDef(typeDef)) {\n      this.typesToWalk.push({ type: 'interface', value: typeDef.value })\n    }\n  }\n\n  addTypes(types: any) {\n    if (!types) {\n      return\n    }\n    if (isSchema(types)) {\n      if (this.config.mergeSchema?.schema === types) {\n        return\n      } else if (!this.config.mergeSchema) {\n        if (Object.keys(this.graphqlMergeSchemaMap).length) {\n          console.error(\n            new Error(\n              `It looks like you're trying to merge multiple GraphQL schemas.\\n Please open a GitHub ticket with more info about your use case.`\n            )\n          )\n        }\n        this.graphqlMergeSchemaMap = this.handleMergeSchema({ schema: types })\n      } else {\n        this.addTypes(types.getTypeMap())\n      }\n      return\n    }\n    if (isNexusPlugin(types)) {\n      if (!this.plugins?.includes(types)) {\n        throw new Error(\n          `Nexus plugin ${types.config.name} was seen in the \"types\" config, but should instead be provided to the \"plugins\" array.`\n        )\n      }\n      return\n    }\n    if (\n      isNexusNamedTypeDef(types) ||\n      isNexusExtendTypeDef(types) ||\n      isNexusExtendInputTypeDef(types) ||\n      isNamedType(types) ||\n      isNexusDynamicInputMethod(types) ||\n      isNexusDynamicOutputMethod(types) ||\n      isNexusDynamicOutputProperty(types) ||\n      isNexusMeta(types)\n    ) {\n      this.addType(types)\n    } else if (Array.isArray(types)) {\n      types.forEach((typeDef) => this.addTypes(typeDef))\n    } else if (isObject(types)) {\n      Object.keys(types).forEach((key) => this.addTypes(types[key]))\n    }\n  }\n\n  private addToNexusMeta(type: NexusMeta) {\n    if (this.nexusMetaObjects.has(type)) {\n      return\n    }\n    this.nexusMetaObjects.add(type)\n\n    if (isNexusMetaBuild(type)) {\n      const types = type[NEXUS_BUILD]()\n      this.addTypes(types)\n    }\n    if (isNexusMetaType(type)) {\n      this.addType(resolveNexusMetaType(type))\n    }\n  }\n\n  private walkTypes() {\n    let obj\n    while ((obj = this.typesToWalk.shift())) {\n      switch (obj.type) {\n        case 'input':\n          this.walkInputType(obj.value)\n          break\n        case 'interface':\n          this.walkInterfaceType(obj.value)\n          break\n        case 'object':\n          this.walkOutputType(obj.value)\n          break\n        default:\n          casesHandled(obj)\n      }\n    }\n  }\n\n  private beforeWalkTypes() {\n    this.plugins.forEach((obj, i) => {\n      if (!isNexusPlugin(obj)) {\n        throw new Error(`Expected a plugin in plugins[${i}], saw ${obj}`)\n      }\n      const { config: pluginConfig } = obj\n      if (pluginConfig.onInstall) {\n        // TODO(tim): remove anys/warning at 1.0\n        const installResult = pluginConfig.onInstall(this.builderLens) as any\n        if (Array.isArray(installResult?.types)) {\n          throw new Error(\n            `Nexus no longer supports a return value from onInstall, you should instead use the hasType/addType api (seen in plugin ${pluginConfig.name}). `\n          )\n        }\n      }\n      if (pluginConfig.onCreateFieldResolver) {\n        this.onCreateResolverFns.push(pluginConfig.onCreateFieldResolver)\n      }\n      if (pluginConfig.onCreateFieldSubscribe) {\n        this.onCreateSubscribeFns.push(pluginConfig.onCreateFieldSubscribe)\n      }\n      if (pluginConfig.onBeforeBuild) {\n        this.onBeforeBuildFns.push(pluginConfig.onBeforeBuild)\n      }\n      if (pluginConfig.onMissingType) {\n        this.onMissingTypeFns.push(pluginConfig.onMissingType)\n      }\n      if (pluginConfig.onAfterBuild) {\n        this.onAfterBuildFns.push(pluginConfig.onAfterBuild)\n      }\n      if (pluginConfig.onObjectDefinition) {\n        this.onObjectDefinitionFns.push(pluginConfig.onObjectDefinition)\n      }\n      if (pluginConfig.onAddOutputField) {\n        this.onAddOutputFieldFns.push(pluginConfig.onAddOutputField)\n      }\n      if (pluginConfig.onAddInputField) {\n        this.onAddInputFieldFns.push(pluginConfig.onAddInputField)\n      }\n      if (pluginConfig.onAddArg) {\n        this.onAddArgFns.push(pluginConfig.onAddArg)\n      }\n      if (pluginConfig.onInputObjectDefinition) {\n        this.onInputObjectDefinitionFns.push(pluginConfig.onInputObjectDefinition)\n      }\n    })\n  }\n\n  private beforeBuildTypes() {\n    this.onBeforeBuildFns.forEach((fn) => {\n      fn(this.builderLens)\n      if (this.typesToWalk.length > 0) {\n        this.walkTypes()\n      }\n    })\n  }\n\n  private checkForInterfaceCircularDependencies() {\n    const interfaces: Record<string, NexusInterfaceTypeConfig<any>> = {}\n    Object.keys(this.pendingTypeMap)\n      .map((key) => this.pendingTypeMap[key])\n      .filter(isNexusInterfaceTypeDef)\n      .forEach((type) => {\n        interfaces[type.name] = type.value\n      })\n    const alreadyChecked: Record<string, boolean> = {}\n    const walkType = (\n      obj: NexusInterfaceTypeConfig<any>,\n      path: string[],\n      visited: Record<string, boolean>\n    ) => {\n      if (alreadyChecked[obj.name]) {\n        return\n      }\n      if (visited[obj.name]) {\n        if (obj.name === path[path.length - 1]) {\n          throw new Error(`GraphQL Nexus: Interface ${obj.name} can't implement itself`)\n        } else {\n          throw new Error(\n            `GraphQL Nexus: Interface circular dependency detected ${[\n              ...path.slice(path.lastIndexOf(obj.name)),\n              obj.name,\n            ].join(' -> ')}`\n          )\n        }\n      }\n\n      const definitionBlock = new InterfaceDefinitionBlock({\n        typeName: obj.name,\n        addInterfaces: (i) =>\n          i.forEach((config) => {\n            const name = typeof config === 'string' ? config : config.value.name\n            walkType(interfaces[name], [...path, obj.name], { ...visited, [obj.name]: true })\n          }),\n        addModification: () => {},\n        addField: () => {},\n        addDynamicOutputMembers: (block, wrapping) => this.addDynamicOutputMembers(block, 'walk', wrapping),\n        warn: () => {},\n      })\n      obj.definition(definitionBlock)\n      alreadyChecked[obj.name] = true\n    }\n    Object.keys(interfaces).forEach((name) => {\n      walkType(interfaces[name], [], {})\n    })\n  }\n\n  private buildNexusTypes() {\n    // If Query isn't defined, set it to null so it falls through to \"missingType\"\n    if (!this.pendingTypeMap.Query && !this.config.schemaRoots?.query && !this.typeExtendMap.Query) {\n      this.pendingTypeMap.Query = null as any\n    }\n    Object.keys(this.pendingTypeMap).forEach((key) => {\n      if (this.typesToWalk.length > 0) {\n        this.walkTypes()\n      }\n      // If we've already constructed the type by this point,\n      // via circular dependency resolution don't worry about building it.\n      if (this.finalTypeMap[key]) {\n        return\n      }\n      if (this.definedTypeMap[key]) {\n        throw extendError(key)\n      }\n      this.finalTypeMap[key] = this.getOrBuildType(key)\n      this.buildingTypes.clear()\n    })\n    Object.keys(this.typeExtendMap).forEach((key) => {\n      // If we haven't defined the type, assume it's an object type\n      if (this.typeExtendMap[key] !== null && !this.hasType(key)) {\n        this.buildObjectType({\n          name: key,\n          definition() {},\n        })\n      }\n    })\n    Object.keys(this.inputTypeExtendMap).forEach((key) => {\n      // If we haven't defined the type, assume it's an input object type\n      if (this.inputTypeExtendMap[key] !== null && !this.hasType(key)) {\n        this.buildInputObjectType({\n          name: key,\n          definition() {},\n        })\n      }\n    })\n  }\n\n  private createSchemaExtension() {\n    this._schemaExtension = new NexusSchemaExtension({\n      ...this.config,\n      dynamicFields: {\n        dynamicInputFields: this.dynamicInputFields,\n        dynamicOutputFields: this.dynamicOutputFields,\n        dynamicOutputProperties: this.dynamicOutputProperties,\n      },\n      sourceTypings: this.sourceTypings,\n    })\n  }\n\n  getFinalTypeMap(): BuildTypes<any> {\n    this.beforeWalkTypes()\n    this.createSchemaExtension()\n    this.walkTypes()\n    this.beforeBuildTypes()\n    this.checkForInterfaceCircularDependencies()\n    this.buildNexusTypes()\n    return {\n      finalConfig: this.config,\n      typeMap: this.finalTypeMap,\n      schemaExtension: this.schemaExtension!,\n      missingTypes: this.missingTypes,\n      onAfterBuildFns: this.onAfterBuildFns,\n    }\n  }\n\n  private shouldMerge(typeName: string) {\n    if (!this.config.mergeSchema) {\n      return false\n    }\n    const { mergeTypes = ['Query', 'Mutation'] } = this.config.mergeSchema\n\n    return Boolean(mergeTypes === true || mergeTypes.includes(typeName))\n  }\n\n  private buildInputObjectType(config: NexusInputObjectTypeConfig<any>): GraphQLInputObjectType {\n    const fields: NexusInputFieldDef[] = []\n    const definitionBlock = new InputDefinitionBlock({\n      typeName: config.name,\n      addField: (field) => fields.push(this.addInputField(field)),\n      addDynamicInputFields: (block, wrapping) => this.addDynamicInputFields(block, wrapping),\n      warn: consoleWarn,\n    })\n    const externalNamedType = this.graphqlMergeSchemaMap[config.name]\n    if (this.shouldMerge(config.name) && isNexusInputObjectTypeDef(externalNamedType)) {\n      externalNamedType.value.definition(definitionBlock)\n    }\n    config.definition(definitionBlock)\n    this.onInputObjectDefinitionFns.forEach((fn) => {\n      fn(definitionBlock, config)\n    })\n    const extensions = this.inputTypeExtendMap[config.name]\n    if (extensions) {\n      extensions.forEach((extension) => {\n        extension.definition(definitionBlock)\n      })\n    }\n    this.inputTypeExtendMap[config.name] = null\n    const inputObjectTypeConfig: NexusGraphQLInputObjectTypeConfig = {\n      name: config.name,\n      fields: () => this.buildInputObjectFields(fields, inputObjectTypeConfig),\n      description: config.description,\n      extensions: {\n        ...config.extensions,\n        nexus: new NexusInputObjectTypeExtension(config),\n      },\n    }\n    return this.finalize(new GraphQLInputObjectType(inputObjectTypeConfig))\n  }\n\n  private buildObjectType(config: NexusObjectTypeConfig<string>) {\n    const fields: NexusOutputFieldDef[] = []\n    const interfaces: Implemented[] = []\n    const modifications: Record<string, FieldModificationDef<any, any>> = {}\n    const definitionBlock = new ObjectDefinitionBlock({\n      typeName: config.name,\n      addField: (fieldDef) => fields.push(this.addOutputField(fieldDef)),\n      addInterfaces: (interfaceDefs) => interfaces.push(...interfaceDefs),\n      addModification: (modification) => (modifications[modification.field] = modification),\n      addDynamicOutputMembers: (block, wrapping) => this.addDynamicOutputMembers(block, 'build', wrapping),\n      warn: consoleWarn,\n    })\n    const externalNamedType = this.graphqlMergeSchemaMap[config.name]\n    if (this.shouldMerge(config.name) && isNexusObjectTypeDef(externalNamedType)) {\n      externalNamedType.value.definition(definitionBlock)\n    }\n    config.definition(definitionBlock)\n    this.onObjectDefinitionFns.forEach((fn) => {\n      fn(definitionBlock, config)\n    })\n    const extensions = this.typeExtendMap[config.name]\n    if (extensions) {\n      extensions.forEach((extension) => {\n        extension.definition(definitionBlock)\n      })\n    }\n    this.typeExtendMap[config.name] = null\n    if (config.sourceType) {\n      this.sourceTypings[config.name] = config.sourceType\n    }\n    const objectTypeConfig: NexusGraphQLObjectTypeConfig = {\n      name: config.name,\n      interfaces: () => this.buildInterfaceList(interfaces),\n      description: config.description,\n      fields: () =>\n        this.buildOutputFields(\n          fields,\n          objectTypeConfig,\n          this.buildInterfaceFields(objectTypeConfig, interfaces, modifications)\n        ),\n      isTypeOf: (config as any).isTypeOf,\n      extensions: {\n        ...config.extensions,\n        nexus: new NexusObjectTypeExtension(config),\n      },\n    }\n    return this.finalize(new GraphQLObjectType(objectTypeConfig))\n  }\n\n  private buildInterfaceType(config: NexusInterfaceTypeConfig<any>) {\n    const { name, description } = config\n    let resolveType: AbstractTypeResolver<string> | undefined = (config as any).resolveType\n\n    const fields: NexusOutputFieldDef[] = []\n    const interfaces: Implemented[] = []\n    const modifications: Record<string, FieldModificationDef<any, any>> = {}\n    const definitionBlock = new InterfaceDefinitionBlock({\n      typeName: config.name,\n      addField: (field) => fields.push(this.addOutputField(field)),\n      addInterfaces: (interfaceDefs) => interfaces.push(...interfaceDefs),\n      addModification: (modification) => (modifications[modification.field] = modification),\n      addDynamicOutputMembers: (block, wrapping) => this.addDynamicOutputMembers(block, 'build', wrapping),\n      warn: consoleWarn,\n    })\n    const externalNamedType = this.graphqlMergeSchemaMap[config.name]\n    if (this.shouldMerge(config.name) && isNexusInterfaceTypeDef(externalNamedType)) {\n      externalNamedType.value.definition(definitionBlock)\n    }\n    config.definition(definitionBlock)\n\n    if (config.sourceType) {\n      this.sourceTypings[config.name] = config.sourceType\n    }\n    const interfaceTypeConfig: NexusGraphQLInterfaceTypeConfig = {\n      name,\n      interfaces: () => this.buildInterfaceList(interfaces),\n      resolveType,\n      description,\n      fields: () =>\n        this.buildOutputFields(\n          fields,\n          interfaceTypeConfig,\n          this.buildInterfaceFields(interfaceTypeConfig, interfaces, modifications)\n        ),\n      extensions: {\n        ...config.extensions,\n        nexus: new NexusInterfaceTypeExtension(config),\n      },\n    }\n    return this.finalize(new GraphQLInterfaceType(interfaceTypeConfig))\n  }\n\n  private addOutputField(field: NexusOutputFieldDef): NexusOutputFieldDef {\n    this.onAddOutputFieldFns.forEach((fn) => {\n      const result = fn(field)\n      if (result) {\n        field = result\n      }\n    })\n    return field\n  }\n\n  private addInputField(field: NexusInputFieldDef): NexusInputFieldDef {\n    this.onAddInputFieldFns.forEach((fn) => {\n      const result = fn(field)\n      if (result) {\n        field = result\n      }\n    })\n    return field\n  }\n\n  private buildEnumType(config: NexusEnumTypeConfig<any>) {\n    const { members } = config\n    const values: GraphQLEnumValueConfigMap = {}\n    if (isArray(members)) {\n      members.forEach((m) => {\n        if (typeof m === 'string') {\n          values[m] = { value: m }\n        } else {\n          values[m.name] = {\n            value: typeof m.value === 'undefined' ? m.name : m.value,\n            deprecationReason: m.deprecation,\n            description: m.description,\n            extensions: {\n              ...m.extensions,\n              nexus: m.extensions?.nexus ?? {},\n            },\n          }\n        }\n      })\n    } else {\n      Object.keys(members)\n        // members can potentially be a TypeScript enum.\n        // The compiled version of this enum will be the members object,\n        // numeric enums members also get a reverse mapping from enum values to enum names.\n        // In these cases we have to ensure we don't include these reverse mapping keys.\n        // See: https://www.typescriptlang.org/docs/handbook/enums.html\n        .filter((key) => isNaN(+key))\n        .forEach((key) => {\n          assertValidName(key)\n\n          values[key] = {\n            value: (members as Record<string, string | number | symbol>)[key],\n          }\n        })\n    }\n    if (!Object.keys(values).length) {\n      throw new Error(`GraphQL Nexus: Enum ${config.name} must have at least one member`)\n    }\n    if (config.sourceType) {\n      this.sourceTypings[config.name] = config.sourceType\n    }\n    return this.finalize(\n      new GraphQLEnumType({\n        name: config.name,\n        values: values,\n        description: config.description,\n        extensions: {\n          ...config.extensions,\n          nexus: config.extensions?.nexus ?? {},\n        },\n      })\n    )\n  }\n\n  private buildUnionType(config: NexusUnionTypeConfig<any>) {\n    let members: UnionMembers | undefined\n    let resolveType: AbstractTypeResolver<string> | undefined = (config as any).resolveType\n\n    config.definition(\n      new UnionDefinitionBlock({\n        typeName: config.name,\n        addUnionMembers: (unionMembers) => (members = unionMembers),\n      })\n    )\n\n    if (config.sourceType) {\n      this.sourceTypings[config.name] = config.sourceType\n    }\n    return this.finalize(\n      new GraphQLUnionType({\n        name: config.name,\n        resolveType,\n        description: config.description,\n        types: () => this.buildUnionMembers(config.name, members),\n        extensions: {\n          ...config.extensions,\n          nexus: config.extensions?.nexus ?? {},\n        },\n      })\n    )\n  }\n\n  private buildScalarType(config: NexusScalarTypeConfig<string>): GraphQLScalarType {\n    if (config.sourceType) {\n      this.sourceTypings[config.name] = config.sourceType\n    }\n    return this.finalize(\n      new GraphQLScalarType({\n        ...config,\n        extensions: {\n          ...config.extensions,\n          nexus: config.extensions?.nexus ?? {},\n        },\n      })\n    )\n  }\n\n  private finalize<T extends GraphQLNamedType>(type: T): T {\n    this.finalTypeMap[type.name] = type\n    return type\n  }\n\n  private missingType(typeName: string, fromObject: boolean = false): GraphQLNamedType {\n    invariantGuard(typeName)\n    if (this.onMissingTypeFns.length) {\n      for (let i = 0; i < this.onMissingTypeFns.length; i++) {\n        const fn = this.onMissingTypeFns[i]\n        const replacementType = fn(typeName, this.builderLens)\n        if (replacementType && replacementType.name) {\n          this.addType(replacementType)\n          return this.getOrBuildType(replacementType)\n        }\n      }\n    }\n    if (typeName === 'Query') {\n      return new GraphQLObjectType({\n        name: 'Query',\n        fields: {\n          ok: {\n            type: new GraphQLNonNull(GraphQLBoolean),\n            resolve: () => true,\n          },\n        },\n      })\n    }\n\n    if (!this.missingTypes[typeName]) {\n      this.missingTypes[typeName] = { fromObject }\n    }\n\n    this.addType(UNKNOWN_TYPE_SCALAR)\n    return this.getOrBuildType(UNKNOWN_TYPE_SCALAR)\n  }\n\n  private buildUnionMembers(unionName: string, members: UnionMembers | undefined) {\n    const unionMembers: GraphQLObjectType[] = []\n    /* istanbul ignore next */\n    if (!members) {\n      throw new Error(\n        `Missing Union members for ${unionName}.` +\n          `Make sure to call the t.members(...) method in the union blocks`\n      )\n    }\n    members.forEach((member) => {\n      unionMembers.push(this.getObjectType(member))\n    })\n    /* istanbul ignore next */\n    if (!unionMembers.length) {\n      throw new Error(`GraphQL Nexus: Union ${unionName} must have at least one member type`)\n    }\n    return unionMembers\n  }\n\n  private buildInterfaceList(interfaces: (string | NexusInterfaceTypeDef<any>)[]) {\n    const list: GraphQLInterfaceType[] = []\n    interfaces.forEach((i) => {\n      const type = this.getInterface(i)\n      list.push(type, ...graphql15InterfaceType(type).getInterfaces())\n    })\n    return Array.from(new Set(list))\n  }\n\n  private buildInterfaceFields(\n    forTypeConfig: NexusGraphQLObjectTypeConfig | NexusGraphQLInterfaceTypeConfig,\n    interfaces: (string | NexusInterfaceTypeDef<any>)[],\n    modifications: Record<string, FieldModificationDef<any, any>>\n  ) {\n    const interfaceFieldsMap: GraphQLFieldConfigMap<any, any> = {}\n    interfaces.forEach((i) => {\n      const config = this.getInterface(i).toConfig()\n      Object.keys(config.fields).forEach((field) => {\n        const interfaceField = config.fields[field]\n        interfaceFieldsMap[field] = interfaceField\n        if (modifications[field]) {\n          // TODO(tim): Refactor this whole mess\n          const { type, field: _field, args, extensions, ...rest } = modifications[field]\n          const extensionConfig: NexusOutputFieldConfig<any, any> = hasNexusExtension(extensions?.nexus)\n            ? extensions?.nexus?.config ?? {}\n            : {}\n          interfaceFieldsMap[field] = {\n            ...interfaceFieldsMap[field],\n            ...rest,\n            extensions: {\n              ...interfaceField.extensions,\n              ...extensions,\n              nexus: hasNexusExtension(interfaceField.extensions?.nexus)\n                ? interfaceField.extensions?.nexus?.modify(extensionConfig)\n                : new NexusFieldExtension(extensionConfig),\n            },\n          }\n          if (typeof type !== 'undefined') {\n            let interfaceReplacement: GraphQLOutputType\n            if (isNexusWrappingType(type)) {\n              const { wrapping, namedType } = unwrapNexusDef(type)\n              interfaceReplacement = rewrapAsGraphQLType(\n                this.getOrBuildType(namedType as any),\n                wrapping as NexusFinalWrapKind[]\n              ) as GraphQLOutputType\n            } else {\n              const { wrapping } = unwrapGraphQLDef(config.fields[field].type)\n              interfaceReplacement = rewrapAsGraphQLType(\n                this.getOutputType(type),\n                wrapping\n              ) as GraphQLOutputType\n            }\n            interfaceFieldsMap[field].type = interfaceReplacement\n          }\n          if (typeof args !== 'undefined') {\n            interfaceFieldsMap[field].args = {\n              ...this.buildArgs(args ?? {}, forTypeConfig, field),\n              ...interfaceFieldsMap[field].args,\n            }\n          }\n        }\n      })\n    })\n    return interfaceFieldsMap\n  }\n\n  private buildOutputFields(\n    fields: NexusOutputFieldDef[],\n    typeConfig: NexusGraphQLInterfaceTypeConfig | NexusGraphQLObjectTypeConfig,\n    intoObject: GraphQLFieldConfigMap<any, any>\n  ) {\n    fields.forEach((field) => {\n      intoObject[field.name] = this.buildOutputField(field, typeConfig)\n    })\n    return intoObject\n  }\n\n  private buildInputObjectFields(\n    fields: NexusInputFieldDef[],\n    typeConfig: NexusGraphQLInputObjectTypeConfig\n  ): GraphQLInputFieldConfigMap {\n    const fieldMap: GraphQLInputFieldConfigMap = {}\n    fields.forEach((field) => {\n      fieldMap[field.name] = this.buildInputObjectField(field, typeConfig)\n    })\n    return fieldMap\n  }\n\n  private getNonNullDefault(\n    nonNullDefaultConfig: { nonNullDefaults?: NonNullConfig } | undefined,\n    kind: 'input' | 'output'\n  ): boolean {\n    const { nonNullDefaults = {} } = nonNullDefaultConfig ?? {}\n\n    return nonNullDefaults[kind] ?? this.config.nonNullDefaults[kind] ?? false\n  }\n\n  private buildOutputField(\n    fieldConfig: NexusOutputFieldDef,\n    typeConfig: NexusGraphQLObjectTypeConfig | NexusGraphQLInterfaceTypeConfig\n  ): GraphQLFieldConfig<any, any> {\n    if (!fieldConfig.type) {\n      /* istanbul ignore next */\n      throw new Error(`Missing required \"type\" field for ${typeConfig.name}.${fieldConfig.name}`)\n    }\n    const fieldExtension = new NexusFieldExtension(fieldConfig)\n    const nonNullDefault = this.getNonNullDefault(typeConfig.extensions?.nexus?.config, 'output')\n    const { namedType, wrapping } = unwrapNexusDef(fieldConfig.type)\n    const finalWrap = finalizeWrapping(nonNullDefault, wrapping, fieldConfig.wrapping)\n    const builderFieldConfig: Omit<NexusGraphQLFieldConfig, 'resolve' | 'subscribe'> = {\n      name: fieldConfig.name,\n      type: rewrapAsGraphQLType(\n        this.getOutputType(namedType as PossibleOutputType),\n        finalWrap\n      ) as GraphQLOutputType,\n      args: this.buildArgs(fieldConfig.args || {}, typeConfig, fieldConfig.name),\n      description: fieldConfig.description,\n      deprecationReason: fieldConfig.deprecation,\n      extensions: {\n        ...fieldConfig.extensions,\n        nexus: fieldExtension,\n      },\n    }\n    return {\n      resolve: this.makeFinalResolver(\n        {\n          builder: this.builderLens,\n          fieldConfig: builderFieldConfig,\n          parentTypeConfig: typeConfig as any, // TODO(tim): remove as any when we drop support for 14.x\n          schemaConfig: this.config,\n          schemaExtension: this.schemaExtension,\n        },\n        fieldConfig.resolve\n      ),\n      subscribe: fieldConfig.subscribe,\n      ...builderFieldConfig,\n    }\n  }\n\n  private makeFinalResolver(info: CreateFieldResolverInfo, resolver?: GraphQLFieldResolver<any, any>) {\n    const resolveFn = resolver || defaultFieldResolver\n    if (this.onCreateResolverFns.length) {\n      const toCompose = this.onCreateResolverFns.map((fn) => fn(info)).filter((f) => f) as MiddlewareFn[]\n      if (toCompose.length) {\n        return composeMiddlewareFns(toCompose, resolveFn)\n      }\n    }\n    return resolveFn\n  }\n\n  private buildInputObjectField(\n    fieldConfig: NexusInputFieldDef,\n    typeConfig: NexusGraphQLInputObjectTypeConfig\n  ): GraphQLInputFieldConfig {\n    const nonNullDefault = this.getNonNullDefault(typeConfig.extensions?.nexus?.config, 'input')\n    const { namedType, wrapping } = unwrapNexusDef(fieldConfig.type)\n    const finalWrap = finalizeWrapping(nonNullDefault, wrapping, fieldConfig.wrapping)\n    return {\n      type: rewrapAsGraphQLType(\n        this.getInputType(namedType as PossibleInputType),\n        finalWrap\n      ) as GraphQLInputType,\n      defaultValue: fieldConfig.default,\n      description: fieldConfig.description,\n      extensions: {\n        ...fieldConfig.extensions,\n        nexus: fieldConfig.extensions?.nexus ?? {},\n      },\n    }\n  }\n\n  private buildArgs(\n    args: ArgsRecord,\n    typeConfig: NexusGraphQLObjectTypeConfig | NexusGraphQLInterfaceTypeConfig,\n    fieldName: string\n  ): GraphQLFieldConfigArgumentMap {\n    const allArgs: GraphQLFieldConfigArgumentMap = {}\n    for (const [argName, arg] of Object.entries(args)) {\n      const nonNullDefault = this.getNonNullDefault(typeConfig.extensions?.nexus?.config, 'input')\n      let finalArgDef: NexusFinalArgConfig = {\n        ...normalizeArgWrapping(arg).value,\n        fieldName,\n        argName,\n        parentType: typeConfig.name,\n        configFor: 'arg',\n      }\n      for (const onArgDef of this.onAddArgFns) {\n        const result = onArgDef(finalArgDef)\n        if (result != null) {\n          finalArgDef = result\n        }\n      }\n      const { namedType, wrapping } = unwrapNexusDef(finalArgDef.type)\n      const finalWrap = finalizeWrapping(nonNullDefault, wrapping)\n      allArgs[argName] = {\n        type: rewrapAsGraphQLType(\n          this.getInputType(namedType as PossibleInputType),\n          finalWrap\n        ) as GraphQLInputType,\n        description: finalArgDef.description,\n        defaultValue: finalArgDef.default,\n        extensions: {\n          ...finalArgDef.extensions,\n          nexus: finalArgDef.extensions?.nexus ?? {},\n        },\n      }\n    }\n    return allArgs\n  }\n\n  private getInterface(name: string | NexusInterfaceTypeDef<any>): GraphQLInterfaceType {\n    const type = this.getOrBuildType(name)\n    if (!isInterfaceType(type)) {\n      /* istanbul ignore next */\n      throw new Error(`Expected ${name} to be an interfaceType, saw ${type.constructor.name}(${type.name})`)\n    }\n    return type\n  }\n\n  private getInputType(\n    possibleInputType: PossibleInputType\n  ): Exclude<GraphQLInputType, GraphQLNonNull<any> | GraphQLList<any>> {\n    const nexusNamedType = getNexusNamedType(possibleInputType)\n    const graphqlType = this.getOrBuildType(nexusNamedType)\n    if (!isInputObjectType(graphqlType) && !isLeafType(graphqlType)) {\n      /* istanbul ignore next */\n      throw new Error(\n        `Expected ${nexusNamedType} to be a possible input type, saw ${graphqlType.constructor.name}(${graphqlType.name})`\n      )\n    }\n    return graphqlType\n  }\n\n  private getOutputType(\n    possibleOutputType: PossibleOutputType\n  ): Exclude<GraphQLOutputType, GraphQLNonNull<any> | GraphQLList<any>> {\n    const graphqlType = this.getOrBuildType(possibleOutputType)\n    if (!isOutputType(graphqlType)) {\n      /* istanbul ignore next */\n      throw new Error(\n        `Expected ${possibleOutputType} to be a valid output type, saw ${graphqlType.constructor.name}`\n      )\n    }\n    return graphqlType\n  }\n\n  private getObjectType(name: string | NexusObjectTypeDef<string>): GraphQLObjectType {\n    if (isNexusNamedTypeDef(name)) {\n      return this.getObjectType(name.name)\n    }\n    const type = this.getOrBuildType(name)\n    if (!isObjectType(type)) {\n      /* istanbul ignore next */\n      throw new Error(`Expected ${name} to be a objectType, saw ${type.constructor.name}`)\n    }\n    return type\n  }\n\n  private getOrBuildType(\n    type: string | AllNexusNamedTypeDefs | GraphQLNamedType,\n    fromObject: boolean = false\n  ): GraphQLNamedType {\n    invariantGuard(type)\n\n    if (isNamedType(type)) {\n      return type\n    }\n\n    if (isNexusNamedTypeDef(type)) {\n      return this.getOrBuildType(type.name, true)\n    }\n\n    if (SCALARS[type]) {\n      return SCALARS[type]\n    }\n    if (this.finalTypeMap[type]) {\n      return this.finalTypeMap[type]\n    }\n    if (this.buildingTypes.has(type)) {\n      /* istanbul ignore next */\n      throw new Error(\n        `GraphQL Nexus: Circular dependency detected, while building types ${Array.from(this.buildingTypes)}`\n      )\n    }\n    const pendingType =\n      this.pendingTypeMap[type] ?? this.graphqlNamedTypeMap[type] ?? this.graphqlMergeSchemaMap[type]\n\n    if (isNexusNamedTypeDef(pendingType)) {\n      this.buildingTypes.add(pendingType.name)\n      if (isNexusObjectTypeDef(pendingType)) {\n        return this.buildObjectType(pendingType.value)\n      } else if (isNexusInterfaceTypeDef(pendingType)) {\n        return this.buildInterfaceType(pendingType.value)\n      } else if (isNexusEnumTypeDef(pendingType)) {\n        return this.buildEnumType(pendingType.value)\n      } else if (isNexusScalarTypeDef(pendingType)) {\n        return this.buildScalarType(pendingType.value)\n      } else if (isNexusInputObjectTypeDef(pendingType)) {\n        return this.buildInputObjectType(pendingType.value)\n      } else if (isNexusUnionTypeDef(pendingType)) {\n        return this.buildUnionType(pendingType.value)\n      } else {\n        console.warn('Unknown kind of type def to build. It will be ignored. The type def was: %j', type)\n      }\n    }\n    return this.missingType(type, fromObject)\n  }\n\n  private walkInputType<T extends NexusShapedInput>(obj: T) {\n    const definitionBlock = new InputDefinitionBlock({\n      typeName: obj.name,\n      addField: (f) => this.maybeTraverseInputFieldType(f),\n      addDynamicInputFields: (block, wrapping) => this.addDynamicInputFields(block, wrapping),\n      warn: () => {},\n    })\n    obj.definition(definitionBlock)\n    return obj\n  }\n\n  private addDynamicInputFields(block: InputDefinitionBlock<any>, wrapping?: NexusWrapKind[]) {\n    eachObj(this.dynamicInputFields, (val, methodName) => {\n      if (typeof val === 'string') {\n        return this.addDynamicField(methodName, val, block)\n      }\n      // @ts-ignore\n      block[methodName] = (...args: any[]) => {\n        return val.value.factory({\n          args,\n          typeDef: block,\n          builder: this.builderLens,\n          typeName: block.typeName,\n          wrapping,\n        })\n      }\n    })\n  }\n\n  private addDynamicOutputMembers(\n    block: OutputDefinitionBlock<any>,\n    stage: 'walk' | 'build',\n    wrapping?: NexusWrapKind[]\n  ) {\n    eachObj(this.dynamicOutputFields, (val, methodName) => {\n      if (typeof val === 'string') {\n        return this.addDynamicField(methodName, val, block)\n      }\n      // @ts-ignore\n      block[methodName] = (...args: any[]) => {\n        return val.value.factory({\n          args,\n          typeDef: block,\n          builder: this.builderLens,\n          typeName: block.typeName,\n          stage,\n          wrapping,\n        })\n      }\n    })\n    eachObj(this.dynamicOutputProperties, (val, propertyName) => {\n      Object.defineProperty(block, propertyName, {\n        get() {\n          return val.value.factory({\n            typeDef: block,\n            builder: this.builderLens,\n            typeName: block.typeName,\n            stage,\n          })\n        },\n        enumerable: true,\n      })\n    })\n  }\n\n  private addDynamicField(\n    methodName: string,\n    typeName: string,\n    block: OutputDefinitionBlock<any> | InputDefinitionBlock<any>\n  ) {\n    // @ts-ignore\n    block[methodName] = (fieldName: string, opts: any) => {\n      let fieldConfig = {\n        type: typeName,\n      }\n\n      /* istanbul ignore if */\n      if (typeof opts === 'function') {\n        throw new Error(messages.removedFunctionShorthand(block.typeName, fieldName))\n      } else {\n        fieldConfig = { ...fieldConfig, ...opts }\n      }\n\n      // @ts-ignore\n      block.field(fieldName, fieldConfig)\n    }\n  }\n\n  private walkOutputType<T extends NexusShapedOutput>(obj: T) {\n    const definitionBlock = new ObjectDefinitionBlock({\n      typeName: obj.name,\n      addInterfaces: (i) => {\n        i.forEach((j) => {\n          if (typeof j !== 'string') {\n            this.addType(j)\n          }\n        })\n      },\n      addField: (f) => this.maybeTraverseOutputFieldType(f),\n      addDynamicOutputMembers: (block, wrapping) => this.addDynamicOutputMembers(block, 'walk', wrapping),\n      addModification: (o) => this.maybeTraverseModification(o),\n      warn: () => {},\n    })\n    obj.definition(definitionBlock)\n    return obj\n  }\n\n  private walkInterfaceType(obj: NexusInterfaceTypeConfig<any>) {\n    const definitionBlock = new InterfaceDefinitionBlock({\n      typeName: obj.name,\n      addModification: (o) => this.maybeTraverseModification(o),\n      addInterfaces: (i) => {\n        i.forEach((j) => {\n          if (typeof j !== 'string') {\n            this.addType(j)\n          }\n        })\n      },\n      addField: (f) => this.maybeTraverseOutputFieldType(f),\n      addDynamicOutputMembers: (block, wrapping) => this.addDynamicOutputMembers(block, 'walk', wrapping),\n      warn: () => {},\n    })\n    obj.definition(definitionBlock)\n    return obj\n  }\n\n  private maybeTraverseModification(mod: FieldModificationDef<any, any>) {\n    const { type, args } = mod\n    if (type) {\n      const namedFieldType = getNexusNamedType(mod.type)\n      if (typeof namedFieldType !== 'string') {\n        this.addType(namedFieldType)\n      }\n    }\n    if (args) {\n      this.traverseArgs(args)\n    }\n  }\n\n  private maybeTraverseOutputFieldType(type: NexusOutputFieldDef) {\n    const { args, type: fieldType } = type\n    const namedFieldType = getNexusNamedType(fieldType)\n    if (typeof namedFieldType !== 'string') {\n      this.addType(namedFieldType)\n    }\n    if (args) {\n      this.traverseArgs(args)\n    }\n  }\n\n  private traverseArgs(args: Record<string, AllNexusArgsDefs>) {\n    eachObj(args, (val) => {\n      const namedArgType = getArgNamedType(val)\n      if (typeof namedArgType !== 'string') {\n        this.addType(namedArgType)\n      }\n    })\n  }\n\n  private maybeTraverseInputFieldType(type: NexusInputFieldDef) {\n    const { type: fieldType } = type\n    const namedFieldType = getNexusNamedType(fieldType)\n    if (typeof namedFieldType !== 'string') {\n      this.addType(namedFieldType)\n    }\n  }\n\n  /**\n   * Given a \"mergeSchema\", gathers all of the types and constructs them into a map of types that we keep as a\n   * \"merge schema\"\n   *\n   * @param config\n   */\n  private handleMergeSchema(config: MergeSchemaConfig) {\n    const { types } = config.schema.toConfig()\n    const mergedTypes: Record<string, AllNexusNamedTypeDefs> = {}\n\n    // We don't need to worry about capturing any types while walking,\n    // because we have the entire schema\n    for (const type of types) {\n      if (type.name.startsWith('__')) {\n        continue\n      }\n      if (config.skipTypes?.includes(type.name)) {\n        continue\n      }\n      mergedTypes[type.name] = this.handleNativeType(type, config)\n    }\n    return mergedTypes\n  }\n\n  private handleNativeType(type: GraphQLType, config: RebuildConfig) {\n    while (isWrappingType(type)) {\n      type = type.ofType\n    }\n    this.pendingTypeMap[type.name] ??= null\n    return rebuildNamedType(type, config)\n  }\n}\n\nfunction extendError(name: string) {\n  return new Error(`${name} was already defined and imported as a type, check the docs for extending types`)\n}\n\nexport type DynamicFieldDefs = {\n  dynamicInputFields: DynamicInputFields\n  dynamicOutputFields: DynamicOutputFields\n  dynamicOutputProperties: DynamicOutputProperties\n}\n\nexport interface BuildTypes<TypeMapDefs extends Record<string, GraphQLNamedType>> {\n  finalConfig: BuilderConfig\n  typeMap: TypeMapDefs\n  missingTypes: Record<string, MissingType>\n  schemaExtension: NexusSchemaExtension\n  onAfterBuildFns: SchemaBuilder['onAfterBuildFns']\n}\n\n/** Builds the schema, we may return more than just the schema from this one day. */\nexport function makeSchemaInternal(config: SchemaConfig) {\n  const builder = new SchemaBuilder(config)\n  builder.addTypes(config.types)\n  if (config.schemaRoots) {\n    builder.addTypes(config.schemaRoots)\n  }\n  const { finalConfig, typeMap, missingTypes, schemaExtension, onAfterBuildFns } = builder.getFinalTypeMap()\n\n  function getRootType(rootType: 'query' | 'mutation' | 'subscription', defaultType: string) {\n    const rootTypeVal = config.schemaRoots?.[rootType] ?? defaultType\n    let returnVal: null | GraphQLNamedType = null\n    if (typeof rootTypeVal === 'string') {\n      returnVal = typeMap[rootTypeVal]\n    } else if (rootTypeVal) {\n      if (isNexusObjectTypeDef(rootTypeVal)) {\n        returnVal = typeMap[rootTypeVal.name]\n      } else if (isObjectType(rootTypeVal)) {\n        returnVal = typeMap[rootTypeVal.name]\n      }\n    }\n    if (returnVal && !isObjectType(returnVal)) {\n      throw new Error(`Expected ${rootType} to be a objectType, saw ${returnVal.constructor.name}`)\n    }\n    return returnVal\n  }\n\n  const schema = new GraphQLSchema({\n    query: getRootType('query', 'Query'),\n    mutation: getRootType('mutation', 'Mutation'),\n    subscription: getRootType('subscription', 'Subscription'),\n    types: objValues(typeMap),\n    extensions: {\n      ...config.extensions,\n      nexus: schemaExtension,\n    },\n  }) as NexusGraphQLSchema\n\n  onAfterBuildFns.forEach((fn) => fn(schema))\n\n  return { schema, missingTypes, finalConfig }\n}\n\nexport function setConfigDefaults(config: BuilderConfigInput): BuilderConfig {\n  const defaults: {\n    features: BuilderConfig['features']\n    nonNullDefaults: BuilderConfig['nonNullDefaults']\n    plugins: BuilderConfig['plugins']\n  } = {\n    features: {\n      abstractTypeRuntimeChecks: true,\n      abstractTypeStrategies: {\n        isTypeOf: false,\n        resolveType: true,\n        __typename: false,\n      },\n    },\n    nonNullDefaults: {\n      input: false,\n      output: false,\n    },\n    plugins: [fieldAuthorizePlugin()],\n  }\n\n  if (!config.features) {\n    config.features = defaults.features\n  } else {\n    // abstractTypeStrategies\n\n    if (!config.features.abstractTypeStrategies) {\n      config.features.abstractTypeStrategies = defaults.features.abstractTypeStrategies\n    } else {\n      config.features.abstractTypeStrategies.__typename =\n        config.features.abstractTypeStrategies.__typename ?? false\n      config.features.abstractTypeStrategies.isTypeOf =\n        config.features.abstractTypeStrategies.isTypeOf ?? false\n      config.features.abstractTypeStrategies.resolveType =\n        config.features.abstractTypeStrategies.resolveType ?? false\n    }\n\n    // abstractTypeRuntimeChecks\n    if (config.features.abstractTypeStrategies.__typename === true) {\n      // Discriminant Model Field strategy cannot be used with runtime checks because at runtime\n      // we cannot know if a resolver for a field whose type is an abstract type includes __typename\n      // in the returned model data.\n      config.features.abstractTypeRuntimeChecks = false\n    }\n    if (config.features.abstractTypeRuntimeChecks === undefined) {\n      config.features.abstractTypeRuntimeChecks = defaults.features.abstractTypeRuntimeChecks\n    }\n  }\n\n  config.plugins = config.plugins ?? []\n  config.nonNullDefaults = {\n    ...defaults.nonNullDefaults,\n    ...(config.nonNullDefaults ?? {}),\n  }\n\n  return config as BuilderConfig\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,OAAO,EACL,eAAe,EACf,oBAAoB,EACpB,cAAc,EACd,eAAe,EAMf,YAAY,EACZ,SAAS,EAGT,sBAAsB,EAEtB,UAAU,EACV,oBAAoB,EAGpB,cAAc,EACd,iBAAiB,EAEjB,iBAAiB,EACjB,aAAa,EAEb,aAAa,EAEb,gBAAgB,EAChB,iBAAiB,EACjB,WAAW,EACX,eAAe,EACf,UAAU,EACV,WAAW,EACX,YAAY,EACZ,YAAY,EACZ,QAAQ,EACR,cAAc,GAEf,MAAM,SAAS,CAAA;AAEhB,OAAO,EACL,oBAAoB,GAKrB,MAAM,gCAAgC,CAAA;AAKvC,OAAO,EAGL,wBAAwB,GAGzB,MAAM,6BAA6B,CAAA;AACpC,OAAO,EAA6C,qBAAqB,EAAE,MAAM,0BAA0B,CAAA;AAE3G,OAAO,EAAwB,oBAAoB,EAAgB,MAAM,yBAAyB,CAAA;AAClG,OAAO,EAML,gBAAgB,EAChB,yBAAyB,EACzB,0BAA0B,EAC1B,4BAA4B,EAC5B,kBAAkB,EAClB,yBAAyB,EACzB,oBAAoB,EACpB,yBAAyB,EACzB,uBAAuB,EACvB,wBAAwB,EACxB,wBAAwB,EACxB,mBAAmB,EACnB,oBAAoB,EACpB,aAAa,EACb,oBAAoB,EACpB,mBAAmB,EACnB,mBAAmB,EAGnB,oBAAoB,EACpB,mBAAmB,EACnB,gBAAgB,EAChB,cAAc,GACf,MAAM,wBAAwB,CAAA;AAe/B,OAAO,EACL,iBAAiB,EACjB,mBAAmB,EACnB,6BAA6B,EAC7B,2BAA2B,EAC3B,wBAAwB,EACxB,oBAAoB,GACrB,MAAM,cAAc,CAAA;AACrB,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAA;AACrC,OAAO,EACL,oBAAoB,GAKrB,MAAM,UAAU,CAAA;;AACjB,OAAO,EAAE,yBAAyB,EAAE,MAAM,WAAW,CAAA;AACrD,OAAO,EAAE,oBAAoB,EAAE,MAAM,gCAAgC,CAAA;AAKrE,OAAO,EACL,YAAY,EACZ,WAAW,EACX,OAAO,EACP,eAAe,EACf,iBAAiB,EACjB,sBAAsB,EACtB,cAAc,EACd,OAAO,EACP,QAAQ,EACR,SAAS,EACT,mBAAmB,GACpB,MAAM,SAAS,CAAA;AAChB,OAAO,EACL,WAAW,EACX,gBAAgB,EAChB,WAAW,EACX,eAAe,EAEf,oBAAoB,GACrB,MAAM,yBAAyB,CAAA;AAChC,OAAO,EAAE,gBAAgB,EAAiB,MAAM,eAAe,CAAA;;;;;;;;;;;;;;;;AAY/D,MAAM,OAAO,GAAsC;IACjD,MAAM,EAAE,mNAAa;IACrB,GAAG,EAAE,gNAAU;IACf,KAAK,EAAE,kNAAY;IACnB,EAAE,EAAE,+MAAS;IACb,OAAO,EAAE,oNAAc;CACxB,CAAA;AAkPK,MAAO,aAAa;IA8FxB,YAAY,MAA0B,CAAA;QA7FtC,6DAAA,EAA+D,CACvD,IAAA,CAAA,gBAAgB,GAAG,IAAI,GAAG,EAAE,CAAA;QACpC,2CAAA,EAA6C,CACrC,IAAA,CAAA,aAAa,GAAG,IAAI,GAAG,EAAE,CAAA;QACjC,+DAAA,EAAiE,CACzD,IAAA,CAAA,YAAY,GAAqC,CAAA,CAAE,CAAA;QAC3D;;;WAGG,CACK,IAAA,CAAA,cAAc,GAAqC,CAAA,CAAE,CAAA;QAC7D;;;WAGG,CACK,IAAA,CAAA,cAAc,GAAiD,CAAA,CAAE,CAAA;QACzE,2EAAA,EAA6E,CACrE,IAAA,CAAA,aAAa,GAA2D,CAAA,CAAE,CAAA;QAClF,iFAAA,EAAmF,CAC3E,IAAA,CAAA,kBAAkB,GAAgE,CAAA,CAAE,CAAA;QAC5F;;;;WAIG,CACK,IAAA,CAAA,mBAAmB,GAA0C,CAAA,CAAE,CAAA;QAEvE;;;WAGG,CACK,IAAA,CAAA,qBAAqB,GAA0C,CAAA,CAAE,CAAA;QAEjE,IAAA,CAAA,kBAAkB,GAAuB,CAAA,CAAE,CAAA;QAC3C,IAAA,CAAA,mBAAmB,GAAwB,CAAA,CAAE,CAAA;QAC7C,IAAA,CAAA,uBAAuB,GAA4B,CAAA,CAAE,CAAA;QACrD,IAAA,CAAA,OAAO,GAAkB,EAAE,CAAA;QAEnC,2DAAA,EAA6D,CACrD,IAAA,CAAA,WAAW,GAAiB,EAAE,CAAA;QAEtC,oEAAA,EAAsE,CAC9D,IAAA,CAAA,aAAa,GAAkB,CAAA,CAAE,CAAA;QAEzC,2BAAA,EAA6B,CACrB,IAAA,CAAA,YAAY,GAAgC,CAAA,CAAE,CAAA;QAKtD,mFAAA,EAAqF,CAC7E,IAAA,CAAA,gBAAgB,GAAwD,EAAE,CAAA;QAElF,0CAAA,EAA4C,CACpC,IAAA,CAAA,gBAAgB,GAAwD,EAAE,CAAA;QAElF,8DAAA,EAAgE,CACxD,IAAA,CAAA,mBAAmB,GAAgE,EAAE,CAAA;QAE7F,wEAAA,EAA0E,CAClE,IAAA,CAAA,oBAAoB,GAAiE,EAAE,CAAA;QAE/F,yEAAA,EAA2E,CACnE,IAAA,CAAA,eAAe,GAAuD,EAAE,CAAA;QAEhF,6FAAA,EAA+F,CACvF,IAAA,CAAA,qBAAqB,GAA6D,EAAE,CAAA;QAE5F,6FAAA,EAA+F,CACvF,IAAA,CAAA,0BAA0B,GAAkE,EAAE,CAAA;QAEtG,+GAAA,EAAiH,CACzG,IAAA,CAAA,WAAW,GAAmD,EAAE,CAAA;QAExE,+GAAA,EAAiH,CACzG,IAAA,CAAA,mBAAmB,GAA2D,EAAE,CAAA;QAExF,+GAAA,EAAiH,CACzG,IAAA,CAAA,kBAAkB,GAA0D,EAAE,CAAA;QAqCtF,IAAA,CAAA,eAAe,GAAG,CAAqC,GAAM,EAAE,KAA4B,EAAE,EAAE;YAC7F,IAAI,CAAC,MAAM,GAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACN,IAAI,CAAC,MAAM,GAAA;gBACd,CAAC,GAAG,CAAC,EAAE,KAAK;YAAA,EACb,CAAA;QACH,CAAC,CAAA;QAED,IAAA,CAAA,eAAe,GAAG,CAAC,GAA6B,EAAW,EAAE;YAC3D,OAAO,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,CAAA;QACxC,CAAC,CAAA;QAED,IAAA,CAAA,eAAe,GAAG,CAAqC,GAAM,EAAyB,EAAE;YACtF,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;QACzB,CAAC,CAAA;QAED,IAAA,CAAA,OAAO,GAAG,CAAC,QAAgB,EAAW,EAAE;YACtC,OAAO,OAAO,CACZ,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,IAC3B,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,IAC3B,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,IAClC,IAAI,CAAC,qBAAqB,CAAC,QAAQ,CAAC,CACvC,CAAA;QACH,CAAC,CAAA;QAED;;;;WAIG,CACK,IAAA,CAAA,OAAO,GAAG,CAAC,OAA6B,EAAE,EAAE;;YAClD,QAAI,mQAAyB,EAAC,OAAO,CAAC,EAAE;gBACtC,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,OAAO,CAAA;gBAC/C,OAAM;aACP;YACD,QAAI,oQAA0B,EAAC,OAAO,CAAC,EAAE;gBACvC,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,OAAO,CAAA;gBAChD,OAAM;aACP;YACD,QAAI,sQAA4B,EAAC,OAAO,CAAC,EAAE;gBACzC,IAAI,CAAC,uBAAuB,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,OAAO,CAAA;gBACpD,OAAM;aACP;YAED,QAAI,sPAAW,EAAC,OAAO,CAAC,EAAE;gBACxB,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAA;gBAC5B,OAAM;aACP;YAED,oCAAoC;YACpC,IAAI,CAAA,KAAA,OAAO,CAAC,IAAI,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,UAAU,CAAC,IAAI,CAAC,EAAE;gBAClC,OAAM;aACP;YAED,QAAI,8PAAoB,EAAC,OAAO,CAAC,EAAE;gBACjC,MAAM,cAAc,GAAG,AAAC,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAA;gBAClG,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAA;gBAClC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC;oBAAE,IAAI,EAAE,QAAQ;oBAAE,KAAK,EAAE,OAAO,CAAC,KAAK;gBAAA,CAAE,CAAC,CAAA;gBAC/D,OAAM;aACP;YAED,QAAI,mQAAyB,EAAC,OAAO,CAAC,EAAE;gBACtC,MAAM,cAAc,GAAG,AAAC,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,IAAI,CAAC,GAC3D,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAA;gBAC9C,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAA;gBAClC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC;oBAAE,IAAI,EAAE,OAAO;oBAAE,KAAK,EAAE,OAAO,CAAC,KAAK;gBAAA,CAAE,CAAC,CAAA;gBAC9D,OAAM;aACP;YAED,sGAAsG;YACtG,2DAA2D;YAC3D,MAAM,YAAY,GAAG,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA;YAEtD,sFAAsF;YACtF,uBAAuB;YACvB,IAAI,YAAY,EAAE;gBAChB,IAAI,YAAY,KAAK,OAAO,EAAE;oBAC5B,MAAM,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA;iBAChC;gBACD,OAAM;aACP;YAED,QAAI,6PAAmB,EAAC,OAAO,CAAC,EAAE;gBAChC,QAAI,kQAAwB,EAAC,OAAO,CAAC,IAAI,OAAO,CAAC,KAAK,CAAC,aAAa,EAAE;oBACpE,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,KAAK,CAAC,aAAa,CAAC,GAAG,OAAO,CAAC,IAAI,CAAA;iBACrE;gBACD,QAAI,kQAAwB,EAAC,OAAO,CAAC,IAAI,OAAO,CAAC,KAAK,CAAC,aAAa,EAAE;oBACpE,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,KAAK,CAAC,aAAa,CAAC,GAAG,OAAO,CAAC,IAAI,CAAA;iBACpE;gBACD,QAAI,8PAAoB,EAAC,OAAO,CAAC,IAAI,OAAO,CAAC,KAAK,CAAC,UAAU,EAAE;oBAC7D,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC,KAAK,CAAC,UAAU,CAAA;iBAC5D;aACF;YAED,0EAA0E;YAC1E,uEAAuE;YACvE,8BAA8B;YAC9B,QAAI,oNAAW,EAAC,OAAO,CAAC,EAAE;gBACxB,2DAA2D;gBAC3D,IAAI,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;oBAC1C,OAAM;iBACP;gBAED,qEAAqE;gBACrE,IAAI,CAAA,KAAA,OAAO,CAAC,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,KAAK,EAAE;oBAC7B,MAAM,EAAE,aAAa,EAAE,UAAU,EAAE,GAAG,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,CAAA;oBACtE,IAAI,aAAa,EAAE;wBACjB,QAAI,oNAAW,EAAC,OAAO,CAAC,EAAE;4BACxB,IAAI,CAAC,kBAAkB,CAAC,aAAa,CAAC,GAAG,OAAO,CAAC,IAAI,CAAA;yBACtD;wBACD,QAAI,qNAAY,EAAC,OAAO,CAAC,EAAE;4BACzB,IAAI,CAAC,mBAAmB,CAAC,aAAa,CAAC,GAAG,OAAO,CAAC,IAAI,CAAA;yBACvD;qBACF;oBACD,IAAI,UAAU,EAAE;wBACd,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,UAAU,CAAA;qBAC9C;iBACF;gBACD,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE;oBACtE,eAAe,EAAE,CAAC,CAAC,EAAE,EAAE;wBACrB,IAAI,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,KAAK,OAAO,CAAC,IAAI,EAAE;4BAChE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAA;yBAChB;oBACH,CAAC;iBACF,CAAC,CAAA;gBACF,IAAI,CAAA,KAAA,OAAO,CAAC,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,KAAK,EAAE;oBAC7B,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAA;iBACrD;gBACD,OAAM;aACP;YAED,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,OAAO,CAAA;YAE3C,QAAI,mQAAyB,EAAC,OAAO,CAAC,EAAE;gBACtC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC;oBAAE,IAAI,EAAE,OAAO;oBAAE,KAAK,EAAE,OAAO,CAAC,KAAK;gBAAA,CAAE,CAAC,CAAA;aAC/D;YACD,QAAI,8PAAoB,EAAC,OAAO,CAAC,EAAE;gBACjC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC;oBAAE,IAAI,EAAE,QAAQ;oBAAE,KAAK,EAAE,OAAO,CAAC,KAAK;gBAAA,CAAE,CAAC,CAAA;aAChE;YACD,QAAI,iQAAuB,EAAC,OAAO,CAAC,EAAE;gBACpC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC;oBAAE,IAAI,EAAE,WAAW;oBAAE,KAAK,EAAE,OAAO,CAAC,KAAK;gBAAA,CAAE,CAAC,CAAA;aACnE;QACH,CAAC,CAAA;QAlKC,IAAI,CAAC,MAAM,GAAG,iBAAiB,CAAC,MAAM,CAAC,CAAA;QACvC,wFAAA,EAA0F,CAC1F,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;gBAAC,sQAAoB,EAAE;SAAC,CAAA;QAE9F,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,MAAM,CAAC,IAAI,KAAK,qBAAqB,CAAC,EAAE;YACtE,IAAI,CAAC,OAAO,CAAC,IAAI,KAAC,gRAAyB,EAAC;gBAAE,OAAO,EAAE,IAAI;YAAA,CAAE,CAAC,CAAC,CAAA;SAChE;QAED,IAAI,CAAC,WAAW,GAAG,MAAM,CAAC,MAAM,CAAC;YAC/B,OAAO,EAAE,IAAI,CAAC,OAAO;YACrB,OAAO,EAAE,IAAI,CAAC,OAAO;YACrB,eAAe,EAAE,IAAI,CAAC,eAAe;YACrC,eAAe,EAAE,IAAI,CAAC,eAAe;YACrC,eAAe,EAAE,IAAI,CAAC,eAAe;SACtC,CAAC,CAAA;QAEF,IAAI,MAAM,CAAC,WAAW,EAAE;YACtB,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,WAAW,CAAC,CAAA;SACxE;IACH,CAAC;IA5BD,IAAY,eAAe,GAAA;QACzB,wBAAA,EAA0B,CAC1B,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE;YAC1B,MAAM,IAAI,KAAK,CAAC,uDAAuD,CAAC,CAAA;SACzE;QACD,OAAO,IAAI,CAAC,gBAAgB,CAAA;IAC9B,CAAC;IAuKD,QAAQ,CAAC,KAAU,EAAA;;QACjB,IAAI,CAAC,KAAK,EAAE;YACV,OAAM;SACP;QACD,QAAI,6MAAQ,EAAC,KAAK,CAAC,EAAE;YACnB,IAAI,CAAA,CAAA,KAAA,IAAI,CAAC,MAAM,CAAC,WAAW,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,MAAM,MAAK,KAAK,EAAE;gBAC7C,OAAM;aACP,MAAM,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE;gBACnC,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC,MAAM,EAAE;oBAClD,OAAO,CAAC,KAAK,CACX,IAAI,KAAK,CACP,CAAA,gIAAA,CAAkI,CACnI,CACF,CAAA;iBACF;gBACD,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC,iBAAiB,CAAC;oBAAE,MAAM,EAAE,KAAK;gBAAA,CAAE,CAAC,CAAA;aACvE,MAAM;gBACL,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,UAAU,EAAE,CAAC,CAAA;aAClC;YACD,OAAM;SACP;QACD,QAAI,uPAAa,EAAC,KAAK,CAAC,EAAE;YACxB,IAAI,CAAC,CAAA,CAAA,KAAA,IAAI,CAAC,OAAO,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,QAAQ,CAAC,KAAK,CAAC,CAAA,EAAE;gBAClC,MAAM,IAAI,KAAK,CACb,CAAA,aAAA,EAAgB,KAAK,CAAC,MAAM,CAAC,IAAI,CAAA,uFAAA,CAAyF,CAC3H,CAAA;aACF;YACD,OAAM;SACP;QACD,QACE,6PAAmB,EAAC,KAAK,CAAC,QAC1B,8PAAoB,EAAC,KAAK,CAAC,QAC3B,mQAAyB,EAAC,KAAK,CAAC,QAChC,oNAAW,EAAC,KAAK,CAAC,QAClB,mQAAyB,EAAC,KAAK,CAAC,QAChC,oQAA0B,EAAC,KAAK,CAAC,QACjC,sQAA4B,EAAC,KAAK,CAAC,QACnC,sPAAW,EAAC,KAAK,CAAC,EAClB;YACA,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAA;SACpB,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YAC/B,KAAK,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,CAAG,CAAD,GAAK,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAA;SACnD,MAAM,QAAI,gOAAQ,EAAC,KAAK,CAAC,EAAE;YAC1B,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,CAAG,CAAD,GAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAA;SAC/D;IACH,CAAC;IAEO,cAAc,CAAC,IAAe,EAAA;QACpC,IAAI,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;YACnC,OAAM;SACP;QACD,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;QAE/B,QAAI,2PAAgB,EAAC,IAAI,CAAC,EAAE;YAC1B,MAAM,KAAK,GAAG,IAAI,CAAC,sPAAW,CAAC,EAAE,CAAA;YACjC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAA;SACrB;QACD,QAAI,0PAAe,EAAC,IAAI,CAAC,EAAE;YACzB,IAAI,CAAC,OAAO,KAAC,+PAAoB,EAAC,IAAI,CAAC,CAAC,CAAA;SACzC;IACH,CAAC;IAEO,SAAS,GAAA;QACf,IAAI,GAAG,CAAA;QACP,MAAQ,CAAD,EAAI,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC,AAAE;YACvC,OAAQ,GAAG,CAAC,IAAI,EAAE;gBAChB,KAAK,OAAO;oBACV,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;oBAC7B,MAAK;gBACP,KAAK,WAAW;oBACd,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;oBACjC,MAAK;gBACP,KAAK,QAAQ;oBACX,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;oBAC9B,MAAK;gBACP;wBACE,oOAAY,EAAC,GAAG,CAAC,CAAA;aACpB;SACF;IACH,CAAC;IAEO,eAAe,GAAA;QACrB,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,CAAC,EAAE,EAAE;YAC9B,IAAI,KAAC,uPAAa,EAAC,GAAG,CAAC,EAAE;gBACvB,MAAM,IAAI,KAAK,CAAC,CAAA,6BAAA,EAAgC,CAAC,CAAA,OAAA,EAAU,GAAG,EAAE,CAAC,CAAA;aAClE;YACD,MAAM,EAAE,MAAM,EAAE,YAAY,EAAE,GAAG,GAAG,CAAA;YACpC,IAAI,YAAY,CAAC,SAAS,EAAE;gBAC1B,wCAAwC;gBACxC,MAAM,aAAa,GAAG,YAAY,CAAC,SAAS,CAAC,IAAI,CAAC,WAAW,CAAQ,CAAA;gBACrE,IAAI,KAAK,CAAC,OAAO,CAAC,aAAa,KAAA,QAAb,aAAa,KAAA,KAAA,IAAA,KAAA,IAAb,aAAa,CAAE,KAAK,CAAC,EAAE;oBACvC,MAAM,IAAI,KAAK,CACb,CAAA,uHAAA,EAA0H,YAAY,CAAC,IAAI,CAAA,GAAA,CAAK,CACjJ,CAAA;iBACF;aACF;YACD,IAAI,YAAY,CAAC,qBAAqB,EAAE;gBACtC,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,YAAY,CAAC,qBAAqB,CAAC,CAAA;aAClE;YACD,IAAI,YAAY,CAAC,sBAAsB,EAAE;gBACvC,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,YAAY,CAAC,sBAAsB,CAAC,CAAA;aACpE;YACD,IAAI,YAAY,CAAC,aAAa,EAAE;gBAC9B,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,YAAY,CAAC,aAAa,CAAC,CAAA;aACvD;YACD,IAAI,YAAY,CAAC,aAAa,EAAE;gBAC9B,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,YAAY,CAAC,aAAa,CAAC,CAAA;aACvD;YACD,IAAI,YAAY,CAAC,YAAY,EAAE;gBAC7B,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,YAAY,CAAC,YAAY,CAAC,CAAA;aACrD;YACD,IAAI,YAAY,CAAC,kBAAkB,EAAE;gBACnC,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,YAAY,CAAC,kBAAkB,CAAC,CAAA;aACjE;YACD,IAAI,YAAY,CAAC,gBAAgB,EAAE;gBACjC,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,YAAY,CAAC,gBAAgB,CAAC,CAAA;aAC7D;YACD,IAAI,YAAY,CAAC,eAAe,EAAE;gBAChC,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,CAAC,eAAe,CAAC,CAAA;aAC3D;YACD,IAAI,YAAY,CAAC,QAAQ,EAAE;gBACzB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAA;aAC7C;YACD,IAAI,YAAY,CAAC,uBAAuB,EAAE;gBACxC,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,YAAY,CAAC,uBAAuB,CAAC,CAAA;aAC3E;QACH,CAAC,CAAC,CAAA;IACJ,CAAC;IAEO,gBAAgB,GAAA;QACtB,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC,EAAE,EAAE,EAAE;YACnC,EAAE,CAAC,IAAI,CAAC,WAAW,CAAC,CAAA;YACpB,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC/B,IAAI,CAAC,SAAS,EAAE,CAAA;aACjB;QACH,CAAC,CAAC,CAAA;IACJ,CAAC;IAEO,qCAAqC,GAAA;QAC3C,MAAM,UAAU,GAAkD,CAAA,CAAE,CAAA;QACpE,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAC7B,GAAG,CAAC,CAAC,GAAG,EAAE,CAAG,CAAD,GAAK,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,CACtC,MAAM,CAAC,iQAAuB,CAAC,CAC/B,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;YAChB,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAA;QACpC,CAAC,CAAC,CAAA;QACJ,MAAM,cAAc,GAA4B,CAAA,CAAE,CAAA;QAClD,MAAM,QAAQ,GAAG,CACf,GAAkC,EAClC,IAAc,EACd,OAAgC,EAChC,EAAE;YACF,IAAI,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;gBAC5B,OAAM;aACP;YACD,IAAI,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;gBACrB,IAAI,GAAG,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE;oBACtC,MAAM,IAAI,KAAK,CAAC,CAAA,yBAAA,EAA4B,GAAG,CAAC,IAAI,CAAA,uBAAA,CAAyB,CAAC,CAAA;iBAC/E,MAAM;oBACL,MAAM,IAAI,KAAK,CACb,CAAA,sDAAA,EAAyD;2BACpD,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;wBACzC,GAAG,CAAC,IAAI;qBACT,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CACjB,CAAA;iBACF;aACF;YAED,MAAM,eAAe,GAAG,IAAI,uQAAwB,CAAC;gBACnD,QAAQ,EAAE,GAAG,CAAC,IAAI;gBAClB,aAAa,EAAE,CAAC,CAAC,EAAE,CACjB,CAAC,AADkB,CACjB,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;wBACnB,MAAM,IAAI,GAAG,OAAO,MAAM,KAAK,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAA;wBACpE,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,CAAC;+BAAG,IAAI;4BAAE,GAAG,CAAC,IAAI;yBAAC,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAO,OAAO,GAAA;4BAAE,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,IAAI;wBAAA,GAAG,CAAA;oBACnF,CAAC,CAAC;gBACJ,eAAe,EAAE,GAAG,EAAE,AAAE,CAAC;gBACzB,QAAQ,EAAE,GAAG,EAAE,AAAE,CAAC;gBAClB,uBAAuB,EAAE,CAAC,KAAK,EAAE,QAAQ,EAAE,CAAG,CAAD,GAAK,CAAC,uBAAuB,CAAC,KAAK,EAAE,MAAM,EAAE,QAAQ,CAAC;gBACnG,IAAI,EAAE,GAAG,EAAE,AAAE,CAAC;aACf,CAAC,CAAA;YACF,GAAG,CAAC,UAAU,CAAC,eAAe,CAAC,CAAA;YAC/B,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,IAAI,CAAA;QACjC,CAAC,CAAA;QACD,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;YACvC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,EAAE,EAAE,CAAA,CAAE,CAAC,CAAA;QACpC,CAAC,CAAC,CAAA;IACJ,CAAC;IAEO,eAAe,GAAA;;QACrB,8EAA8E;QAC9E,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,IAAI,CAAC,CAAA,CAAA,KAAA,IAAI,CAAC,MAAM,CAAC,WAAW,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,KAAK,CAAA,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE;YAC9F,IAAI,CAAC,cAAc,CAAC,KAAK,GAAG,IAAW,CAAA;SACxC;QACD,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,EAAE;YAC/C,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC/B,IAAI,CAAC,SAAS,EAAE,CAAA;aACjB;YACD,uDAAuD;YACvD,oEAAoE;YACpE,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;gBAC1B,OAAM;aACP;YACD,IAAI,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE;gBAC5B,MAAM,WAAW,CAAC,GAAG,CAAC,CAAA;aACvB;YACD,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,CAAA;YACjD,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,CAAA;QAC5B,CAAC,CAAC,CAAA;QACF,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,EAAE;YAC9C,6DAA6D;YAC7D,IAAI,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;gBAC1D,IAAI,CAAC,eAAe,CAAC;oBACnB,IAAI,EAAE,GAAG;oBACT,UAAU,KAAI,CAAC;iBAChB,CAAC,CAAA;aACH;QACH,CAAC,CAAC,CAAA;QACF,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,EAAE;YACnD,mEAAmE;YACnE,IAAI,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,KAAK,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;gBAC/D,IAAI,CAAC,oBAAoB,CAAC;oBACxB,IAAI,EAAE,GAAG;oBACT,UAAU,KAAI,CAAC;iBAChB,CAAC,CAAA;aACH;QACH,CAAC,CAAC,CAAA;IACJ,CAAC;IAEO,qBAAqB,GAAA;QAC3B,IAAI,CAAC,gBAAgB,GAAG,IAAI,iPAAoB,CAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAC3C,IAAI,CAAC,MAAM,GAAA;YACd,aAAa,EAAE;gBACb,kBAAkB,EAAE,IAAI,CAAC,kBAAkB;gBAC3C,mBAAmB,EAAE,IAAI,CAAC,mBAAmB;gBAC7C,uBAAuB,EAAE,IAAI,CAAC,uBAAuB;aACtD;YACD,aAAa,EAAE,IAAI,CAAC,aAAa;QAAA,GACjC,CAAA;IACJ,CAAC;IAED,eAAe,GAAA;QACb,IAAI,CAAC,eAAe,EAAE,CAAA;QACtB,IAAI,CAAC,qBAAqB,EAAE,CAAA;QAC5B,IAAI,CAAC,SAAS,EAAE,CAAA;QAChB,IAAI,CAAC,gBAAgB,EAAE,CAAA;QACvB,IAAI,CAAC,qCAAqC,EAAE,CAAA;QAC5C,IAAI,CAAC,eAAe,EAAE,CAAA;QACtB,OAAO;YACL,WAAW,EAAE,IAAI,CAAC,MAAM;YACxB,OAAO,EAAE,IAAI,CAAC,YAAY;YAC1B,eAAe,EAAE,IAAI,CAAC,eAAgB;YACtC,YAAY,EAAE,IAAI,CAAC,YAAY;YAC/B,eAAe,EAAE,IAAI,CAAC,eAAe;SACtC,CAAA;IACH,CAAC;IAEO,WAAW,CAAC,QAAgB,EAAA;QAClC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE;YAC5B,OAAO,KAAK,CAAA;SACb;QACD,MAAM,EAAE,UAAU,GAAG;YAAC,OAAO;YAAE,UAAU;SAAC,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,WAAW,CAAA;QAEtE,OAAO,OAAO,CAAC,UAAU,KAAK,IAAI,IAAI,UAAU,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAA;IACtE,CAAC;IAEO,oBAAoB,CAAC,MAAuC,EAAA;QAClE,MAAM,MAAM,GAAyB,EAAE,CAAA;QACvC,MAAM,eAAe,GAAG,IAAI,sQAAoB,CAAC;YAC/C,QAAQ,EAAE,MAAM,CAAC,IAAI;YACrB,QAAQ,EAAE,CAAC,KAAK,EAAE,CAAG,CAAD,KAAO,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;YAC3D,qBAAqB,EAAE,CAAC,KAAK,EAAE,QAAQ,EAAE,CAAG,CAAD,GAAK,CAAC,qBAAqB,CAAC,KAAK,EAAE,QAAQ,CAAC;YACvF,IAAI,EAAE,mOAAW;SAClB,CAAC,CAAA;QACF,MAAM,iBAAiB,GAAG,IAAI,CAAC,qBAAqB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;QACjE,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,QAAI,mQAAyB,EAAC,iBAAiB,CAAC,EAAE;YACjF,iBAAiB,CAAC,KAAK,CAAC,UAAU,CAAC,eAAe,CAAC,CAAA;SACpD;QACD,MAAM,CAAC,UAAU,CAAC,eAAe,CAAC,CAAA;QAClC,IAAI,CAAC,0BAA0B,CAAC,OAAO,CAAC,CAAC,EAAE,EAAE,EAAE;YAC7C,EAAE,CAAC,eAAe,EAAE,MAAM,CAAC,CAAA;QAC7B,CAAC,CAAC,CAAA;QACF,MAAM,UAAU,GAAG,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;QACvD,IAAI,UAAU,EAAE;YACd,UAAU,CAAC,OAAO,CAAC,CAAC,SAAS,EAAE,EAAE;gBAC/B,SAAS,CAAC,UAAU,CAAC,eAAe,CAAC,CAAA;YACvC,CAAC,CAAC,CAAA;SACH;QACD,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,IAAI,CAAA;QAC3C,MAAM,qBAAqB,GAAsC;YAC/D,IAAI,EAAE,MAAM,CAAC,IAAI;YACjB,MAAM,EAAE,GAAG,CAAG,CAAD,GAAK,CAAC,sBAAsB,CAAC,MAAM,EAAE,qBAAqB,CAAC;YACxE,WAAW,EAAE,MAAM,CAAC,WAAW;YAC/B,UAAU,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACL,MAAM,CAAC,UAAU,GAAA;gBACpB,KAAK,EAAE,IAAI,0PAA6B,CAAC,MAAM,CAAC;YAAA,EACjD;SACF,CAAA;QACD,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,+NAAsB,CAAC,qBAAqB,CAAC,CAAC,CAAA;IACzE,CAAC;IAEO,eAAe,CAAC,MAAqC,EAAA;QAC3D,MAAM,MAAM,GAA0B,EAAE,CAAA;QACxC,MAAM,UAAU,GAAkB,EAAE,CAAA;QACpC,MAAM,aAAa,GAAmD,CAAA,CAAE,CAAA;QACxE,MAAM,eAAe,GAAG,IAAI,iQAAqB,CAAC;YAChD,QAAQ,EAAE,MAAM,CAAC,IAAI;YACrB,QAAQ,EAAE,CAAC,QAAQ,EAAE,CAAG,CAAD,KAAO,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;YAClE,aAAa,EAAE,CAAC,aAAa,EAAE,CAAG,CAAD,SAAW,CAAC,IAAI,CAAC,GAAG,aAAa,CAAC;YACnE,eAAe,EAAE,CAAC,YAAY,EAAE,CAAI,CAAF,CAAC,WAAc,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,YAAY,CAAC;YACrF,uBAAuB,EAAE,CAAC,KAAK,EAAE,QAAQ,EAAE,CAAG,CAAD,GAAK,CAAC,uBAAuB,CAAC,KAAK,EAAE,OAAO,EAAE,QAAQ,CAAC;YACpG,IAAI,EAAE,mOAAW;SAClB,CAAC,CAAA;QACF,MAAM,iBAAiB,GAAG,IAAI,CAAC,qBAAqB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;QACjE,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,QAAI,8PAAoB,EAAC,iBAAiB,CAAC,EAAE;YAC5E,iBAAiB,CAAC,KAAK,CAAC,UAAU,CAAC,eAAe,CAAC,CAAA;SACpD;QACD,MAAM,CAAC,UAAU,CAAC,eAAe,CAAC,CAAA;QAClC,IAAI,CAAC,qBAAqB,CAAC,OAAO,CAAC,CAAC,EAAE,EAAE,EAAE;YACxC,EAAE,CAAC,eAAe,EAAE,MAAM,CAAC,CAAA;QAC7B,CAAC,CAAC,CAAA;QACF,MAAM,UAAU,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;QAClD,IAAI,UAAU,EAAE;YACd,UAAU,CAAC,OAAO,CAAC,CAAC,SAAS,EAAE,EAAE;gBAC/B,SAAS,CAAC,UAAU,CAAC,eAAe,CAAC,CAAA;YACvC,CAAC,CAAC,CAAA;SACH;QACD,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,IAAI,CAAA;QACtC,IAAI,MAAM,CAAC,UAAU,EAAE;YACrB,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,UAAU,CAAA;SACpD;QACD,MAAM,gBAAgB,GAAiC;YACrD,IAAI,EAAE,MAAM,CAAC,IAAI;YACjB,UAAU,EAAE,GAAG,CAAG,CAAD,GAAK,CAAC,kBAAkB,CAAC,UAAU,CAAC;YACrD,WAAW,EAAE,MAAM,CAAC,WAAW;YAC/B,MAAM,EAAE,GAAG,CACT,CADW,GACP,CAAC,iBAAiB,CACpB,MAAM,EACN,gBAAgB,EAChB,IAAI,CAAC,oBAAoB,CAAC,gBAAgB,EAAE,UAAU,EAAE,aAAa,CAAC,CACvE;YACH,QAAQ,EAAG,MAAc,CAAC,QAAQ;YAClC,UAAU,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACL,MAAM,CAAC,UAAU,GAAA;gBACpB,KAAK,EAAE,IAAI,qPAAwB,CAAC,MAAM,CAAC;YAAA,EAC5C;SACF,CAAA;QACD,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,0NAAiB,CAAC,gBAAgB,CAAC,CAAC,CAAA;IAC/D,CAAC;IAEO,kBAAkB,CAAC,MAAqC,EAAA;QAC9D,MAAM,EAAE,IAAI,EAAE,WAAW,EAAE,GAAG,MAAM,CAAA;QACpC,IAAI,WAAW,GAA8C,MAAc,CAAC,WAAW,CAAA;QAEvF,MAAM,MAAM,GAA0B,EAAE,CAAA;QACxC,MAAM,UAAU,GAAkB,EAAE,CAAA;QACpC,MAAM,aAAa,GAAmD,CAAA,CAAE,CAAA;QACxE,MAAM,eAAe,GAAG,IAAI,uQAAwB,CAAC;YACnD,QAAQ,EAAE,MAAM,CAAC,IAAI;YACrB,QAAQ,EAAE,CAAC,KAAK,EAAE,CAAG,CAAD,KAAO,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;YAC5D,aAAa,EAAE,CAAC,aAAa,EAAE,CAAG,CAAD,SAAW,CAAC,IAAI,CAAC,GAAG,aAAa,CAAC;YACnE,eAAe,EAAE,CAAC,YAAY,EAAE,CAAI,CAAF,CAAC,WAAc,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,YAAY,CAAC;YACrF,uBAAuB,EAAE,CAAC,KAAK,EAAE,QAAQ,EAAE,CAAG,CAAD,GAAK,CAAC,uBAAuB,CAAC,KAAK,EAAE,OAAO,EAAE,QAAQ,CAAC;YACpG,IAAI,EAAE,mOAAW;SAClB,CAAC,CAAA;QACF,MAAM,iBAAiB,GAAG,IAAI,CAAC,qBAAqB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;QACjE,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,QAAI,iQAAuB,EAAC,iBAAiB,CAAC,EAAE;YAC/E,iBAAiB,CAAC,KAAK,CAAC,UAAU,CAAC,eAAe,CAAC,CAAA;SACpD;QACD,MAAM,CAAC,UAAU,CAAC,eAAe,CAAC,CAAA;QAElC,IAAI,MAAM,CAAC,UAAU,EAAE;YACrB,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,UAAU,CAAA;SACpD;QACD,MAAM,mBAAmB,GAAoC;YAC3D,IAAI;YACJ,UAAU,EAAE,GAAG,CAAG,CAAD,GAAK,CAAC,kBAAkB,CAAC,UAAU,CAAC;YACrD,WAAW;YACX,WAAW;YACX,MAAM,EAAE,GAAG,CACT,CADW,GACP,CAAC,iBAAiB,CACpB,MAAM,EACN,mBAAmB,EACnB,IAAI,CAAC,oBAAoB,CAAC,mBAAmB,EAAE,UAAU,EAAE,aAAa,CAAC,CAC1E;YACH,UAAU,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACL,MAAM,CAAC,UAAU,GAAA;gBACpB,KAAK,EAAE,IAAI,wPAA2B,CAAC,MAAM,CAAC;YAAA,EAC/C;SACF,CAAA;QACD,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,6NAAoB,CAAC,mBAAmB,CAAC,CAAC,CAAA;IACrE,CAAC;IAEO,cAAc,CAAC,KAA0B,EAAA;QAC/C,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,CAAC,EAAE,EAAE,EAAE;YACtC,MAAM,MAAM,GAAG,EAAE,CAAC,KAAK,CAAC,CAAA;YACxB,IAAI,MAAM,EAAE;gBACV,KAAK,GAAG,MAAM,CAAA;aACf;QACH,CAAC,CAAC,CAAA;QACF,OAAO,KAAK,CAAA;IACd,CAAC;IAEO,aAAa,CAAC,KAAyB,EAAA;QAC7C,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC,EAAE,EAAE,EAAE;YACrC,MAAM,MAAM,GAAG,EAAE,CAAC,KAAK,CAAC,CAAA;YACxB,IAAI,MAAM,EAAE;gBACV,KAAK,GAAG,MAAM,CAAA;aACf;QACH,CAAC,CAAC,CAAA;QACF,OAAO,KAAK,CAAA;IACd,CAAC;IAEO,aAAa,CAAC,MAAgC,EAAA;;QACpD,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,CAAA;QAC1B,MAAM,MAAM,GAA8B,CAAA,CAAE,CAAA;QAC5C,QAAI,+NAAO,EAAC,OAAO,CAAC,EAAE;YACpB,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE;;gBACpB,IAAI,OAAO,CAAC,KAAK,QAAQ,EAAE;oBACzB,MAAM,CAAC,CAAC,CAAC,GAAG;wBAAE,KAAK,EAAE,CAAC;oBAAA,CAAE,CAAA;iBACzB,MAAM;oBACL,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG;wBACf,KAAK,EAAE,OAAO,CAAC,CAAC,KAAK,KAAK,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK;wBACxD,iBAAiB,EAAE,CAAC,CAAC,WAAW;wBAChC,WAAW,EAAE,CAAC,CAAC,WAAW;wBAC1B,UAAU,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACL,CAAC,CAAC,UAAU,GAAA;4BACf,KAAK,EAAE,CAAA,KAAA,CAAA,KAAA,CAAC,CAAC,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,KAAK,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,CAAA,CAAE;wBAAA,EACjC;qBACF,CAAA;iBACF;YACH,CAAC,CAAC,CAAA;SACH,MAAM;YACL,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,AAClB,gDAAgD;YAChD,gEAAgE;YAChE,mFAAmF;YACnF,gFAAgF;YAChF,+DAA+D;aAC9D,MAAM,CAAC,CAAC,GAAG,EAAE,CAAG,CAAD,IAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAC5B,OAAO,CAAC,CAAC,GAAG,EAAE,EAAE;oBACf,kOAAe,EAAC,GAAG,CAAC,CAAA;gBAEpB,MAAM,CAAC,GAAG,CAAC,GAAG;oBACZ,KAAK,EAAG,OAAoD,CAAC,GAAG,CAAC;iBAClE,CAAA;YACH,CAAC,CAAC,CAAA;SACL;QACD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE;YAC/B,MAAM,IAAI,KAAK,CAAC,CAAA,oBAAA,EAAuB,MAAM,CAAC,IAAI,CAAA,8BAAA,CAAgC,CAAC,CAAA;SACpF;QACD,IAAI,MAAM,CAAC,UAAU,EAAE;YACrB,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,UAAU,CAAA;SACpD;QACD,OAAO,IAAI,CAAC,QAAQ,CAClB,IAAI,wNAAe,CAAC;YAClB,IAAI,EAAE,MAAM,CAAC,IAAI;YACjB,MAAM,EAAE,MAAM;YACd,WAAW,EAAE,MAAM,CAAC,WAAW;YAC/B,UAAU,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACL,MAAM,CAAC,UAAU,GAAA;gBACpB,KAAK,EAAE,CAAA,KAAA,CAAA,KAAA,MAAM,CAAC,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,KAAK,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,CAAA,CAAE;YAAA,EACtC;SACF,CAAC,CACH,CAAA;IACH,CAAC;IAEO,cAAc,CAAC,MAAiC,EAAA;;QACtD,IAAI,OAAiC,CAAA;QACrC,IAAI,WAAW,GAA8C,MAAc,CAAC,WAAW,CAAA;QAEvF,MAAM,CAAC,UAAU,CACf,IAAI,+PAAoB,CAAC;YACvB,QAAQ,EAAE,MAAM,CAAC,IAAI;YACrB,eAAe,EAAE,CAAC,YAAY,EAAE,CAAI,CAAF,CAAC,KAAQ,GAAG,YAAY,CAAC;SAC5D,CAAC,CACH,CAAA;QAED,IAAI,MAAM,CAAC,UAAU,EAAE;YACrB,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,UAAU,CAAA;SACpD;QACD,OAAO,IAAI,CAAC,QAAQ,CAClB,IAAI,yNAAgB,CAAC;YACnB,IAAI,EAAE,MAAM,CAAC,IAAI;YACjB,WAAW;YACX,WAAW,EAAE,MAAM,CAAC,WAAW;YAC/B,KAAK,EAAE,GAAG,CAAG,CAAD,GAAK,CAAC,iBAAiB,CAAC,MAAM,CAAC,IAAI,EAAE,OAAO,CAAC;YACzD,UAAU,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACL,MAAM,CAAC,UAAU,GAAA;gBACpB,KAAK,EAAE,CAAA,KAAA,CAAA,KAAA,MAAM,CAAC,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,KAAK,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,CAAA,CAAE;YAAA,EACtC;SACF,CAAC,CACH,CAAA;IACH,CAAC;IAEO,eAAe,CAAC,MAAqC,EAAA;;QAC3D,IAAI,MAAM,CAAC,UAAU,EAAE;YACrB,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,UAAU,CAAA;SACpD;QACD,OAAO,IAAI,CAAC,QAAQ,CAClB,IAAI,0NAAiB,CAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAChB,MAAM,GAAA;YACT,UAAU,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACL,MAAM,CAAC,UAAU,GAAA;gBACpB,KAAK,EAAE,CAAA,KAAA,CAAA,KAAA,MAAM,CAAC,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,KAAK,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,CAAA,CAAE;YAAA;QAAA,GAEvC,CACH,CAAA;IACH,CAAC;IAEO,QAAQ,CAA6B,IAAO,EAAA;QAClD,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAA;QACnC,OAAO,IAAI,CAAA;IACb,CAAC;IAEO,WAAW,CAAC,QAAgB,EAAE,aAAsB,KAAK,EAAA;YAC/D,sOAAc,EAAC,QAAQ,CAAC,CAAA;QACxB,IAAI,IAAI,CAAC,gBAAgB,CAAC,MAAM,EAAE;YAChC,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,gBAAgB,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE;gBACrD,MAAM,EAAE,GAAG,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAA;gBACnC,MAAM,eAAe,GAAG,EAAE,CAAC,QAAQ,EAAE,IAAI,CAAC,WAAW,CAAC,CAAA;gBACtD,IAAI,eAAe,IAAI,eAAe,CAAC,IAAI,EAAE;oBAC3C,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,CAAA;oBAC7B,OAAO,IAAI,CAAC,cAAc,CAAC,eAAe,CAAC,CAAA;iBAC5C;aACF;SACF;QACD,IAAI,QAAQ,KAAK,OAAO,EAAE;YACxB,OAAO,IAAI,0NAAiB,CAAC;gBAC3B,IAAI,EAAE,OAAO;gBACb,MAAM,EAAE;oBACN,EAAE,EAAE;wBACF,IAAI,EAAE,IAAI,uNAAc,CAAC,oNAAc,CAAC;wBACxC,OAAO,EAAE,GAAG,CAAG,CAAD,GAAK;qBACpB;iBACF;aACF,CAAC,CAAA;SACH;QAED,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,EAAE;YAChC,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,GAAG;gBAAE,UAAU;YAAA,CAAE,CAAA;SAC7C;QAED,IAAI,CAAC,OAAO,CAAC,2OAAmB,CAAC,CAAA;QACjC,OAAO,IAAI,CAAC,cAAc,CAAC,2OAAmB,CAAC,CAAA;IACjD,CAAC;IAEO,iBAAiB,CAAC,SAAiB,EAAE,OAAiC,EAAA;QAC5E,MAAM,YAAY,GAAwB,EAAE,CAAA;QAC5C,wBAAA,EAA0B,CAC1B,IAAI,CAAC,OAAO,EAAE;YACZ,MAAM,IAAI,KAAK,CACb,CAAA,0BAAA,EAA6B,SAAS,CAAA,CAAA,CAAG,GACvC,CAAA,+DAAA,CAAiE,CACpE,CAAA;SACF;QACD,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;YACzB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC,CAAA;QAC/C,CAAC,CAAC,CAAA;QACF,wBAAA,EAA0B,CAC1B,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE;YACxB,MAAM,IAAI,KAAK,CAAC,CAAA,qBAAA,EAAwB,SAAS,CAAA,mCAAA,CAAqC,CAAC,CAAA;SACxF;QACD,OAAO,YAAY,CAAA;IACrB,CAAC;IAEO,kBAAkB,CAAC,UAAmD,EAAA;QAC5E,MAAM,IAAI,GAA2B,EAAE,CAAA;QACvC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE;YACvB,MAAM,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,CAAA;YACjC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,OAAG,8OAAsB,EAAC,IAAI,CAAC,CAAC,aAAa,EAAE,CAAC,CAAA;QAClE,CAAC,CAAC,CAAA;QACF,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC,CAAA;IAClC,CAAC;IAEO,oBAAoB,CAC1B,aAA6E,EAC7E,UAAmD,EACnD,aAA6D,EAAA;QAE7D,MAAM,kBAAkB,GAAoC,CAAA,CAAE,CAAA;QAC9D,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE;YACvB,MAAM,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAA;YAC9C,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;;gBAC3C,MAAM,cAAc,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAA;gBAC3C,kBAAkB,CAAC,KAAK,CAAC,GAAG,cAAc,CAAA;gBAC1C,IAAI,aAAa,CAAC,KAAK,CAAC,EAAE;oBACxB,sCAAsC;oBACtC,MAAM,KAAqD,aAAa,CAAC,KAAK,CAAC,EAAzE,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE,UAAU,EAAA,GAAA,EAAkC,EAA7B,IAAI,GAAA,IAAA,mMAAA,EAAA,IAAhD;wBAAA;wBAAA;wBAAA;wBAAA;qBAAkD,CAAuB,CAAA;oBAC/E,MAAM,eAAe,OAAqC,8OAAiB,EAAC,UAAU,KAAA,QAAV,UAAU,KAAA,KAAA,IAAA,KAAA,IAAV,UAAU,CAAE,KAAK,CAAC,GAC1F,CAAA,KAAA,CAAA,KAAA,UAAU,KAAA,QAAV,UAAU,KAAA,KAAA,IAAA,KAAA,IAAV,UAAU,CAAE,KAAK,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,MAAM,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,CAAA,CAAE,GAC/B,CAAA,CAAE,CAAA;oBACN,kBAAkB,CAAC,KAAK,CAAC,GAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACpB,kBAAkB,CAAC,KAAK,CAAC,GACzB,IAAI,GAAA;wBACP,UAAU,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACL,cAAc,CAAC,UAAU,GACzB,UAAU,GAAA;4BACb,KAAK,MAAE,8OAAiB,EAAC,CAAA,KAAA,cAAc,CAAC,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,KAAK,CAAC,GACtD,CAAA,KAAA,CAAA,KAAA,cAAc,CAAC,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,KAAK,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,MAAM,CAAC,eAAe,CAAC,GACzD,IAAI,gPAAmB,CAAC,eAAe,CAAC;wBAAA;oBAAA,EAE/C,CAAA;oBACD,IAAI,OAAO,IAAI,KAAK,WAAW,EAAE;wBAC/B,IAAI,oBAAuC,CAAA;wBAC3C,QAAI,6PAAmB,EAAC,IAAI,CAAC,EAAE;4BAC7B,MAAM,EAAE,QAAQ,EAAE,SAAS,EAAE,OAAG,wPAAc,EAAC,IAAI,CAAC,CAAA;4BACpD,oBAAoB,OAAG,6PAAmB,EACxC,IAAI,CAAC,cAAc,CAAC,SAAgB,CAAC,EACrC,QAAgC,CACZ,CAAA;yBACvB,MAAM;4BACL,MAAM,EAAE,QAAQ,EAAE,OAAG,0PAAgB,EAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,CAAA;4BAChE,oBAAoB,OAAG,6PAAmB,EACxC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,EACxB,QAAQ,CACY,CAAA;yBACvB;wBACD,kBAAkB,CAAC,KAAK,CAAC,CAAC,IAAI,GAAG,oBAAoB,CAAA;qBACtD;oBACD,IAAI,OAAO,IAAI,KAAK,WAAW,EAAE;wBAC/B,kBAAkB,CAAC,KAAK,CAAC,CAAC,IAAI,GAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACzB,IAAI,CAAC,SAAS,CAAC,IAAI,KAAA,QAAJ,IAAI,KAAA,KAAA,IAAJ,IAAI,GAAI,CAAA,CAAE,EAAE,aAAa,EAAE,KAAK,CAAC,GAChD,kBAAkB,CAAC,KAAK,CAAC,CAAC,IAAI,CAClC,CAAA;qBACF;iBACF;YACH,CAAC,CAAC,CAAA;QACJ,CAAC,CAAC,CAAA;QACF,OAAO,kBAAkB,CAAA;IAC3B,CAAC;IAEO,iBAAiB,CACvB,MAA6B,EAC7B,UAA0E,EAC1E,UAA2C,EAAA;QAE3C,MAAM,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;YACvB,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,gBAAgB,CAAC,KAAK,EAAE,UAAU,CAAC,CAAA;QACnE,CAAC,CAAC,CAAA;QACF,OAAO,UAAU,CAAA;IACnB,CAAC;IAEO,sBAAsB,CAC5B,MAA4B,EAC5B,UAA6C,EAAA;QAE7C,MAAM,QAAQ,GAA+B,CAAA,CAAE,CAAA;QAC/C,MAAM,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;YACvB,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,qBAAqB,CAAC,KAAK,EAAE,UAAU,CAAC,CAAA;QACtE,CAAC,CAAC,CAAA;QACF,OAAO,QAAQ,CAAA;IACjB,CAAC;IAEO,iBAAiB,CACvB,oBAAqE,EACrE,IAAwB,EAAA;;QAExB,MAAM,EAAE,eAAe,GAAG,CAAA,CAAE,EAAE,GAAG,oBAAoB,KAAA,QAApB,oBAAoB,KAAA,KAAA,IAApB,oBAAoB,GAAI,CAAA,CAAE,CAAA;QAE3D,OAAO,CAAA,KAAA,CAAA,KAAA,eAAe,CAAC,IAAI,CAAC,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,KAAK,CAAA;IAC5E,CAAC;IAEO,gBAAgB,CACtB,WAAgC,EAChC,UAA0E,EAAA;;QAE1E,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE;YACrB,wBAAA,EAA0B,CAC1B,MAAM,IAAI,KAAK,CAAC,CAAA,kCAAA,EAAqC,UAAU,CAAC,IAAI,CAAA,CAAA,EAAI,WAAW,CAAC,IAAI,EAAE,CAAC,CAAA;SAC5F;QACD,MAAM,cAAc,GAAG,IAAI,gPAAmB,CAAC,WAAW,CAAC,CAAA;QAC3D,MAAM,cAAc,GAAG,IAAI,CAAC,iBAAiB,CAAC,CAAA,KAAA,CAAA,KAAA,UAAU,CAAC,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,KAAK,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,MAAM,EAAE,QAAQ,CAAC,CAAA;QAC7F,MAAM,EAAE,SAAS,EAAE,QAAQ,EAAE,OAAG,wPAAc,EAAC,WAAW,CAAC,IAAI,CAAC,CAAA;QAChE,MAAM,SAAS,OAAG,0PAAgB,EAAC,cAAc,EAAE,QAAQ,EAAE,WAAW,CAAC,QAAQ,CAAC,CAAA;QAClF,MAAM,kBAAkB,GAA2D;YACjF,IAAI,EAAE,WAAW,CAAC,IAAI;YACtB,IAAI,MAAE,6PAAmB,EACvB,IAAI,CAAC,aAAa,CAAC,SAA+B,CAAC,EACnD,SAAS,CACW;YACtB,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,IAAI,IAAI,CAAA,CAAE,EAAE,UAAU,EAAE,WAAW,CAAC,IAAI,CAAC;YAC1E,WAAW,EAAE,WAAW,CAAC,WAAW;YACpC,iBAAiB,EAAE,WAAW,CAAC,WAAW;YAC1C,UAAU,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACL,WAAW,CAAC,UAAU,GAAA;gBACzB,KAAK,EAAE,cAAc;YAAA,EACtB;SACF,CAAA;QACD,OAAA,OAAA,MAAA,CAAA;YACE,OAAO,EAAE,IAAI,CAAC,iBAAiB,CAC7B;gBACE,OAAO,EAAE,IAAI,CAAC,WAAW;gBACzB,WAAW,EAAE,kBAAkB;gBAC/B,gBAAgB,EAAE,UAAiB;gBACnC,YAAY,EAAE,IAAI,CAAC,MAAM;gBACzB,eAAe,EAAE,IAAI,CAAC,eAAe;aACtC,EACD,WAAW,CAAC,OAAO,CACpB;YACD,SAAS,EAAE,WAAW,CAAC,SAAS;QAAA,GAC7B,kBAAkB,EACtB;IACH,CAAC;IAEO,iBAAiB,CAAC,IAA6B,EAAE,QAAyC,EAAA;QAChG,MAAM,SAAS,GAAG,QAAQ,IAAI,+NAAoB,CAAA;QAClD,IAAI,IAAI,CAAC,mBAAmB,CAAC,MAAM,EAAE;YACnC,MAAM,SAAS,GAAG,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAG,CAAD,CAAG,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAmB,CAAA;YACnG,IAAI,SAAS,CAAC,MAAM,EAAE;gBACpB,WAAO,6OAAoB,EAAC,SAAS,EAAE,SAAS,CAAC,CAAA;aAClD;SACF;QACD,OAAO,SAAS,CAAA;IAClB,CAAC;IAEO,qBAAqB,CAC3B,WAA+B,EAC/B,UAA6C,EAAA;;QAE7C,MAAM,cAAc,GAAG,IAAI,CAAC,iBAAiB,CAAC,CAAA,KAAA,CAAA,KAAA,UAAU,CAAC,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,KAAK,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,MAAM,EAAE,OAAO,CAAC,CAAA;QAC5F,MAAM,EAAE,SAAS,EAAE,QAAQ,EAAE,OAAG,wPAAc,EAAC,WAAW,CAAC,IAAI,CAAC,CAAA;QAChE,MAAM,SAAS,OAAG,0PAAgB,EAAC,cAAc,EAAE,QAAQ,EAAE,WAAW,CAAC,QAAQ,CAAC,CAAA;QAClF,OAAO;YACL,IAAI,MAAE,6PAAmB,EACvB,IAAI,CAAC,YAAY,CAAC,SAA8B,CAAC,EACjD,SAAS,CACU;YACrB,YAAY,EAAE,WAAW,CAAC,OAAO;YACjC,WAAW,EAAE,WAAW,CAAC,WAAW;YACpC,UAAU,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACL,WAAW,CAAC,UAAU,GAAA;gBACzB,KAAK,EAAE,CAAA,KAAA,CAAA,KAAA,WAAW,CAAC,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,KAAK,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,CAAA,CAAE;YAAA,EAC3C;SACF,CAAA;IACH,CAAC;IAEO,SAAS,CACf,IAAgB,EAChB,UAA0E,EAC1E,SAAiB,EAAA;;QAEjB,MAAM,OAAO,GAAkC,CAAA,CAAE,CAAA;QACjD,KAAK,MAAM,CAAC,OAAO,EAAE,GAAG,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAE;YACjD,MAAM,cAAc,GAAG,IAAI,CAAC,iBAAiB,CAAC,CAAA,KAAA,CAAA,KAAA,UAAU,CAAC,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,KAAK,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,MAAM,EAAE,OAAO,CAAC,CAAA;YAC5F,IAAI,WAAW,GAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,OACV,8PAAoB,EAAC,GAAG,CAAC,CAAC,KAAK,GAAA;gBAClC,SAAS;gBACT,OAAO;gBACP,UAAU,EAAE,UAAU,CAAC,IAAI;gBAC3B,SAAS,EAAE,KAAK;YAAA,EACjB,CAAA;YACD,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,WAAW,CAAE;gBACvC,MAAM,MAAM,GAAG,QAAQ,CAAC,WAAW,CAAC,CAAA;gBACpC,IAAI,MAAM,IAAI,IAAI,EAAE;oBAClB,WAAW,GAAG,MAAM,CAAA;iBACrB;aACF;YACD,MAAM,EAAE,SAAS,EAAE,QAAQ,EAAE,OAAG,wPAAc,EAAC,WAAW,CAAC,IAAI,CAAC,CAAA;YAChE,MAAM,SAAS,OAAG,0PAAgB,EAAC,cAAc,EAAE,QAAQ,CAAC,CAAA;YAC5D,OAAO,CAAC,OAAO,CAAC,GAAG;gBACjB,IAAI,MAAE,6PAAmB,EACvB,IAAI,CAAC,YAAY,CAAC,SAA8B,CAAC,EACjD,SAAS,CACU;gBACrB,WAAW,EAAE,WAAW,CAAC,WAAW;gBACpC,YAAY,EAAE,WAAW,CAAC,OAAO;gBACjC,UAAU,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACL,WAAW,CAAC,UAAU,GAAA;oBACzB,KAAK,EAAE,CAAA,KAAA,CAAA,KAAA,WAAW,CAAC,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,KAAK,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,CAAA,CAAE;gBAAA,EAC3C;aACF,CAAA;SACF;QACD,OAAO,OAAO,CAAA;IAChB,CAAC;IAEO,YAAY,CAAC,IAAyC,EAAA;QAC5D,MAAM,IAAI,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAA;QACtC,IAAI,KAAC,wNAAe,EAAC,IAAI,CAAC,EAAE;YAC1B,wBAAA,EAA0B,CAC1B,MAAM,IAAI,KAAK,CAAC,CAAA,SAAA,EAAY,IAAI,CAAA,6BAAA,EAAgC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAA,CAAA,EAAI,IAAI,CAAC,IAAI,CAAA,CAAA,CAAG,CAAC,CAAA;SACvG;QACD,OAAO,IAAI,CAAA;IACb,CAAC;IAEO,YAAY,CAClB,iBAAoC,EAAA;QAEpC,MAAM,cAAc,OAAG,yOAAiB,EAAC,iBAAiB,CAAC,CAAA;QAC3D,MAAM,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,cAAc,CAAC,CAAA;QACvD,IAAI,KAAC,0NAAiB,EAAC,WAAW,CAAC,IAAI,KAAC,mNAAU,EAAC,WAAW,CAAC,EAAE;YAC/D,wBAAA,EAA0B,CAC1B,MAAM,IAAI,KAAK,CACb,CAAA,SAAA,EAAY,cAAc,CAAA,kCAAA,EAAqC,WAAW,CAAC,WAAW,CAAC,IAAI,CAAA,CAAA,EAAI,WAAW,CAAC,IAAI,CAAA,CAAA,CAAG,CACnH,CAAA;SACF;QACD,OAAO,WAAW,CAAA;IACpB,CAAC;IAEO,aAAa,CACnB,kBAAsC,EAAA;QAEtC,MAAM,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,kBAAkB,CAAC,CAAA;QAC3D,IAAI,KAAC,qNAAY,EAAC,WAAW,CAAC,EAAE;YAC9B,wBAAA,EAA0B,CAC1B,MAAM,IAAI,KAAK,CACb,CAAA,SAAA,EAAY,kBAAkB,CAAA,gCAAA,EAAmC,WAAW,CAAC,WAAW,CAAC,IAAI,EAAE,CAChG,CAAA;SACF;QACD,OAAO,WAAW,CAAA;IACpB,CAAC;IAEO,aAAa,CAAC,IAAyC,EAAA;QAC7D,QAAI,6PAAmB,EAAC,IAAI,CAAC,EAAE;YAC7B,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;SACrC;QACD,MAAM,IAAI,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAA;QACtC,IAAI,KAAC,qNAAY,EAAC,IAAI,CAAC,EAAE;YACvB,wBAAA,EAA0B,CAC1B,MAAM,IAAI,KAAK,CAAC,CAAA,SAAA,EAAY,IAAI,CAAA,yBAAA,EAA4B,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC,CAAA;SACrF;QACD,OAAO,IAAI,CAAA;IACb,CAAC;IAEO,cAAc,CACpB,IAAuD,EACvD,aAAsB,KAAK,EAAA;;YAE3B,sOAAc,EAAC,IAAI,CAAC,CAAA;QAEpB,QAAI,oNAAW,EAAC,IAAI,CAAC,EAAE;YACrB,OAAO,IAAI,CAAA;SACZ;QAED,QAAI,6PAAmB,EAAC,IAAI,CAAC,EAAE;YAC7B,OAAO,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAA;SAC5C;QAED,IAAI,OAAO,CAAC,IAAI,CAAC,EAAE;YACjB,OAAO,OAAO,CAAC,IAAI,CAAC,CAAA;SACrB;QACD,IAAI,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE;YAC3B,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAA;SAC/B;QACD,IAAI,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;YAChC,wBAAA,EAA0B,CAC1B,MAAM,IAAI,KAAK,CACb,CAAA,kEAAA,EAAqE,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,EAAE,CACtG,CAAA;SACF;QACD,MAAM,WAAW,GACf,CAAA,KAAA,CAAA,KAAA,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAA;QAEjG,QAAI,6PAAmB,EAAC,WAAW,CAAC,EAAE;YACpC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,CAAA;YACxC,QAAI,8PAAoB,EAAC,WAAW,CAAC,EAAE;gBACrC,OAAO,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,KAAK,CAAC,CAAA;aAC/C,MAAM,QAAI,iQAAuB,EAAC,WAAW,CAAC,EAAE;gBAC/C,OAAO,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,KAAK,CAAC,CAAA;aAClD,MAAM,QAAI,4PAAkB,EAAC,WAAW,CAAC,EAAE;gBAC1C,OAAO,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,KAAK,CAAC,CAAA;aAC7C,MAAM,QAAI,8PAAoB,EAAC,WAAW,CAAC,EAAE;gBAC5C,OAAO,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,KAAK,CAAC,CAAA;aAC/C,MAAM,QAAI,mQAAyB,EAAC,WAAW,CAAC,EAAE;gBACjD,OAAO,IAAI,CAAC,oBAAoB,CAAC,WAAW,CAAC,KAAK,CAAC,CAAA;aACpD,MAAM,QAAI,6PAAmB,EAAC,WAAW,CAAC,EAAE;gBAC3C,OAAO,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,KAAK,CAAC,CAAA;aAC9C,MAAM;gBACL,OAAO,CAAC,IAAI,CAAC,6EAA6E,EAAE,IAAI,CAAC,CAAA;aAClG;SACF;QACD,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,UAAU,CAAC,CAAA;IAC3C,CAAC;IAEO,aAAa,CAA6B,GAAM,EAAA;QACtD,MAAM,eAAe,GAAG,IAAI,sQAAoB,CAAC;YAC/C,QAAQ,EAAE,GAAG,CAAC,IAAI;YAClB,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAG,CAAD,GAAK,CAAC,2BAA2B,CAAC,CAAC,CAAC;YACpD,qBAAqB,EAAE,CAAC,KAAK,EAAE,QAAQ,EAAE,CAAG,CAAD,GAAK,CAAC,qBAAqB,CAAC,KAAK,EAAE,QAAQ,CAAC;YACvF,IAAI,EAAE,GAAG,EAAI,AAAF,CAAG;SACf,CAAC,CAAA;QACF,GAAG,CAAC,UAAU,CAAC,eAAe,CAAC,CAAA;QAC/B,OAAO,GAAG,CAAA;IACZ,CAAC;IAEO,qBAAqB,CAAC,KAAgC,EAAE,QAA0B,EAAA;YACxF,+NAAO,EAAC,IAAI,CAAC,kBAAkB,EAAE,CAAC,GAAG,EAAE,UAAU,EAAE,EAAE;YACnD,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;gBAC3B,OAAO,IAAI,CAAC,eAAe,CAAC,UAAU,EAAE,GAAG,EAAE,KAAK,CAAC,CAAA;aACpD;YACD,aAAa;YACb,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,IAAW,EAAE,EAAE;gBACrC,OAAO,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC;oBACvB,IAAI;oBACJ,OAAO,EAAE,KAAK;oBACd,OAAO,EAAE,IAAI,CAAC,WAAW;oBACzB,QAAQ,EAAE,KAAK,CAAC,QAAQ;oBACxB,QAAQ;iBACT,CAAC,CAAA;YACJ,CAAC,CAAA;QACH,CAAC,CAAC,CAAA;IACJ,CAAC;IAEO,uBAAuB,CAC7B,KAAiC,EACjC,KAAuB,EACvB,QAA0B,EAAA;YAE1B,+NAAO,EAAC,IAAI,CAAC,mBAAmB,EAAE,CAAC,GAAG,EAAE,UAAU,EAAE,EAAE;YACpD,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;gBAC3B,OAAO,IAAI,CAAC,eAAe,CAAC,UAAU,EAAE,GAAG,EAAE,KAAK,CAAC,CAAA;aACpD;YACD,aAAa;YACb,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,IAAW,EAAE,EAAE;gBACrC,OAAO,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC;oBACvB,IAAI;oBACJ,OAAO,EAAE,KAAK;oBACd,OAAO,EAAE,IAAI,CAAC,WAAW;oBACzB,QAAQ,EAAE,KAAK,CAAC,QAAQ;oBACxB,KAAK;oBACL,QAAQ;iBACT,CAAC,CAAA;YACJ,CAAC,CAAA;QACH,CAAC,CAAC,CAAA;YACF,+NAAO,EAAC,IAAI,CAAC,uBAAuB,EAAE,CAAC,GAAG,EAAE,YAAY,EAAE,EAAE;YAC1D,MAAM,CAAC,cAAc,CAAC,KAAK,EAAE,YAAY,EAAE;gBACzC,GAAG;oBACD,OAAO,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC;wBACvB,OAAO,EAAE,KAAK;wBACd,OAAO,EAAE,IAAI,CAAC,WAAW;wBACzB,QAAQ,EAAE,KAAK,CAAC,QAAQ;wBACxB,KAAK;qBACN,CAAC,CAAA;gBACJ,CAAC;gBACD,UAAU,EAAE,IAAI;aACjB,CAAC,CAAA;QACJ,CAAC,CAAC,CAAA;IACJ,CAAC;IAEO,eAAe,CACrB,UAAkB,EAClB,QAAgB,EAChB,KAA6D,EAAA;QAE7D,aAAa;QACb,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,SAAiB,EAAE,IAAS,EAAE,EAAE;YACnD,IAAI,WAAW,GAAG;gBAChB,IAAI,EAAE,QAAQ;aACf,CAAA;YAED,sBAAA,EAAwB,CACxB,IAAI,OAAO,IAAI,KAAK,UAAU,EAAE;gBAC9B,MAAM,IAAI,KAAK,CAAC,mOAAQ,CAAC,wBAAwB,CAAC,KAAK,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC,CAAA;aAC9E,MAAM;gBACL,WAAW,GAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAQ,WAAW,GAAK,IAAI,CAAE,CAAA;aAC1C;YAED,aAAa;YACb,KAAK,CAAC,KAAK,CAAC,SAAS,EAAE,WAAW,CAAC,CAAA;QACrC,CAAC,CAAA;IACH,CAAC;IAEO,cAAc,CAA8B,GAAM,EAAA;QACxD,MAAM,eAAe,GAAG,IAAI,iQAAqB,CAAC;YAChD,QAAQ,EAAE,GAAG,CAAC,IAAI;YAClB,aAAa,EAAE,CAAC,CAAC,EAAE,EAAE;gBACnB,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE;oBACd,IAAI,OAAO,CAAC,KAAK,QAAQ,EAAE;wBACzB,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAA;qBAChB;gBACH,CAAC,CAAC,CAAA;YACJ,CAAC;YACD,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAG,CAAD,GAAK,CAAC,4BAA4B,CAAC,CAAC,CAAC;YACrD,uBAAuB,EAAE,CAAC,KAAK,EAAE,QAAQ,EAAE,CAAG,CAAD,GAAK,CAAC,uBAAuB,CAAC,KAAK,EAAE,MAAM,EAAE,QAAQ,CAAC;YACnG,eAAe,EAAE,CAAC,CAAC,EAAE,CAAG,CAAD,GAAK,CAAC,yBAAyB,CAAC,CAAC,CAAC;YACzD,IAAI,EAAE,GAAG,EAAE,AAAE,CAAC;SACf,CAAC,CAAA;QACF,GAAG,CAAC,UAAU,CAAC,eAAe,CAAC,CAAA;QAC/B,OAAO,GAAG,CAAA;IACZ,CAAC;IAEO,iBAAiB,CAAC,GAAkC,EAAA;QAC1D,MAAM,eAAe,GAAG,IAAI,uQAAwB,CAAC;YACnD,QAAQ,EAAE,GAAG,CAAC,IAAI;YAClB,eAAe,EAAE,CAAC,CAAC,EAAE,CAAG,CAAD,GAAK,CAAC,yBAAyB,CAAC,CAAC,CAAC;YACzD,aAAa,EAAE,CAAC,CAAC,EAAE,EAAE;gBACnB,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE;oBACd,IAAI,OAAO,CAAC,KAAK,QAAQ,EAAE;wBACzB,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAA;qBAChB;gBACH,CAAC,CAAC,CAAA;YACJ,CAAC;YACD,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAG,CAAD,GAAK,CAAC,4BAA4B,CAAC,CAAC,CAAC;YACrD,uBAAuB,EAAE,CAAC,KAAK,EAAE,QAAQ,EAAE,CAAG,CAAD,GAAK,CAAC,uBAAuB,CAAC,KAAK,EAAE,MAAM,EAAE,QAAQ,CAAC;YACnG,IAAI,EAAE,GAAG,EAAE,AAAE,CAAC;SACf,CAAC,CAAA;QACF,GAAG,CAAC,UAAU,CAAC,eAAe,CAAC,CAAA;QAC/B,OAAO,GAAG,CAAA;IACZ,CAAC;IAEO,yBAAyB,CAAC,GAAmC,EAAA;QACnE,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG,GAAG,CAAA;QAC1B,IAAI,IAAI,EAAE;YACR,MAAM,cAAc,OAAG,yOAAiB,EAAC,GAAG,CAAC,IAAI,CAAC,CAAA;YAClD,IAAI,OAAO,cAAc,KAAK,QAAQ,EAAE;gBACtC,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,CAAA;aAC7B;SACF;QACD,IAAI,IAAI,EAAE;YACR,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAA;SACxB;IACH,CAAC;IAEO,4BAA4B,CAAC,IAAyB,EAAA;QAC5D,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,SAAS,EAAE,GAAG,IAAI,CAAA;QACtC,MAAM,cAAc,OAAG,yOAAiB,EAAC,SAAS,CAAC,CAAA;QACnD,IAAI,OAAO,cAAc,KAAK,QAAQ,EAAE;YACtC,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,CAAA;SAC7B;QACD,IAAI,IAAI,EAAE;YACR,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAA;SACxB;IACH,CAAC;IAEO,YAAY,CAAC,IAAsC,EAAA;YACzD,+NAAO,EAAC,IAAI,EAAE,CAAC,GAAG,EAAE,EAAE;YACpB,MAAM,YAAY,OAAG,uOAAe,EAAC,GAAG,CAAC,CAAA;YACzC,IAAI,OAAO,YAAY,KAAK,QAAQ,EAAE;gBACpC,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,CAAA;aAC3B;QACH,CAAC,CAAC,CAAA;IACJ,CAAC;IAEO,2BAA2B,CAAC,IAAwB,EAAA;QAC1D,MAAM,EAAE,IAAI,EAAE,SAAS,EAAE,GAAG,IAAI,CAAA;QAChC,MAAM,cAAc,OAAG,yOAAiB,EAAC,SAAS,CAAC,CAAA;QACnD,IAAI,OAAO,cAAc,KAAK,QAAQ,EAAE;YACtC,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,CAAA;SAC7B;IACH,CAAC;IAED;;;;;OAKG,CACK,iBAAiB,CAAC,MAAyB,EAAA;;QACjD,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAA;QAC1C,MAAM,WAAW,GAA0C,CAAA,CAAE,CAAA;QAE7D,kEAAkE;QAClE,oCAAoC;QACpC,KAAK,MAAM,IAAI,IAAI,KAAK,CAAE;YACxB,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;gBAC9B,SAAQ;aACT;YACD,IAAI,CAAA,KAAA,MAAM,CAAC,SAAS,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;gBACzC,SAAQ;aACT;YACD,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,MAAM,CAAC,CAAA;SAC7D;QACD,OAAO,WAAW,CAAA;IACpB,CAAC;IAEO,gBAAgB,CAAC,IAAiB,EAAE,MAAqB,EAAA;;;QAC/D,UAAO,uNAAc,EAAC,IAAI,CAAC,CAAE;YAC3B,IAAI,GAAG,IAAI,CAAC,MAAM,CAAA;SACnB;QACD,CAAA,KAAA,CAAA,KAAA,IAAI,CAAC,cAAc,CAAA,CAAA,KAAC,IAAI,CAAC,IAAI,CAAA,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,EAAA,CAAA,GAAA,GAAM,IAAI,EAAA;QACvC,WAAO,8OAAgB,EAAC,IAAI,EAAE,MAAM,CAAC,CAAA;IACvC,CAAC;CACF;AAED,SAAS,WAAW,CAAC,IAAY;IAC/B,OAAO,IAAI,KAAK,CAAC,GAAG,IAAI,CAAA,+EAAA,CAAiF,CAAC,CAAA;AAC5G,CAAC;AAiBK,SAAU,kBAAkB,CAAC,MAAoB;IACrD,MAAM,OAAO,GAAG,IAAI,aAAa,CAAC,MAAM,CAAC,CAAA;IACzC,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAA;IAC9B,IAAI,MAAM,CAAC,WAAW,EAAE;QACtB,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,WAAW,CAAC,CAAA;KACrC;IACD,MAAM,EAAE,WAAW,EAAE,OAAO,EAAE,YAAY,EAAE,eAAe,EAAE,eAAe,EAAE,GAAG,OAAO,CAAC,eAAe,EAAE,CAAA;IAE1G,SAAS,WAAW,CAAC,QAA+C,EAAE,WAAmB;;QACvF,MAAM,WAAW,GAAG,CAAA,KAAA,CAAA,KAAA,MAAM,CAAC,WAAW,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,EAAA,CAAG,QAAQ,CAAC,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,WAAW,CAAA;QACjE,IAAI,SAAS,GAA4B,IAAI,CAAA;QAC7C,IAAI,OAAO,WAAW,KAAK,QAAQ,EAAE;YACnC,SAAS,GAAG,OAAO,CAAC,WAAW,CAAC,CAAA;SACjC,MAAM,IAAI,WAAW,EAAE;YACtB,QAAI,8PAAoB,EAAC,WAAW,CAAC,EAAE;gBACrC,SAAS,GAAG,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAA;aACtC,MAAM,QAAI,qNAAY,EAAC,WAAW,CAAC,EAAE;gBACpC,SAAS,GAAG,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAA;aACtC;SACF;QACD,IAAI,SAAS,IAAI,KAAC,qNAAY,EAAC,SAAS,CAAC,EAAE;YACzC,MAAM,IAAI,KAAK,CAAC,CAAA,SAAA,EAAY,QAAQ,CAAA,yBAAA,EAA4B,SAAS,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC,CAAA;SAC9F;QACD,OAAO,SAAS,CAAA;IAClB,CAAC;IAED,MAAM,MAAM,GAAG,IAAI,kNAAa,CAAC;QAC/B,KAAK,EAAE,WAAW,CAAC,OAAO,EAAE,OAAO,CAAC;QACpC,QAAQ,EAAE,WAAW,CAAC,UAAU,EAAE,UAAU,CAAC;QAC7C,YAAY,EAAE,WAAW,CAAC,cAAc,EAAE,cAAc,CAAC;QACzD,KAAK,MAAE,iOAAS,EAAC,OAAO,CAAC;QACzB,UAAU,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACL,MAAM,CAAC,UAAU,GAAA;YACpB,KAAK,EAAE,eAAe;QAAA,EACvB;KACF,CAAuB,CAAA;IAExB,eAAe,CAAC,OAAO,CAAC,CAAC,EAAE,EAAE,CAAG,CAAD,CAAG,CAAC,MAAM,CAAC,CAAC,CAAA;IAE3C,OAAO;QAAE,MAAM;QAAE,YAAY;QAAE,WAAW;IAAA,CAAE,CAAA;AAC9C,CAAC;AAEK,SAAU,iBAAiB,CAAC,MAA0B;;IAC1D,MAAM,QAAQ,GAIV;QACF,QAAQ,EAAE;YACR,yBAAyB,EAAE,IAAI;YAC/B,sBAAsB,EAAE;gBACtB,QAAQ,EAAE,KAAK;gBACf,WAAW,EAAE,IAAI;gBACjB,UAAU,EAAE,KAAK;aAClB;SACF;QACD,eAAe,EAAE;YACf,KAAK,EAAE,KAAK;YACZ,MAAM,EAAE,KAAK;SACd;QACD,OAAO,EAAE;gBAAC,sQAAoB,EAAE;SAAC;KAClC,CAAA;IAED,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE;QACpB,MAAM,CAAC,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAA;KACpC,MAAM;QACL,yBAAyB;QAEzB,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,sBAAsB,EAAE;YAC3C,MAAM,CAAC,QAAQ,CAAC,sBAAsB,GAAG,QAAQ,CAAC,QAAQ,CAAC,sBAAsB,CAAA;SAClF,MAAM;YACL,MAAM,CAAC,QAAQ,CAAC,sBAAsB,CAAC,UAAU,GAC/C,CAAA,KAAA,MAAM,CAAC,QAAQ,CAAC,sBAAsB,CAAC,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,KAAK,CAAA;YAC5D,MAAM,CAAC,QAAQ,CAAC,sBAAsB,CAAC,QAAQ,GAC7C,CAAA,KAAA,MAAM,CAAC,QAAQ,CAAC,sBAAsB,CAAC,QAAQ,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,KAAK,CAAA;YAC1D,MAAM,CAAC,QAAQ,CAAC,sBAAsB,CAAC,WAAW,GAChD,CAAA,KAAA,MAAM,CAAC,QAAQ,CAAC,sBAAsB,CAAC,WAAW,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,KAAK,CAAA;SAC9D;QAED,4BAA4B;QAC5B,IAAI,MAAM,CAAC,QAAQ,CAAC,sBAAsB,CAAC,UAAU,KAAK,IAAI,EAAE;YAC9D,0FAA0F;YAC1F,8FAA8F;YAC9F,8BAA8B;YAC9B,MAAM,CAAC,QAAQ,CAAC,yBAAyB,GAAG,KAAK,CAAA;SAClD;QACD,IAAI,MAAM,CAAC,QAAQ,CAAC,yBAAyB,KAAK,SAAS,EAAE;YAC3D,MAAM,CAAC,QAAQ,CAAC,yBAAyB,GAAG,QAAQ,CAAC,QAAQ,CAAC,yBAAyB,CAAA;SACxF;KACF;IAED,MAAM,CAAC,OAAO,GAAG,CAAA,KAAA,MAAM,CAAC,OAAO,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,EAAE,CAAA;IACrC,MAAM,CAAC,eAAe,GAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACjB,QAAQ,CAAC,eAAe,GACxB,AAAC,CAAA,KAAA,MAAM,CAAC,eAAe,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,CAAA,CAAE,CAAC,CAClC,CAAA;IAED,OAAO,MAAuB,CAAA;AAChC,CAAC"}},
    {"offset": {"line": 4696, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/lang.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/lang.ts"],"sourcesContent":["export const SDL_HEADER = `### This file was generated by Nexus Schema\n### Do not make changes to this file directly\n`\n\nexport const TYPEGEN_HEADER = `/**\n * This file was generated by Nexus Schema\n * Do not make changes to this file directly\n */\n`\n\nexport const TYPEGEN_CONFIG_WARNING = `/**\n * For better typings, you should provide configuration for how to lookup \n * the types. See the documentation for \"typegenAutoConfig\"\n */\n`\n"],"names":[],"mappings":";;;;;;;;AAAO,MAAM,UAAU,GAAG,CAAA;;CAEzB,CAAA;AAEM,MAAM,cAAc,GAAG,CAAA;;;;CAI7B,CAAA;AAEM,MAAM,sBAAsB,GAAG,CAAA;;;;CAIrC,CAAA"}},
    {"offset": {"line": 4721, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/typegenAutoConfig.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/typegenAutoConfig.ts"],"sourcesContent":["import { GraphQLNamedType, GraphQLSchema, isOutputType } from 'graphql'\nimport * as path from 'path'\nimport type { TypegenInfo } from './builder'\nimport type { TypingImport } from './definitions/_types'\nimport { TYPEGEN_HEADER } from './lang'\nimport { getOwnPackage, log, objValues, relativePathTo, typeScriptFileExtension } from './utils'\n\n/** Any common types / constants that would otherwise be circular-imported */\nexport const SCALAR_TYPES = {\n  Int: 'number',\n  String: 'string',\n  ID: 'string',\n  Float: 'number',\n  Boolean: 'boolean',\n}\n\nexport interface SourceTypeModule {\n  /**\n   * The module for where to look for the types. This uses the node resolution algorithm via require.resolve,\n   * so if this lives in node_modules, you can just provide the module name otherwise you should provide the\n   * absolute path to the file.\n   */\n  module: string\n  /**\n   * When we import the module, we use `import * as ____` to prevent conflicts. This alias should be a name\n   * that doesn't conflict with any other types, usually a short lowercase name.\n   */\n  alias: string\n  /**\n   * Provides a custom approach to matching for the type\n   *\n   * If not provided, the default implementation is:\n   *\n   * (type) => [ new RegExp(`(?:interface|type|class|enum)\\\\s+(${type.name})\\\\W`, \"g\"), ]\n   */\n  typeMatch?: (type: GraphQLNamedType, defaultRegex: RegExp) => RegExp | RegExp[]\n  /**\n   * A list of typesNames or regular expressions matching type names that should be resolved by this import.\n   * Provide an empty array if you wish to use the file for context and ensure no other types are matched.\n   */\n  onlyTypes?: (string | RegExp)[]\n  /**\n   * By default the import is configured `import * as alias from`, setting glob to false will change this to\n   * `import alias from`\n   */\n  glob?: false\n}\n\nexport interface SourceTypesConfigOptions {\n  /** Any headers to prefix on the generated type file */\n  headers?: string[]\n  /**\n   * Array of SourceTypeModule's to look in and match the type names against.\n   *\n   * @example\n   *   modules: [\n   *     { module: 'typescript', alias: 'ts' },\n   *     { module: path.join(__dirname, '../sourceTypes'), alias: 'b' },\n   *   ]\n   */\n  modules: SourceTypeModule[]\n  /**\n   * Types that should not be matched for a source type,\n   *\n   * By default this is set to ['Query', 'Mutation', 'Subscription']\n   *\n   * @example\n   *   skipTypes: ['Query', 'Mutation', /(.*?)Edge/, /(.*?)Connection/]\n   */\n  skipTypes?: (string | RegExp)[]\n  /**\n   * If debug is set to true, this will log out info about all types found, skipped, etc. for the type\n   * generation files. @default false\n   */\n  debug?: boolean\n  /**\n   * If provided this will be used for the source types rather than the auto-resolve mechanism above. Useful\n   * as an override for one-off cases, or for scalar source types.\n   */\n  mapping?: Record<string, string>\n}\n\n/**\n * This is an approach for handling type definition auto-resolution. It is designed to handle the most common\n * cases, as can be seen in the examples / the simplicity of the implementation.\n *\n * If you wish to do something more complex, involving full AST parsing, etc, you can provide a different\n * function to the `typegenInfo` property of the `makeSchema` config.\n *\n * @param options\n */\nexport function typegenAutoConfig(options: SourceTypesConfigOptions, contextType: TypingImport | undefined) {\n  return async (schema: GraphQLSchema, outputPath: string): Promise<TypegenInfo> => {\n    const {\n      headers,\n      skipTypes = ['Query', 'Mutation', 'Subscription'],\n      mapping: _sourceTypeMap,\n      debug,\n    } = options\n\n    const typeMap = schema.getTypeMap()\n    const typesToIgnore = new Set<string>()\n    const typesToIgnoreRegex: RegExp[] = []\n    const allImportsMap: Record<string, string> = {}\n    const importsMap: Record<string, [string, boolean]> = {}\n\n    const sourceTypeMap: Record<string, string> = {\n      ...SCALAR_TYPES,\n      ..._sourceTypeMap,\n    }\n\n    const forceImports = new Set(\n      objValues(sourceTypeMap)\n        .concat(typeof contextType === 'string' ? contextType || '' : '')\n        .map((t) => {\n          const match = t.match(/^(\\w+)\\./)\n          return match ? match[1] : null\n        })\n        .filter((f) => f)\n    )\n\n    skipTypes.forEach((skip) => {\n      if (typeof skip === 'string') {\n        typesToIgnore.add(skip)\n      } else if (skip instanceof RegExp) {\n        typesToIgnoreRegex.push(skip)\n      } else {\n        throw new Error('Invalid type for options.skipTypes, expected string or RegExp')\n      }\n    })\n\n    const typeSources = await Promise.all(\n      options.modules.map(async (source) => {\n        // Keeping all of this in here so if we don't have any sources\n        // e.g. in the Playground, it doesn't break things.\n\n        // Yeah, this doesn't exist in Node 6, but since this is a new\n        // lib and Node 6 is close to EOL so if you really need it, open a PR :)\n        const fs = require('fs') as typeof import('fs')\n        const util = require('util') as typeof import('util')\n        const readFile = util.promisify(fs.readFile)\n        const { module: pathOrModule, glob = true, onlyTypes, alias, typeMatch } = source\n        if (path.isAbsolute(pathOrModule) && path.extname(pathOrModule) !== '.ts') {\n          return console.warn(\n            `Nexus Schema Typegen: Expected module ${pathOrModule} to be an absolute path to a TypeScript module, skipping.`\n          )\n        }\n        let resolvedPath: string\n        let fileContents: string\n        try {\n          resolvedPath = require.resolve(pathOrModule, {\n            paths: [process.cwd()],\n          })\n          if (path.extname(resolvedPath) !== '.ts') {\n            resolvedPath = findTypingForFile(resolvedPath, pathOrModule)\n          }\n          fileContents = await readFile(resolvedPath, 'utf-8')\n        } catch (e) {\n          if (e instanceof Error && e.message.indexOf('Cannot find module') !== -1) {\n            console.error(`GraphQL Nexus: Unable to find file or module ${pathOrModule}, skipping`)\n          } else {\n            console.error(e.message)\n          }\n          return null\n        }\n\n        const importPath = (\n          path.isAbsolute(pathOrModule) ? relativePathTo(resolvedPath, outputPath) : pathOrModule\n        ).replace(typeScriptFileExtension, '')\n\n        if (allImportsMap[alias] && allImportsMap[alias] !== importPath) {\n          return console.warn(\n            `Nexus Schema Typegen: Cannot have multiple type sources ${importsMap[alias]} and ${pathOrModule} with the same alias ${alias}, skipping`\n          )\n        }\n        allImportsMap[alias] = importPath\n\n        if (forceImports.has(alias)) {\n          importsMap[alias] = [importPath, glob]\n          forceImports.delete(alias)\n        }\n\n        return {\n          alias,\n          glob,\n          importPath,\n          fileContents,\n          onlyTypes,\n          typeMatch: typeMatch || defaultTypeMatcher,\n        }\n      })\n    )\n\n    const builtinScalars = new Set(Object.keys(SCALAR_TYPES))\n\n    Object.keys(typeMap).forEach((typeName) => {\n      if (typeName.startsWith('__')) {\n        return\n      }\n      if (typesToIgnore.has(typeName)) {\n        return\n      }\n      if (typesToIgnoreRegex.some((r) => r.test(typeName))) {\n        return\n      }\n      if (sourceTypeMap[typeName]) {\n        return\n      }\n      if (builtinScalars.has(typeName)) {\n        return\n      }\n\n      const type = schema.getType(typeName)\n\n      // For now we'll say that if it's output type it can be backed\n      if (isOutputType(type)) {\n        for (let i = 0; i < typeSources.length; i++) {\n          const typeSource = typeSources[i]\n          if (!typeSource) {\n            continue\n          }\n          // If we've specified an array of \"onlyTypes\" to match ensure the\n          // `typeName` falls within that list.\n          if (typeSource.onlyTypes) {\n            if (\n              !typeSource.onlyTypes.some((t) => {\n                return t instanceof RegExp ? t.test(typeName) : t === typeName\n              })\n            ) {\n              continue\n            }\n          }\n          const { fileContents, importPath, glob, alias, typeMatch } = typeSource\n          const typeRegex = typeMatch(type, defaultTypeMatcher(type)[0])\n          const matched = firstMatch(fileContents, Array.isArray(typeRegex) ? typeRegex : [typeRegex])\n          if (matched) {\n            if (debug) {\n              log(`Matched type - ${typeName} in \"${importPath}\" - ${alias}.${matched[1]}`)\n            }\n            importsMap[alias] = [importPath, glob]\n            sourceTypeMap[typeName] = `${alias}.${matched[1]}`\n          } else {\n            if (debug) {\n              log(`No match for ${typeName} in \"${importPath}\" using ${typeRegex}`)\n            }\n          }\n        }\n      }\n    })\n\n    if (forceImports.size > 0) {\n      console.error(`Missing required typegen import: ${Array.from(forceImports)}`)\n    }\n\n    const imports: string[] = []\n\n    Object.keys(importsMap)\n      .sort()\n      .forEach((alias) => {\n        const [importPath, glob] = importsMap[alias]\n        const safeImportPath = importPath.replace(/\\\\+/g, '/')\n        imports.push(`import type ${glob ? '* as ' : ''}${alias} from \"${safeImportPath}\"`)\n      })\n\n    const typegenInfo = {\n      headers: headers || [TYPEGEN_HEADER],\n      sourceTypeMap,\n      imports,\n      contextTypeImport: contextType,\n      nexusSchemaImportId: getOwnPackage().name,\n    }\n\n    return typegenInfo\n  }\n}\n\nfunction findTypingForFile(absolutePath: string, pathOrModule: string) {\n  // First try to find the \"d.ts\" adjacent to the file\n  try {\n    const typeDefPath = absolutePath.replace(path.extname(absolutePath), '.d.ts')\n    require.resolve(typeDefPath)\n    return typeDefPath\n  } catch (e) {\n    console.error(e)\n  }\n\n  // TODO: need to figure out cases where it's a node module\n  // and \"typings\" is set in the package.json\n\n  throw new Error(`Unable to find typings associated with ${pathOrModule}, skipping`)\n}\n\nconst firstMatch = (fileContents: string, typeRegex: RegExp[]): RegExpExecArray | null => {\n  for (let i = 0; i < typeRegex.length; i++) {\n    const regex = typeRegex[i]\n    const match = regex.exec(fileContents)\n    if (match) {\n      return match\n    }\n  }\n  return null\n}\n\nconst defaultTypeMatcher = (type: GraphQLNamedType) => {\n  return [new RegExp(`(?:interface|type|class|enum)\\\\s+(${type.name})\\\\W`, 'g')]\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4936, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/typegenFormatPrettier.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/typegenFormatPrettier.ts"],"sourcesContent":["import * as path from 'path'\nimport type * as Prettier from 'prettier'\n\nexport type TypegenFormatFn = (content: string, type: 'types' | 'schema') => string | Promise<string>\n\n// todo use Prettier.Options type instead of just `object`\n// but will this force us to make prettier a dep then since that type would be user-visible?\nexport function typegenFormatPrettier(prettierConfig: string | object): TypegenFormatFn {\n  return async function formatTypegen(content: string, type: 'types' | 'schema') {\n    let prettier: typeof import('prettier')\n    /* istanbul ignore next */\n    try {\n      prettier = require('prettier') as typeof import('prettier')\n    } catch {\n      console.warn(\n        'It looks like you provided a `prettierConfig` option to GraphQL Nexus, but you do not have prettier ' +\n          'installed as a dependency in your project. Please add it as a peerDependency of nexus to use this feature. ' +\n          'Skipping formatting.'\n      )\n      return content\n    }\n\n    let prettierConfigResolved: Prettier.Options\n\n    if (typeof prettierConfig === 'string') {\n      /* istanbul ignore if */\n      if (!path.isAbsolute(prettierConfig)) {\n        console.error(\n          new Error(`Expected prettierrc path to be absolute, saw ${prettierConfig}. Skipping formatting.`)\n        )\n        return content\n      }\n      prettierConfigResolved = (await prettier.resolveConfig('ignore_this', {\n        config: prettierConfig,\n      }))! // non-null assert b/c config file is explicitly passed\n    } else {\n      prettierConfigResolved = prettierConfig\n    }\n\n    return prettier.format(content, {\n      ...prettierConfigResolved,\n      parser: type === 'types' ? 'typescript' : 'graphql',\n    })\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA,OAAO,KAAK,IAAI,MAAM,MAAM,CAAA;;;AAOtB,SAAU,qBAAqB,CAAC,cAA+B;IACnE,OAAO,SAAe,aAAa,CAAC,OAAe,EAAE,IAAwB;;YAC3E,IAAI,QAAmC,CAAA;YACvC,wBAAA,EAA0B,CAC1B,IAAI;gBACF,QAAQ,GAAG,OAAO,CAAC,UAAU,CAA8B,CAAA;aAC5D,CAAC,OAAA,IAAM;gBACN,OAAO,CAAC,IAAI,CACV,sGAAsG,GACpG,6GAA6G,GAC7G,sBAAsB,CACzB,CAAA;gBACD,OAAO,OAAO,CAAA;aACf;YAED,IAAI,sBAAwC,CAAA;YAE5C,IAAI,OAAO,cAAc,KAAK,QAAQ,EAAE;gBACtC,sBAAA,EAAwB,CACxB,IAAI,CAAC,IAAI,CAAC,0GAAU,CAAC,cAAc,CAAC,EAAE;oBACpC,OAAO,CAAC,KAAK,CACX,IAAI,KAAK,CAAC,CAAA,6CAAA,EAAgD,cAAc,CAAA,sBAAA,CAAwB,CAAC,CAClG,CAAA;oBACD,OAAO,OAAO,CAAA;iBACf;gBACD,sBAAsB,GAAG,AAAC,MAAM,QAAQ,CAAC,aAAa,CAAC,aAAa,EAAE;oBACpE,MAAM,EAAE,cAAc;iBACvB,CAAC,CAAE,CAAA,AAAC,uDAAuD;aAC7D,MAAM;gBACL,sBAAsB,GAAG,cAAc,CAAA;aACxC;YAED,OAAO,QAAQ,CAAC,MAAM,CAAC,OAAO,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACzB,sBAAsB,GAAA;gBACzB,MAAM,EAAE,IAAI,KAAK,OAAO,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,SAAS;YAAA,GACnD,CAAA;QACJ,CAAC;KAAA,CAAA;AACH,CAAC"}},
    {"offset": {"line": 4976, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/typegenPrinter.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/typegenPrinter.ts"],"sourcesContent":["import {\n  getNamedType,\n  GraphQLAbstractType,\n  GraphQLArgument,\n  GraphQLField,\n  GraphQLInputField,\n  GraphQLInputType,\n  GraphQLInterfaceType,\n  GraphQLNamedType,\n  GraphQLObjectType,\n  GraphQLOutputType,\n  GraphQLScalarType,\n  GraphQLUnionType,\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n  isScalarType,\n  isSpecifiedScalarType,\n  isUnionType,\n} from 'graphql'\nimport type { TypegenInfo } from './builder'\nimport { isNexusPrintedGenTyping, isNexusPrintedGenTypingImport } from './definitions/wrapping'\nimport type { NexusGraphQLSchema } from './definitions/_types'\nimport { TYPEGEN_HEADER } from './lang'\nimport type { StringLike } from './plugin'\nimport { hasNexusExtension } from './extensions'\nimport {\n  eachObj,\n  getOwnPackage,\n  graphql15InterfaceType,\n  GroupedTypes,\n  groupTypes,\n  mapObj,\n  mapValues,\n  PrintedGenTypingImport,\n  relativePathTo,\n  resolveImportPath,\n} from './utils'\n\nconst SpecifiedScalars = {\n  ID: 'string',\n  String: 'string',\n  Float: 'number',\n  Int: 'number',\n  Boolean: 'boolean',\n}\ntype SpecifiedScalarNames = keyof typeof SpecifiedScalars\n\ntype TypeFieldMapping = Record<string, Record<string, [string, string]>>\ntype TypeMapping = Record<string, string>\ntype RootTypeMapping = Record<string, string | Record<string, [string, string]>>\n\ninterface TypegenInfoWithFile extends TypegenInfo {\n  typegenPath: string\n  globalsPath?: string\n  globalsHeaders?: string[]\n  declareInputs?: boolean\n}\n\n/**\n * We track and output a few main things:\n *\n * 1. \"root\" types, or the values that fill the first argument for a given object type 2. \"arg\" types, the\n * values that are arguments to output fields. 3. \"return\" types, the values returned from the resolvers...\n * usually just list/nullable variations on the\n *     \"root\" types for other types 4. The names of all types, grouped by type.\n *\n * - Non-scalar types will get a dedicated \"Root\" type associated with it\n */\nexport class TypegenPrinter {\n  private groupedTypes: GroupedTypes\n  private printImports: Record<string, Record<string, boolean | string>>\n  private hasDiscriminatedTypes: boolean\n\n  constructor(protected schema: NexusGraphQLSchema, protected typegenInfo: TypegenInfoWithFile) {\n    this.groupedTypes = groupTypes(schema)\n    this.printImports = {}\n    this.hasDiscriminatedTypes = false\n  }\n\n  print() {\n    const body = [this.printCommon(), this.printPlugins()].join('\\n\\n')\n    return [this.printHeaders(), body].join('\\n\\n')\n  }\n\n  printConfigured() {\n    if (this.typegenInfo.globalsPath) {\n      const plugins = this.printPlugins()\n      const globalTypes = [this.printHeadersGlobal(), this.printDynamicImport(true), plugins].join('\\n\\n')\n\n      // Reset printImports for the imports needed in the types\n      this.printImports = {}\n\n      const common = this.printCommon()\n      const tsTypes = [this.printHeadersCommon(), common].join('\\n\\n')\n      return {\n        tsTypes,\n        globalTypes,\n      }\n    }\n    return {\n      tsTypes: this.print(),\n      globalTypes: null,\n    }\n  }\n\n  private printCommon() {\n    return [\n      this.printInputTypeMap(),\n      this.printEnumTypeMap(),\n      this.printScalarTypeMap(),\n      this.printObjectTypeMap(),\n      this.printInterfaceTypeMap(),\n      this.printUnionTypeMap(),\n      this.printRootTypeDef(),\n      this.printAllTypesMap(),\n      this.printFieldTypesMap(),\n      this.printFieldTypeNamesMap(),\n      this.printArgTypeMap(),\n      this.printAbstractTypeMembers(),\n      this.printInheritedFieldMap(),\n      this.printTypeNames('object', 'NexusGenObjectNames', 'NexusGenObjects'),\n      this.printTypeNames('input', 'NexusGenInputNames', 'NexusGenInputs'),\n      this.printTypeNames('enum', 'NexusGenEnumNames', 'NexusGenEnums'),\n      this.printTypeNames('interface', 'NexusGenInterfaceNames', 'NexusGenInterfaces'),\n      this.printTypeNames('scalar', 'NexusGenScalarNames', 'NexusGenScalars'),\n      this.printTypeNames('union', 'NexusGenUnionNames', 'NexusGenUnions'),\n      this.printIsTypeOfObjectTypeNames('NexusGenObjectsUsingAbstractStrategyIsTypeOf'),\n      this.printResolveTypeAbstractTypes('NexusGenAbstractsUsingStrategyResolveType'),\n      this.printFeaturesConfig('NexusGenFeaturesConfig'),\n      this.printGenTypeMap(),\n    ].join('\\n\\n')\n  }\n\n  private printHeaders() {\n    return [this.printHeadersCommon(), this.printHeadersGlobal()].join('\\n')\n  }\n\n  private printHeadersCommon() {\n    return [\n      this.typegenInfo.headers.join('\\n'),\n      this.typegenInfo.imports.join('\\n'),\n      this.printDynamicImport(),\n    ].join('\\n')\n  }\n\n  private printHeadersGlobal() {\n    const headers = [\n      this.printDynamicInputFieldDefinitions(),\n      this.printDynamicOutputFieldDefinitions(),\n      this.printDynamicOutputPropertyDefinitions(),\n      GLOBAL_DECLARATION,\n    ]\n\n    if (this.typegenInfo.globalsPath) {\n      headers.unshift(\n        `import type { NexusGenTypes } from '${relativePathTo(\n          this.typegenInfo.typegenPath,\n          this.typegenInfo.globalsPath ?? ''\n        )}'`\n      )\n      headers.unshift(...(this.typegenInfo.globalsHeaders ?? []))\n      headers.unshift(TYPEGEN_HEADER)\n    }\n\n    return headers.join('\\n')\n  }\n\n  private printGenTypeMap() {\n    return [`export interface NexusGenTypes {`]\n      .concat([\n        `  context: ${this.printContext()};`,\n        `  inputTypes: NexusGenInputs;`,\n        `  rootTypes: NexusGenRootTypes;`,\n        `  inputTypeShapes: NexusGenInputs & NexusGenEnums & NexusGenScalars;`,\n        `  argTypes: NexusGenArgTypes;`,\n        `  fieldTypes: NexusGenFieldTypes;`,\n        `  fieldTypeNames: NexusGenFieldTypeNames;`,\n        `  allTypes: NexusGenAllTypes;`,\n        `  typeInterfaces: NexusGenTypeInterfaces;`,\n        `  objectNames: NexusGenObjectNames;`,\n        `  inputNames: NexusGenInputNames;`,\n        `  enumNames: NexusGenEnumNames;`,\n        `  interfaceNames: NexusGenInterfaceNames;`,\n        `  scalarNames: NexusGenScalarNames;`,\n        `  unionNames: NexusGenUnionNames;`,\n        `  allInputTypes: NexusGenTypes['inputNames'] | NexusGenTypes['enumNames'] | NexusGenTypes['scalarNames'];`,\n        `  allOutputTypes: NexusGenTypes['objectNames'] | NexusGenTypes['enumNames'] | NexusGenTypes['unionNames'] | NexusGenTypes['interfaceNames'] | NexusGenTypes['scalarNames'];`,\n        `  allNamedTypes: NexusGenTypes['allInputTypes'] | NexusGenTypes['allOutputTypes']`,\n        `  abstractTypes: NexusGenTypes['interfaceNames'] | NexusGenTypes['unionNames'];`,\n        `  abstractTypeMembers: NexusGenAbstractTypeMembers;`,\n        `  objectsUsingAbstractStrategyIsTypeOf: NexusGenObjectsUsingAbstractStrategyIsTypeOf;`,\n        `  abstractsUsingStrategyResolveType: NexusGenAbstractsUsingStrategyResolveType;`,\n        `  features: NexusGenFeaturesConfig;`,\n      ])\n      .concat('}')\n      .join('\\n')\n  }\n\n  private printDynamicImport(forGlobal = false) {\n    const { sourceTypings } = this.schema.extensions.nexus.config\n    const { contextTypeImport } = this.typegenInfo\n    const imports: string[] = []\n    const importMap: Record<string, Set<string>> = {}\n    const outputPath = this.typegenInfo.typegenPath\n    const nexusSchemaImportId = this.typegenInfo.nexusSchemaImportId ?? getOwnPackage().name\n\n    if (!this.printImports[nexusSchemaImportId]) {\n      this.maybeAddCoreImport(forGlobal)\n    }\n\n    if (!forGlobal) {\n      if (contextTypeImport) {\n        const importPath = resolveImportPath(contextTypeImport, 'context', outputPath)\n        importMap[importPath] = importMap[importPath] || new Set()\n        importMap[importPath].add(\n          contextTypeImport.alias\n            ? `${contextTypeImport.export} as ${contextTypeImport.alias}`\n            : contextTypeImport.export\n        )\n      }\n      eachObj(sourceTypings, (rootType, typeName) => {\n        if (typeof rootType !== 'string') {\n          const importPath = resolveImportPath(rootType, typeName, outputPath)\n          importMap[importPath] = importMap[importPath] || new Set()\n          importMap[importPath].add(\n            rootType.alias ? `${rootType.export} as ${rootType.alias}` : rootType.export\n          )\n        }\n      })\n      eachObj(importMap, (val, key) => {\n        imports.push(`import type { ${Array.from(val).join(', ')} } from ${JSON.stringify(key)}`)\n      })\n    }\n\n    eachObj(this.printImports, (val, key) => {\n      const { default: def, ...rest } = val\n      const idents = []\n      if (def) {\n        idents.push(def)\n      }\n      let bindings: string[] = []\n      eachObj(rest, (alias, binding) => {\n        bindings.push(alias !== true ? `${binding} as ${alias}` : `${binding}`)\n      })\n      if (bindings.length) {\n        idents.push(`{ ${bindings.join(', ')} }`)\n      }\n      imports.push(`import type ${idents.join(', ')} from ${JSON.stringify(key)}`)\n    })\n    return imports.join('\\n')\n  }\n\n  private maybeAddCoreImport(forGlobal = false) {\n    const nexusSchemaImportId = this.typegenInfo.nexusSchemaImportId ?? getOwnPackage().name\n    const {\n      dynamicFields: { dynamicInputFields, dynamicOutputFields },\n    } = this.schema.extensions.nexus.config\n\n    let shouldAdd = false\n    const hasDynamicFields = [dynamicInputFields, dynamicOutputFields].some((o) => Object.keys(o).length > 0)\n\n    if (!this.typegenInfo.globalsPath) {\n      shouldAdd = hasDynamicFields || this.hasDiscriminatedTypes\n    } else {\n      shouldAdd = forGlobal ? hasDynamicFields : this.hasDiscriminatedTypes\n    }\n\n    if (shouldAdd) {\n      this.printImports[nexusSchemaImportId] = {\n        core: true,\n      }\n    }\n  }\n\n  private printDynamicInputFieldDefinitions() {\n    const { dynamicInputFields } = this.schema.extensions.nexus.config.dynamicFields\n    // If there is nothing custom... exit\n    if (!Object.keys(dynamicInputFields).length) {\n      return []\n    }\n    return [`declare global {`, `  interface NexusGenCustomInputMethods<TypeName extends string> {`]\n      .concat(\n        mapObj(dynamicInputFields, (val, key) => {\n          if (typeof val === 'string') {\n            const baseType = this.schema.getType(val)\n            return this.prependDoc(\n              `    ${key}<FieldName extends string>(fieldName: FieldName, opts?: core.CommonInputFieldConfig<TypeName, FieldName>): void // ${JSON.stringify(\n                val\n              )};`,\n              baseType?.description\n            )\n          }\n          return this.prependDoc(\n            `    ${key}${val.value.typeDefinition || `(...args: any): void`}`,\n            val.value.typeDescription\n          )\n        })\n      )\n      .concat([`  }`, `}`])\n      .join('\\n')\n  }\n\n  private printDynamicOutputFieldDefinitions() {\n    const { dynamicOutputFields } = this.schema.extensions.nexus.config.dynamicFields\n    // If there is nothing custom... exit\n    if (!Object.keys(dynamicOutputFields).length) {\n      return []\n    }\n    return [`declare global {`, `  interface NexusGenCustomOutputMethods<TypeName extends string> {`]\n      .concat(\n        mapObj(dynamicOutputFields, (val, key) => {\n          if (typeof val === 'string') {\n            const baseType = this.schema.getType(val)\n            return this.prependDoc(\n              `    ${key}<FieldName extends string>(fieldName: FieldName, ...opts: core.ScalarOutSpread<TypeName, FieldName>): void // ${JSON.stringify(\n                val\n              )};`,\n              baseType?.description\n            )\n          }\n          return this.prependDoc(\n            `    ${key}${val.value.typeDefinition || `(...args: any): void`}`,\n            val.value.typeDescription\n          )\n        })\n      )\n      .concat([`  }`, `}`])\n      .join('\\n')\n  }\n\n  private prependDoc(typeDef: string, typeDescription?: string | null) {\n    let outStr = ''\n    if (typeDescription) {\n      let parts = typeDescription.split('\\n').map((f) => f.trimLeft())\n      if (parts[0] === '') {\n        parts = parts.slice(1)\n      }\n      if (parts[parts.length - 1] === '') {\n        parts = parts.slice(0, -1)\n      }\n      outStr = ['    /**', ...parts.map((p) => `     *${p ? ` ${p}` : ''}`), '     */'].join('\\n') + '\\n'\n    }\n    return `${outStr}${typeDef}`\n  }\n\n  private printDynamicOutputPropertyDefinitions() {\n    const { dynamicOutputProperties } = this.schema.extensions.nexus.config.dynamicFields\n    // If there is nothing custom... exit\n    if (!Object.keys(dynamicOutputProperties).length) {\n      return []\n    }\n    return [`declare global {`, `  interface NexusGenCustomOutputProperties<TypeName extends string> {`]\n      .concat(\n        mapObj(dynamicOutputProperties, (val, key) => {\n          return this.prependDoc(\n            `    ${key}${val.value.typeDefinition || `: any`}`,\n            val.value.typeDescription\n          )\n        })\n      )\n      .concat([`  }`, `}`])\n      .join('\\n')\n  }\n\n  private printInheritedFieldMap() {\n    const hasInterfaces: (\n      | (GraphQLInterfaceType & { getInterfaces(): ReadonlyArray<GraphQLInterfaceType> })\n      | GraphQLObjectType\n    )[] = []\n    const withInterfaces = hasInterfaces\n      .concat(this.groupedTypes.object, this.groupedTypes.interface.map(graphql15InterfaceType))\n      .map((o) => {\n        if (o.getInterfaces().length) {\n          return [o.name, o.getInterfaces().map((i) => i.name)]\n        }\n        return null\n      })\n      .filter((f) => f) as [string, string[]][]\n\n    return ['export interface NexusGenTypeInterfaces {']\n      .concat(\n        withInterfaces.map(([name, interfaces]) => {\n          return `  ${name}: ${interfaces.map((i) => JSON.stringify(i)).join(' | ')}`\n        })\n      )\n      .concat('}')\n      .join('\\n')\n  }\n\n  private printContext() {\n    return this.typegenInfo.contextTypeImport?.alias || this.typegenInfo.contextTypeImport?.export || 'any'\n  }\n\n  private printAbstractTypeMembers() {\n    return this.printTypeInterface('NexusGenAbstractTypeMembers', this.buildAbstractTypeMembers())\n  }\n\n  private buildAbstractTypeMembers() {\n    const sourceMap: TypeMapping = {}\n    const abstractTypes: (GraphQLInterfaceType | GraphQLUnionType)[] = []\n    abstractTypes\n      .concat(this.groupedTypes.union)\n      .concat(this.groupedTypes.interface)\n      .forEach((type) => {\n        if (isInterfaceType(type)) {\n          const possibleNames = this.schema.getPossibleTypes(type).map((t) => t.name)\n          if (possibleNames.length > 0) {\n            sourceMap[type.name] = possibleNames.map((val) => JSON.stringify(val)).join(' | ')\n          }\n        } else {\n          sourceMap[type.name] = type\n            .getTypes()\n            .map((t) => JSON.stringify(t.name))\n            .join(' | ')\n        }\n      })\n    return sourceMap\n  }\n\n  private printTypeNames(name: keyof GroupedTypes, exportName: string, source: string) {\n    const obj = this.groupedTypes[name] as GraphQLNamedType[]\n    const typeDef = obj.length === 0 ? 'never' : `keyof ${source}`\n    return `export type ${exportName} = ${typeDef};`\n  }\n\n  private printIsTypeOfObjectTypeNames(exportName: string) {\n    const objectTypes = this.groupedTypes.object.filter((o) => o.isTypeOf !== undefined)\n    const typeDef =\n      objectTypes.length === 0\n        ? 'never'\n        : objectTypes\n            .map((o) => JSON.stringify(o.name))\n            .sort()\n            .join(' | ')\n    return `export type ${exportName} = ${typeDef};`\n  }\n\n  private printResolveTypeAbstractTypes(exportName: string) {\n    const abstractTypes = [...this.groupedTypes.interface, ...this.groupedTypes.union].filter(\n      (o) => o.resolveType !== undefined\n    )\n    const typeDef =\n      abstractTypes.length === 0\n        ? 'never'\n        : abstractTypes\n\n            .map((o) => JSON.stringify(o.name))\n            .sort()\n            .join(' | ')\n    return `export type ${exportName} = ${typeDef};`\n  }\n\n  private printFeaturesConfig(exportName: string) {\n    const abstractTypes = this.schema.extensions.nexus.config.features?.abstractTypeStrategies ?? {}\n    const unionProps = renderObject(mapValues(abstractTypes, (val) => val ?? false))\n\n    return [`export type ${exportName} = {`]\n      .concat(`  abstractTypeStrategies: ${unionProps}`)\n      .concat('}')\n      .join('\\n')\n  }\n\n  private buildEnumTypeMap() {\n    const enumMap: TypeMapping = {}\n    this.groupedTypes.enum.forEach((e) => {\n      const sourceType = this.resolveSourceType(e.name)\n      if (sourceType) {\n        enumMap[e.name] = sourceType\n      } else {\n        const values = e.getValues().map((val) => JSON.stringify(val.value))\n        enumMap[e.name] = values.join(' | ')\n      }\n    })\n    return enumMap\n  }\n\n  private buildInputTypeMap() {\n    const inputObjMap: TypeFieldMapping = {}\n    this.groupedTypes.input.forEach((input) => {\n      eachObj(input.getFields(), (field) => {\n        inputObjMap[input.name] = inputObjMap[input.name] || {}\n        inputObjMap[input.name][field.name] = this.normalizeArg(field)\n      })\n    })\n    return inputObjMap\n  }\n\n  private buildScalarTypeMap() {\n    const scalarMap: TypeMapping = {}\n    this.groupedTypes.scalar.forEach((e) => {\n      if (isSpecifiedScalarType(e)) {\n        scalarMap[e.name] = this.resolveSourceType(e.name) ?? SpecifiedScalars[e.name as SpecifiedScalarNames]\n        return\n      }\n      const sourceType = this.resolveSourceType(e.name)\n      if (sourceType) {\n        scalarMap[e.name] = sourceType\n      } else {\n        scalarMap[e.name] = 'any'\n      }\n    })\n    return scalarMap\n  }\n\n  private printInputTypeMap() {\n    const inputTypeMap = this.buildInputTypeMap()\n\n    if (this.typegenInfo.declareInputs) {\n      const declaredInputs: string[] = mapObj(inputTypeMap, (fields, inputName) =>\n        this.printNamedObj(inputName, fields)\n      )\n      return [...declaredInputs, this.printNamedMap('NexusGenInputs', inputTypeMap)].join('\\n\\n')\n    }\n\n    return this.printTypeFieldInterface('NexusGenInputs', inputTypeMap, 'input type')\n  }\n\n  private printEnumTypeMap() {\n    const enumTypeMap = this.buildEnumTypeMap()\n\n    if (this.typegenInfo.declareInputs) {\n      return [\n        ...mapObj(enumTypeMap, (val, name) => `export type ${name} = ${val}`),\n        this.printNamedMap('NexusGenEnums', enumTypeMap),\n      ].join('\\n\\n')\n    }\n\n    return this.printTypeInterface('NexusGenEnums', enumTypeMap)\n  }\n\n  private printScalarTypeMap() {\n    return this.printTypeInterface('NexusGenScalars', this.buildScalarTypeMap())\n  }\n\n  private shouldDiscriminateType(\n    abstractType: GraphQLAbstractType,\n    objectType: GraphQLObjectType\n  ): 'required' | 'optional' | false {\n    if (!this.schema.extensions.nexus.config.features?.abstractTypeStrategies?.__typename) {\n      return false\n    }\n\n    if (abstractType.resolveType !== undefined) {\n      return 'optional'\n    }\n\n    if (objectType.isTypeOf !== undefined) {\n      return 'optional'\n    }\n\n    return 'required'\n  }\n\n  private maybeDiscriminate(abstractType: GraphQLAbstractType, objectType: GraphQLObjectType) {\n    const requiredOrOptional = this.shouldDiscriminateType(abstractType, objectType)\n\n    if (requiredOrOptional === false) {\n      return `NexusGenRootTypes['${objectType.name}']`\n    }\n\n    this.hasDiscriminatedTypes = true\n\n    return `core.Discriminate<'${objectType.name}', '${requiredOrOptional}'>`\n  }\n\n  private buildRootTypeMap(hasFields: Array<GraphQLInterfaceType | GraphQLObjectType | GraphQLUnionType>) {\n    const rootTypeMap: RootTypeMapping = {}\n    hasFields.forEach((type) => {\n      const rootTyping = this.resolveSourceType(type.name)\n      if (rootTyping) {\n        rootTypeMap[type.name] = rootTyping\n        return\n      }\n      if (isUnionType(type)) {\n        rootTypeMap[type.name] = type\n          .getTypes()\n          .map((t) => this.maybeDiscriminate(type, t))\n          .join(' | ')\n      } else if (isInterfaceType(type)) {\n        const possibleRoots = this.schema.getPossibleTypes(type).map((t) => this.maybeDiscriminate(type, t))\n        if (possibleRoots.length > 0) {\n          rootTypeMap[type.name] = possibleRoots.join(' | ')\n        } else {\n          rootTypeMap[type.name] = 'any'\n        }\n      } else if (type.name === 'Query' || type.name === 'Mutation') {\n        rootTypeMap[type.name] = '{}'\n      } else {\n        eachObj(type.getFields(), (field) => {\n          const obj = (rootTypeMap[type.name] = rootTypeMap[type.name] || {})\n          if (!this.hasResolver(field, type)) {\n            if (typeof obj !== 'string') {\n              obj[field.name] = [\n                this.argSeparator(field.type as GraphQLInputType, false),\n                this.printOutputType(field.type),\n              ]\n            }\n          }\n        })\n      }\n    })\n    return rootTypeMap\n  }\n\n  private resolveSourceType(typeName: string): string | undefined {\n    const rootTyping = this.schema.extensions.nexus.config.sourceTypings[typeName]\n    if (rootTyping) {\n      return typeof rootTyping === 'string' ? rootTyping : rootTyping.export\n    }\n    return (this.typegenInfo.sourceTypeMap as any)[typeName]\n  }\n\n  private hasResolver(\n    field: GraphQLField<any, any>,\n    // Used in test mocking\n    _type: GraphQLObjectType\n  ) {\n    if (field.extensions && hasNexusExtension(field.extensions.nexus)) {\n      return field.extensions.nexus.hasDefinedResolver\n    }\n    return Boolean(field.resolve)\n  }\n\n  private printObjectTypeMap() {\n    return this.printRootTypeFieldInterface(\n      'NexusGenObjects',\n      this.buildRootTypeMap(this.groupedTypes.object)\n    )\n  }\n\n  private printInterfaceTypeMap() {\n    return this.printRootTypeFieldInterface(\n      'NexusGenInterfaces',\n      this.buildRootTypeMap(this.groupedTypes.interface)\n    )\n  }\n\n  private printUnionTypeMap() {\n    return this.printRootTypeFieldInterface('NexusGenUnions', this.buildRootTypeMap(this.groupedTypes.union))\n  }\n\n  private printRootTypeDef() {\n    const toJoin: string[] = []\n    if (this.groupedTypes.interface.length) {\n      toJoin.push('NexusGenInterfaces')\n    }\n    if (this.groupedTypes.object.length) {\n      toJoin.push('NexusGenObjects')\n    }\n    if (this.groupedTypes.union.length) {\n      toJoin.push('NexusGenUnions')\n    }\n    return `export type NexusGenRootTypes = ${toJoin.join(' & ')}`\n  }\n\n  private printAllTypesMap() {\n    const toJoin: string[] = ['NexusGenRootTypes']\n    if (this.groupedTypes.scalar.length) {\n      toJoin.push('NexusGenScalars')\n    }\n    if (this.groupedTypes.enum.length) {\n      toJoin.push('NexusGenEnums')\n    }\n    return `export type NexusGenAllTypes = ${toJoin.join(' & ')}`\n  }\n\n  private buildArgTypeMap() {\n    const argTypeMap: Record<string, TypeFieldMapping> = {}\n    const hasFields: (GraphQLInterfaceType | GraphQLObjectType)[] = []\n    hasFields\n      .concat(this.groupedTypes.object)\n      .concat(this.groupedTypes.interface)\n      .forEach((type) => {\n        eachObj(type.getFields(), (field) => {\n          if (field.args.length > 0) {\n            argTypeMap[type.name] = argTypeMap[type.name] || {}\n            argTypeMap[type.name][field.name] = field.args.reduce((obj, arg) => {\n              obj[arg.name] = this.normalizeArg(arg)\n              return obj\n            }, {} as Record<string, [string, string]>)\n          }\n        })\n      })\n    return argTypeMap\n  }\n\n  private printArgTypeMap() {\n    const argTypeMap = this.buildArgTypeMap()\n    if (this.typegenInfo.declareInputs) {\n      const declaredArgs: string[] = []\n      eachObj(argTypeMap, (fields, typeName) => {\n        eachObj(fields, (args, fieldName) => {\n          declaredArgs.push(this.printNamedObj(this.getArgsName(typeName, fieldName), args))\n        })\n      })\n      return [...declaredArgs, this.printArgTypeFieldInterface(argTypeMap)].join('\\n\\n')\n    }\n\n    return this.printArgTypeFieldInterface(argTypeMap)\n  }\n\n  private getArgsName(typeName: string, fieldName: string) {\n    return `${typeName}${fieldName.slice(0, 1).toUpperCase().concat(fieldName.slice(1))}Args`\n  }\n\n  private printNamedObj(name: string, obj: Record<string, [string, string]>) {\n    return [\n      `export interface ${name} {`,\n      ...mapObj(obj, (val, key) => `  ${key}${val[0]} ${val[1]}`),\n      `}`,\n    ].join('\\n')\n  }\n\n  private printNamedMap(name: string, obj: Record<string, any>) {\n    return [`export interface ${name} {`, ...mapObj(obj, (val, key) => `  ${key}: ${key}`), `}`].join('\\n')\n  }\n\n  private buildReturnTypeMap() {\n    const returnTypeMap: TypeFieldMapping = {}\n    const hasFields: (GraphQLInterfaceType | GraphQLObjectType)[] = []\n    hasFields\n      .concat(this.groupedTypes.object)\n      .concat(this.groupedTypes.interface)\n      .forEach((type) => {\n        eachObj(type.getFields(), (field) => {\n          returnTypeMap[type.name] = returnTypeMap[type.name] || {}\n          returnTypeMap[type.name][field.name] = [':', this.printOutputType(field.type)]\n        })\n      })\n    return returnTypeMap\n  }\n\n  private buildReturnTypeNamesMap() {\n    const returnTypeMap: TypeFieldMapping = {}\n    const hasFields: (GraphQLInterfaceType | GraphQLObjectType)[] = []\n    hasFields\n      .concat(this.groupedTypes.object)\n      .concat(this.groupedTypes.interface)\n      .forEach((type) => {\n        eachObj(type.getFields(), (field) => {\n          returnTypeMap[type.name] = returnTypeMap[type.name] || {}\n          returnTypeMap[type.name][field.name] = [':', `'${getNamedType(field.type).name}'`]\n        })\n      })\n    return returnTypeMap\n  }\n\n  private printOutputType(type: GraphQLOutputType) {\n    const returnType = this.typeToArr(type)\n    function combine(item: any[]): string {\n      if (item.length === 1) {\n        if (Array.isArray(item[0])) {\n          const toPrint = combine(item[0])\n          return toPrint.indexOf('null') === -1 ? `${toPrint}[]` : `Array<${toPrint}>`\n        }\n        return item[0]\n      }\n      if (Array.isArray(item[1])) {\n        const toPrint = combine(item[1])\n        return toPrint.indexOf('null') === -1 ? `${toPrint}[] | null` : `Array<${toPrint}> | null`\n      }\n      return `${item[1]} | null`\n    }\n    return `${combine(returnType)}; // ${type}`\n  }\n\n  private typeToArr(type: GraphQLOutputType): any[] {\n    const typing = []\n    if (isNonNullType(type)) {\n      type = type.ofType\n    } else {\n      typing.push(null)\n    }\n    if (isListType(type)) {\n      typing.push(this.typeToArr(type.ofType))\n    } else if (isScalarType(type)) {\n      typing.push(this.printScalar(type))\n    } else if (isEnumType(type)) {\n      if (this.typegenInfo.declareInputs) {\n        typing.push(type.name)\n      } else {\n        typing.push(`NexusGenEnums['${type.name}']`)\n      }\n    } else if (isObjectType(type) || isInterfaceType(type) || isUnionType(type)) {\n      typing.push(`NexusGenRootTypes['${type.name}']`)\n    }\n    return typing\n  }\n\n  private printFieldTypesMap() {\n    return this.printTypeFieldInterface('NexusGenFieldTypes', this.buildReturnTypeMap(), 'field return type')\n  }\n\n  private printFieldTypeNamesMap() {\n    return this.printTypeFieldInterface(\n      'NexusGenFieldTypeNames',\n      this.buildReturnTypeNamesMap(),\n      'field return type name'\n    )\n  }\n\n  private normalizeArg(arg: GraphQLInputField | GraphQLArgument): [string, string] {\n    return [this.argSeparator(arg.type, Boolean(arg.defaultValue)), this.argTypeRepresentation(arg.type)]\n  }\n\n  private argSeparator(type: GraphQLInputType, hasDefaultValue: boolean) {\n    if (hasDefaultValue || isNonNullType(type)) {\n      return ':'\n    }\n\n    return '?:'\n  }\n\n  private argTypeRepresentation(arg: GraphQLInputType): string {\n    const argType = this.argTypeArr(arg)\n    function combine(item: any[]): string {\n      if (item.length === 1) {\n        if (Array.isArray(item[0])) {\n          const toPrint = combine(item[0])\n          return toPrint.indexOf('null') === -1 ? `${toPrint}[]` : `Array<${toPrint}>`\n        }\n        return item[0]\n      }\n      if (Array.isArray(item[1])) {\n        const toPrint = combine(item[1])\n        return toPrint.indexOf('null') === -1 ? `${toPrint}[] | null` : `Array<${toPrint}> | null`\n      }\n      return `${item[1]} | null`\n    }\n    return `${combine(argType)}; // ${arg}`\n  }\n\n  private argTypeArr(arg: GraphQLInputType): any[] {\n    const typing = []\n    if (isNonNullType(arg)) {\n      arg = arg.ofType\n    } else {\n      typing.push(null)\n    }\n    if (isListType(arg)) {\n      typing.push(this.argTypeArr(arg.ofType))\n    } else if (isScalarType(arg)) {\n      typing.push(this.printScalar(arg))\n    } else if (isEnumType(arg)) {\n      if (this.typegenInfo.declareInputs) {\n        typing.push(arg.name)\n      } else {\n        typing.push(`NexusGenEnums['${arg.name}']`)\n      }\n    } else if (isInputObjectType(arg)) {\n      if (this.typegenInfo.declareInputs) {\n        typing.push(arg.name)\n      } else {\n        typing.push(`NexusGenInputs['${arg.name}']`)\n      }\n    }\n    return typing\n  }\n\n  private printTypeInterface(interfaceName: string, typeMapping: TypeMapping) {\n    return [`export interface ${interfaceName} {`]\n      .concat(mapObj(typeMapping, (val, key) => `  ${key}: ${val}`))\n      .concat('}')\n      .join('\\n')\n  }\n\n  private printRootTypeFieldInterface(interfaceName: string, typeMapping: RootTypeMapping) {\n    return [`export interface ${interfaceName} {`]\n      .concat(\n        mapObj(typeMapping, (val, key) => {\n          if (typeof val === 'string') {\n            return `  ${key}: ${val};`\n          }\n          if (Object.keys(val).length === 0) {\n            return `  ${key}: {};`\n          }\n          return this.printObj('  ', 'root type')(val, key)\n        })\n      )\n      .concat('}')\n      .join('\\n')\n  }\n\n  private printTypeFieldInterface(interfaceName: string, typeMapping: TypeFieldMapping, source: string) {\n    return [`export interface ${interfaceName} {`]\n      .concat(mapObj(typeMapping, this.printObj('  ', source)))\n      .concat('}')\n      .join('\\n')\n  }\n\n  private printArgTypeFieldInterface(typeMapping: Record<string, TypeFieldMapping>) {\n    return [`export interface NexusGenArgTypes {`]\n      .concat(\n        mapObj(typeMapping, (val, typeName) => {\n          if (this.typegenInfo.declareInputs) {\n            return [`  ${typeName}: {`]\n              .concat(\n                mapObj(val, (_, fieldName) => `    ${fieldName}: ${this.getArgsName(typeName, fieldName)}`)\n              )\n              .concat('  }')\n              .join('\\n')\n          }\n          return [`  ${typeName}: {`]\n            .concat(mapObj(val, this.printObj('    ', 'args')))\n            .concat('  }')\n            .join('\\n')\n        })\n      )\n      .concat('}')\n      .join('\\n')\n  }\n\n  private printObj =\n    (space: string, source: string) => (val: Record<string, [string, string]>, key: string) => {\n      return [`${space}${key}: { // ${source}`]\n        .concat(\n          mapObj(val, (v2, k2) => {\n            return `${space}  ${k2}${v2[0]} ${v2[1]}`\n          })\n        )\n        .concat(`${space}}`)\n        .join('\\n')\n    }\n\n  private printScalar(type: GraphQLScalarType) {\n    if (isSpecifiedScalarType(type)) {\n      return this.resolveSourceType(type.name) ?? SpecifiedScalars[type.name as SpecifiedScalarNames]\n    }\n    return `NexusGenScalars['${type.name}']`\n  }\n\n  private printPlugins() {\n    const pluginFieldExt: string[] = [\n      `  interface NexusGenPluginFieldConfig<TypeName extends string, FieldName extends string> {`,\n    ]\n    const pluginInputFieldExt: string[] = [\n      `  interface NexusGenPluginInputFieldConfig<TypeName extends string, FieldName extends string> {`,\n    ]\n    const pluginArgExt: string[] = [`  interface NexusGenPluginArgConfig {`]\n    const pluginSchemaExt: string[] = [`  interface NexusGenPluginSchemaConfig {`]\n    const pluginTypeExt: string[] = [`  interface NexusGenPluginTypeConfig<TypeName extends string> {`]\n    const pluginInputTypeExt: string[] = [\n      `  interface NexusGenPluginInputTypeConfig<TypeName extends string> {`,\n    ]\n    const printInlineDefs: string[] = []\n    const plugins = this.schema.extensions.nexus.config.plugins || []\n    plugins.forEach((plugin) => {\n      if (plugin.config.fieldDefTypes) {\n        pluginFieldExt.push(padLeft(this.printType(plugin.config.fieldDefTypes), '    '))\n      }\n      if (plugin.config.inputFieldDefTypes) {\n        pluginInputFieldExt.push(padLeft(this.printType(plugin.config.inputFieldDefTypes), '    '))\n      }\n      if (plugin.config.objectTypeDefTypes) {\n        pluginTypeExt.push(padLeft(this.printType(plugin.config.objectTypeDefTypes), '    '))\n      }\n      if (plugin.config.inputObjectTypeDefTypes) {\n        pluginInputTypeExt.push(padLeft(this.printType(plugin.config.inputObjectTypeDefTypes), '    '))\n      }\n      if (plugin.config.argTypeDefTypes) {\n        pluginArgExt.push(padLeft(this.printType(plugin.config.argTypeDefTypes), '    '))\n      }\n    })\n    return [\n      printInlineDefs.join('\\n'),\n      [\n        'declare global {',\n        [\n          pluginTypeExt.concat('  }').join('\\n'),\n          pluginInputTypeExt.concat('  }').join('\\n'),\n          pluginFieldExt.concat('  }').join('\\n'),\n          pluginInputFieldExt.concat('  }').join('\\n'),\n          pluginSchemaExt.concat('  }').join('\\n'),\n          pluginArgExt.concat('  }').join('\\n'),\n        ].join('\\n'),\n        '}',\n      ].join('\\n'),\n    ].join('\\n')\n  }\n\n  private printType(strLike: StringLike | StringLike[]): string {\n    if (Array.isArray(strLike)) {\n      return strLike.map((s) => this.printType(s)).join('\\n')\n    }\n    if (isNexusPrintedGenTyping(strLike)) {\n      strLike.imports.forEach((i) => {\n        this.addImport(i)\n      })\n      return strLike.toString()\n    }\n    if (isNexusPrintedGenTypingImport(strLike)) {\n      this.addImport(strLike)\n      return ''\n    }\n    return strLike\n  }\n\n  private addImport(i: PrintedGenTypingImport) {\n    /* istanbul ignore if */\n    if (!isNexusPrintedGenTypingImport(i)) {\n      console.warn(`Expected printedGenTypingImport, saw ${i}`)\n      return\n    }\n    this.printImports[i.config.module] = this.printImports[i.config.module] || {}\n    if (i.config.default) {\n      this.printImports[i.config.module].default = i.config.default\n    }\n    if (i.config.bindings) {\n      i.config.bindings.forEach((binding) => {\n        if (typeof binding === 'string') {\n          this.printImports[i.config.module][binding] = true\n        } else {\n          this.printImports[i.config.module][binding[0]] = binding[1]\n        }\n      })\n    }\n  }\n}\n\nfunction padLeft(str: string, padding: string) {\n  return str\n    .split('\\n')\n    .map((s) => `${padding}${s}`)\n    .join('\\n')\n}\n\nconst GLOBAL_DECLARATION = `\ndeclare global {\n  interface NexusGen extends NexusGenTypes {}\n}`\n\nfunction renderObject(object: Record<string, any>): string {\n  return [\n    '{',\n    mapObj(object, (val, key) => {\n      return `    ${key}: ${val}`\n    }).join('\\n'),\n    '  }',\n  ].join('\\n')\n}\n"],"names":[],"mappings":";;;;;;AAAA,OAAO,EACL,YAAY,EAYZ,UAAU,EACV,iBAAiB,EACjB,eAAe,EACf,UAAU,EACV,aAAa,EACb,YAAY,EACZ,YAAY,EACZ,qBAAqB,EACrB,WAAW,GACZ,MAAM,SAAS,CAAA;AAEhB,OAAO,EAAE,uBAAuB,EAAE,6BAA6B,EAAE,MAAM,wBAAwB,CAAA;AAE/F,OAAO,EAAE,cAAc,EAAE,MAAM,QAAQ,CAAA;AAEvC,OAAO,EAAE,iBAAiB,EAAE,MAAM,cAAc,CAAA;AAChD,OAAO,EACL,OAAO,EACP,aAAa,EACb,sBAAsB,EAEtB,UAAU,EACV,MAAM,EACN,SAAS,EAET,cAAc,EACd,iBAAiB,GAClB,MAAM,SAAS,CAAA;;;;;;;AAEhB,MAAM,gBAAgB,GAAG;IACvB,EAAE,EAAE,QAAQ;IACZ,MAAM,EAAE,QAAQ;IAChB,KAAK,EAAE,QAAQ;IACf,GAAG,EAAE,QAAQ;IACb,OAAO,EAAE,SAAS;CACnB,CAAA;AAwBK,MAAO,cAAc;IAKzB,YAAsB,MAA0B,EAAY,WAAgC,CAAA;QAAtE,IAAA,CAAA,MAAM,GAAN,MAAM,CAAoB;QAAY,IAAA,CAAA,WAAW,GAAX,WAAW,CAAqB;QAu0BpF,IAAA,CAAA,QAAQ,GACd,CAAC,KAAa,EAAE,MAAc,EAAE,CAAG,CAAD,AAAE,GAAqC,EAAE,GAAW,EAAE,EAAE;gBACxF,OAAO;oBAAC,GAAG,KAAK,GAAG,GAAG,CAAA,OAAA,EAAU,MAAM,EAAE;iBAAC,CACtC,MAAM,KACL,8NAAM,EAAC,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE;oBACrB,OAAO,GAAG,KAAK,CAAA,EAAA,EAAK,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC,CAAA,CAAA,EAAI,EAAE,CAAC,CAAC,CAAC,EAAE,CAAA;gBAC3C,CAAC,CAAC,CACH,CACA,MAAM,CAAC,GAAG,KAAK,CAAA,CAAA,CAAG,CAAC,CACnB,IAAI,CAAC,IAAI,CAAC,CAAA;YACf,CAAC,CAAA;QAh1BD,IAAI,CAAC,YAAY,OAAG,kOAAU,EAAC,MAAM,CAAC,CAAA;QACtC,IAAI,CAAC,YAAY,GAAG,CAAA,CAAE,CAAA;QACtB,IAAI,CAAC,qBAAqB,GAAG,KAAK,CAAA;IACpC,CAAC;IAED,KAAK,GAAA;QACH,MAAM,IAAI,GAAG;YAAC,IAAI,CAAC,WAAW,EAAE;YAAE,IAAI,CAAC,YAAY,EAAE;SAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;QACnE,OAAO;YAAC,IAAI,CAAC,YAAY,EAAE;YAAE,IAAI;SAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;IACjD,CAAC;IAED,eAAe,GAAA;QACb,IAAI,IAAI,CAAC,WAAW,CAAC,WAAW,EAAE;YAChC,MAAM,OAAO,GAAG,IAAI,CAAC,YAAY,EAAE,CAAA;YACnC,MAAM,WAAW,GAAG;gBAAC,IAAI,CAAC,kBAAkB,EAAE;gBAAE,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC;gBAAE,OAAO;aAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;YAEpG,yDAAyD;YACzD,IAAI,CAAC,YAAY,GAAG,CAAA,CAAE,CAAA;YAEtB,MAAM,MAAM,GAAG,IAAI,CAAC,WAAW,EAAE,CAAA;YACjC,MAAM,OAAO,GAAG;gBAAC,IAAI,CAAC,kBAAkB,EAAE;gBAAE,MAAM;aAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;YAChE,OAAO;gBACL,OAAO;gBACP,WAAW;aACZ,CAAA;SACF;QACD,OAAO;YACL,OAAO,EAAE,IAAI,CAAC,KAAK,EAAE;YACrB,WAAW,EAAE,IAAI;SAClB,CAAA;IACH,CAAC;IAEO,WAAW,GAAA;QACjB,OAAO;YACL,IAAI,CAAC,iBAAiB,EAAE;YACxB,IAAI,CAAC,gBAAgB,EAAE;YACvB,IAAI,CAAC,kBAAkB,EAAE;YACzB,IAAI,CAAC,kBAAkB,EAAE;YACzB,IAAI,CAAC,qBAAqB,EAAE;YAC5B,IAAI,CAAC,iBAAiB,EAAE;YACxB,IAAI,CAAC,gBAAgB,EAAE;YACvB,IAAI,CAAC,gBAAgB,EAAE;YACvB,IAAI,CAAC,kBAAkB,EAAE;YACzB,IAAI,CAAC,sBAAsB,EAAE;YAC7B,IAAI,CAAC,eAAe,EAAE;YACtB,IAAI,CAAC,wBAAwB,EAAE;YAC/B,IAAI,CAAC,sBAAsB,EAAE;YAC7B,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE,qBAAqB,EAAE,iBAAiB,CAAC;YACvE,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,oBAAoB,EAAE,gBAAgB,CAAC;YACpE,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,mBAAmB,EAAE,eAAe,CAAC;YACjE,IAAI,CAAC,cAAc,CAAC,WAAW,EAAE,wBAAwB,EAAE,oBAAoB,CAAC;YAChF,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE,qBAAqB,EAAE,iBAAiB,CAAC;YACvE,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,oBAAoB,EAAE,gBAAgB,CAAC;YACpE,IAAI,CAAC,4BAA4B,CAAC,8CAA8C,CAAC;YACjF,IAAI,CAAC,6BAA6B,CAAC,2CAA2C,CAAC;YAC/E,IAAI,CAAC,mBAAmB,CAAC,wBAAwB,CAAC;YAClD,IAAI,CAAC,eAAe,EAAE;SACvB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;IAChB,CAAC;IAEO,YAAY,GAAA;QAClB,OAAO;YAAC,IAAI,CAAC,kBAAkB,EAAE;YAAE,IAAI,CAAC,kBAAkB,EAAE;SAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;IAC1E,CAAC;IAEO,kBAAkB,GAAA;QACxB,OAAO;YACL,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC;YACnC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC;YACnC,IAAI,CAAC,kBAAkB,EAAE;SAC1B,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;IACd,CAAC;IAEO,kBAAkB,GAAA;;QACxB,MAAM,OAAO,GAAG;YACd,IAAI,CAAC,iCAAiC,EAAE;YACxC,IAAI,CAAC,kCAAkC,EAAE;YACzC,IAAI,CAAC,qCAAqC,EAAE;YAC5C,kBAAkB;SACnB,CAAA;QAED,IAAI,IAAI,CAAC,WAAW,CAAC,WAAW,EAAE;YAChC,OAAO,CAAC,OAAO,CACb,CAAA,oCAAA,MAAuC,sOAAc,EACnD,IAAI,CAAC,WAAW,CAAC,WAAW,EAC5B,CAAA,KAAA,IAAI,CAAC,WAAW,CAAC,WAAW,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,EAAE,CACnC,CAAA,CAAA,CAAG,CACL,CAAA;YACD,OAAO,CAAC,OAAO,CAAC,GAAG,AAAC,CAAA,KAAA,IAAI,CAAC,WAAW,CAAC,cAAc,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,EAAE,CAAC,CAAC,CAAA;YAC3D,OAAO,CAAC,OAAO,CAAC,qOAAc,CAAC,CAAA;SAChC;QAED,OAAO,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;IAC3B,CAAC;IAEO,eAAe,GAAA;QACrB,OAAO;YAAC,CAAA,gCAAA,CAAkC;SAAC,CACxC,MAAM,CAAC;YACN,CAAA,WAAA,EAAc,IAAI,CAAC,YAAY,EAAE,CAAA,CAAA,CAAG;YACpC,CAAA,6BAAA,CAA+B;YAC/B,CAAA,+BAAA,CAAiC;YACjC,CAAA,oEAAA,CAAsE;YACtE,CAAA,6BAAA,CAA+B;YAC/B,CAAA,iCAAA,CAAmC;YACnC,CAAA,yCAAA,CAA2C;YAC3C,CAAA,6BAAA,CAA+B;YAC/B,CAAA,yCAAA,CAA2C;YAC3C,CAAA,mCAAA,CAAqC;YACrC,CAAA,iCAAA,CAAmC;YACnC,CAAA,+BAAA,CAAiC;YACjC,CAAA,yCAAA,CAA2C;YAC3C,CAAA,mCAAA,CAAqC;YACrC,CAAA,iCAAA,CAAmC;YACnC,CAAA,yGAAA,CAA2G;YAC3G,CAAA,2KAAA,CAA6K;YAC7K,CAAA,iFAAA,CAAmF;YACnF,CAAA,+EAAA,CAAiF;YACjF,CAAA,mDAAA,CAAqD;YACrD,CAAA,qFAAA,CAAuF;YACvF,CAAA,+EAAA,CAAiF;YACjF,CAAA,mCAAA,CAAqC;SACtC,CAAC,CACD,MAAM,CAAC,GAAG,CAAC,CACX,IAAI,CAAC,IAAI,CAAC,CAAA;IACf,CAAC;IAEO,kBAAkB,CAAC,SAAS,GAAG,KAAK,EAAA;;QAC1C,MAAM,EAAE,aAAa,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,CAAA;QAC7D,MAAM,EAAE,iBAAiB,EAAE,GAAG,IAAI,CAAC,WAAW,CAAA;QAC9C,MAAM,OAAO,GAAa,EAAE,CAAA;QAC5B,MAAM,SAAS,GAAgC,CAAA,CAAE,CAAA;QACjD,MAAM,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC,WAAW,CAAA;QAC/C,MAAM,mBAAmB,GAAG,CAAA,KAAA,IAAI,CAAC,WAAW,CAAC,mBAAmB,MAAA,QAAA,OAAA,KAAA,IAAA,SAAI,qOAAa,EAAE,EAAC,IAAI,CAAA;QAExF,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,mBAAmB,CAAC,EAAE;YAC3C,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,CAAA;SACnC;QAED,IAAI,CAAC,SAAS,EAAE;YACd,IAAI,iBAAiB,EAAE;gBACrB,MAAM,UAAU,OAAG,yOAAiB,EAAC,iBAAiB,EAAE,SAAS,EAAE,UAAU,CAAC,CAAA;gBAC9E,SAAS,CAAC,UAAU,CAAC,GAAG,SAAS,CAAC,UAAU,CAAC,IAAI,IAAI,GAAG,EAAE,CAAA;gBAC1D,SAAS,CAAC,UAAU,CAAC,CAAC,GAAG,CACvB,iBAAiB,CAAC,KAAK,GACnB,GAAG,iBAAiB,CAAC,MAAM,CAAA,IAAA,EAAO,iBAAiB,CAAC,KAAK,EAAE,GAC3D,iBAAiB,CAAC,MAAM,CAC7B,CAAA;aACF;gBACD,+NAAO,EAAC,aAAa,EAAE,CAAC,QAAQ,EAAE,QAAQ,EAAE,EAAE;gBAC5C,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;oBAChC,MAAM,UAAU,OAAG,yOAAiB,EAAC,QAAQ,EAAE,QAAQ,EAAE,UAAU,CAAC,CAAA;oBACpE,SAAS,CAAC,UAAU,CAAC,GAAG,SAAS,CAAC,UAAU,CAAC,IAAI,IAAI,GAAG,EAAE,CAAA;oBAC1D,SAAS,CAAC,UAAU,CAAC,CAAC,GAAG,CACvB,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAA,IAAA,EAAO,QAAQ,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,CAC7E,CAAA;iBACF;YACH,CAAC,CAAC,CAAA;gBACF,+NAAO,EAAC,SAAS,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;gBAC9B,OAAO,CAAC,IAAI,CAAC,CAAA,cAAA,EAAiB,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA,QAAA,EAAW,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC,CAAA;YAC3F,CAAC,CAAC,CAAA;SACH;YAED,+NAAO,EAAC,IAAI,CAAC,YAAY,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;YACtC,MAAM,EAAE,OAAO,EAAE,GAAG,EAAA,GAAc,GAAG,EAAZ,IAAI,GAAA,IAAA,mMAAA,EAAK,GAAG,EAA/B;gBAAA;aAAyB,CAAM,CAAA;YACrC,MAAM,MAAM,GAAG,EAAE,CAAA;YACjB,IAAI,GAAG,EAAE;gBACP,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;aACjB;YACD,IAAI,QAAQ,GAAa,EAAE,CAAA;gBAC3B,+NAAO,EAAC,IAAI,EAAE,CAAC,KAAK,EAAE,OAAO,EAAE,EAAE;gBAC/B,QAAQ,CAAC,IAAI,CAAC,KAAK,KAAK,IAAI,CAAC,CAAC,CAAC,GAAG,OAAO,CAAA,IAAA,EAAO,KAAK,EAAE,CAAC,CAAC,CAAC,GAAG,OAAO,EAAE,CAAC,CAAA;YACzE,CAAC,CAAC,CAAA;YACF,IAAI,QAAQ,CAAC,MAAM,EAAE;gBACnB,MAAM,CAAC,IAAI,CAAC,CAAA,EAAA,EAAK,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA,EAAA,CAAI,CAAC,CAAA;aAC1C;YACD,OAAO,CAAC,IAAI,CAAC,CAAA,YAAA,EAAe,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA,MAAA,EAAS,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC,CAAA;QAC9E,CAAC,CAAC,CAAA;QACF,OAAO,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;IAC3B,CAAC;IAEO,kBAAkB,CAAC,SAAS,GAAG,KAAK,EAAA;;QAC1C,MAAM,mBAAmB,GAAG,CAAA,KAAA,IAAI,CAAC,WAAW,CAAC,mBAAmB,MAAA,QAAA,OAAA,KAAA,IAAA,SAAI,qOAAa,EAAE,EAAC,IAAI,CAAA;QACxF,MAAM,EACJ,aAAa,EAAE,EAAE,kBAAkB,EAAE,mBAAmB,EAAE,EAC3D,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,CAAA;QAEvC,IAAI,SAAS,GAAG,KAAK,CAAA;QACrB,MAAM,gBAAgB,GAAG;YAAC,kBAAkB;YAAE,mBAAmB;SAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,KAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAA;QAEzG,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,WAAW,EAAE;YACjC,SAAS,GAAG,gBAAgB,IAAI,IAAI,CAAC,qBAAqB,CAAA;SAC3D,MAAM;YACL,SAAS,GAAG,SAAS,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,IAAI,CAAC,qBAAqB,CAAA;SACtE;QAED,IAAI,SAAS,EAAE;YACb,IAAI,CAAC,YAAY,CAAC,mBAAmB,CAAC,GAAG;gBACvC,IAAI,EAAE,IAAI;aACX,CAAA;SACF;IACH,CAAC;IAEO,iCAAiC,GAAA;QACvC,MAAM,EAAE,kBAAkB,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,aAAa,CAAA;QAChF,qCAAqC;QACrC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC,MAAM,EAAE;YAC3C,OAAO,EAAE,CAAA;SACV;QACD,OAAO;YAAC,CAAA,gBAAA,CAAkB;YAAE,CAAA,iEAAA,CAAmE;SAAC,CAC7F,MAAM,KACL,8NAAM,EAAC,kBAAkB,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;YACtC,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;gBAC3B,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA;gBACzC,OAAO,IAAI,CAAC,UAAU,CACpB,CAAA,IAAA,EAAO,GAAG,CAAA,mHAAA,EAAsH,IAAI,CAAC,SAAS,CAC5I,GAAG,CACJ,CAAA,CAAA,CAAG,EACJ,QAAQ,KAAA,QAAR,QAAQ,KAAA,KAAA,IAAA,KAAA,IAAR,QAAQ,CAAE,WAAW,CACtB,CAAA;aACF;YACD,OAAO,IAAI,CAAC,UAAU,CACpB,CAAA,IAAA,EAAO,GAAG,GAAG,GAAG,CAAC,KAAK,CAAC,cAAc,IAAI,CAAA,oBAAA,CAAsB,EAAE,EACjE,GAAG,CAAC,KAAK,CAAC,eAAe,CAC1B,CAAA;QACH,CAAC,CAAC,CACH,CACA,MAAM,CAAC;YAAC,CAAA,GAAA,CAAK;YAAE,CAAA,CAAA,CAAG;SAAC,CAAC,CACpB,IAAI,CAAC,IAAI,CAAC,CAAA;IACf,CAAC;IAEO,kCAAkC,GAAA;QACxC,MAAM,EAAE,mBAAmB,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,aAAa,CAAA;QACjF,qCAAqC;QACrC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC,MAAM,EAAE;YAC5C,OAAO,EAAE,CAAA;SACV;QACD,OAAO;YAAC,CAAA,gBAAA,CAAkB;YAAE,CAAA,kEAAA,CAAoE;SAAC,CAC9F,MAAM,KACL,8NAAM,EAAC,mBAAmB,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;YACvC,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;gBAC3B,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA;gBACzC,OAAO,IAAI,CAAC,UAAU,CACpB,CAAA,IAAA,EAAO,GAAG,CAAA,8GAAA,EAAiH,IAAI,CAAC,SAAS,CACvI,GAAG,CACJ,CAAA,CAAA,CAAG,EACJ,QAAQ,KAAA,QAAR,QAAQ,KAAA,KAAA,IAAA,KAAA,IAAR,QAAQ,CAAE,WAAW,CACtB,CAAA;aACF;YACD,OAAO,IAAI,CAAC,UAAU,CACpB,CAAA,IAAA,EAAO,GAAG,GAAG,GAAG,CAAC,KAAK,CAAC,cAAc,IAAI,CAAA,oBAAA,CAAsB,EAAE,EACjE,GAAG,CAAC,KAAK,CAAC,eAAe,CAC1B,CAAA;QACH,CAAC,CAAC,CACH,CACA,MAAM,CAAC;YAAC,CAAA,GAAA,CAAK;YAAE,CAAA,CAAA,CAAG;SAAC,CAAC,CACpB,IAAI,CAAC,IAAI,CAAC,CAAA;IACf,CAAC;IAEO,UAAU,CAAC,OAAe,EAAE,eAA+B,EAAA;QACjE,IAAI,MAAM,GAAG,EAAE,CAAA;QACf,IAAI,eAAe,EAAE;YACnB,IAAI,KAAK,GAAG,eAAe,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAC,AAAF,CAAG,QAAQ,EAAE,CAAC,CAAA;YAChE,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE;gBACnB,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;aACvB;YACD,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;gBAClC,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAA;aAC3B;YACD,MAAM,GAAG;gBAAC,SAAS,EAAE;mBAAG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,AAAC,MAAA,EAAS,CAAC,CAAC,CAAC,CAAC,CAAA,CAAA,EAAI,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;gBAAE,SAAS;aAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAA;SACpG;QACD,OAAO,GAAG,MAAM,GAAG,OAAO,EAAE,CAAA;IAC9B,CAAC;IAEO,qCAAqC,GAAA;QAC3C,MAAM,EAAE,uBAAuB,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,aAAa,CAAA;QACrF,qCAAqC;QACrC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,uBAAuB,CAAC,CAAC,MAAM,EAAE;YAChD,OAAO,EAAE,CAAA;SACV;QACD,OAAO;YAAC,CAAA,gBAAA,CAAkB;YAAE,CAAA,qEAAA,CAAuE;SAAC,CACjG,MAAM,KACL,8NAAM,EAAC,uBAAuB,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;YAC3C,OAAO,IAAI,CAAC,UAAU,CACpB,CAAA,IAAA,EAAO,GAAG,GAAG,GAAG,CAAC,KAAK,CAAC,cAAc,IAAI,CAAA,KAAA,CAAO,EAAE,EAClD,GAAG,CAAC,KAAK,CAAC,eAAe,CAC1B,CAAA;QACH,CAAC,CAAC,CACH,CACA,MAAM,CAAC;YAAC,CAAA,GAAA,CAAK;YAAE,CAAA,CAAA,CAAG;SAAC,CAAC,CACpB,IAAI,CAAC,IAAI,CAAC,CAAA;IACf,CAAC;IAEO,sBAAsB,GAAA;QAC5B,MAAM,aAAa,GAGb,EAAE,CAAA;QACR,MAAM,cAAc,GAAG,aAAa,CACjC,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,GAAG,CAAC,8OAAsB,CAAC,CAAC,CACzF,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE;YACT,IAAI,CAAC,CAAC,aAAa,EAAE,CAAC,MAAM,EAAE;gBAC5B,OAAO;oBAAC,CAAC,CAAC,IAAI;oBAAE,CAAC,CAAC,aAAa,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAC,AAAF,CAAG,IAAI,CAAC;iBAAC,CAAA;aACtD;YACD,OAAO,IAAI,CAAA;QACb,CAAC,CAAC,CACD,MAAM,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAyB,CAAA;QAE3C,OAAO;YAAC,2CAA2C;SAAC,CACjD,MAAM,CACL,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,EAAE,UAAU,CAAC,EAAE,EAAE;YACxC,OAAO,CAAA,EAAA,EAAK,IAAI,CAAA,EAAA,EAAK,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,GAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAA;QAC7E,CAAC,CAAC,CACH,CACA,MAAM,CAAC,GAAG,CAAC,CACX,IAAI,CAAC,IAAI,CAAC,CAAA;IACf,CAAC;IAEO,YAAY,GAAA;;QAClB,OAAO,CAAA,CAAA,KAAA,IAAI,CAAC,WAAW,CAAC,iBAAiB,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,KAAK,KAAA,CAAI,CAAA,KAAA,IAAI,CAAC,WAAW,CAAC,iBAAiB,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,MAAM,CAAA,IAAI,KAAK,CAAA;IACzG,CAAC;IAEO,wBAAwB,GAAA;QAC9B,OAAO,IAAI,CAAC,kBAAkB,CAAC,6BAA6B,EAAE,IAAI,CAAC,wBAAwB,EAAE,CAAC,CAAA;IAChG,CAAC;IAEO,wBAAwB,GAAA;QAC9B,MAAM,SAAS,GAAgB,CAAA,CAAE,CAAA;QACjC,MAAM,aAAa,GAAgD,EAAE,CAAA;QACrE,aAAa,CACV,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAC/B,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CACnC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;YAChB,QAAI,wNAAe,EAAC,IAAI,CAAC,EAAE;gBACzB,MAAM,aAAa,GAAG,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,IAAI,CAAC,CAAA;gBAC3E,IAAI,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE;oBAC5B,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,aAAa,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAG,CAAD,GAAK,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;iBACnF;aACF,MAAM;gBACL,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CACxB,QAAQ,EAAE,CACV,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,GAAK,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAClC,IAAI,CAAC,KAAK,CAAC,CAAA;aACf;QACH,CAAC,CAAC,CAAA;QACJ,OAAO,SAAS,CAAA;IAClB,CAAC;IAEO,cAAc,CAAC,IAAwB,EAAE,UAAkB,EAAE,MAAc,EAAA;QACjF,MAAM,GAAG,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAuB,CAAA;QACzD,MAAM,OAAO,GAAG,GAAG,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAA,MAAA,EAAS,MAAM,EAAE,CAAA;QAC9D,OAAO,CAAA,YAAA,EAAe,UAAU,CAAA,GAAA,EAAM,OAAO,CAAA,CAAA,CAAG,CAAA;IAClD,CAAC;IAEO,4BAA4B,CAAC,UAAkB,EAAA;QACrD,MAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,QAAQ,KAAK,SAAS,CAAC,CAAA;QACpF,MAAM,OAAO,GACX,WAAW,CAAC,MAAM,KAAK,CAAC,GACpB,OAAO,GACP,WAAW,CACR,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,GAAK,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAClC,IAAI,EAAE,CACN,IAAI,CAAC,KAAK,CAAC,CAAA;QACpB,OAAO,CAAA,YAAA,EAAe,UAAU,CAAA,GAAA,EAAM,OAAO,CAAA,CAAA,CAAG,CAAA;IAClD,CAAC;IAEO,6BAA6B,CAAC,UAAkB,EAAA;QACtD,MAAM,aAAa,GAAG,CAAC;eAAG,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE;eAAG,IAAI,CAAC,YAAY,CAAC,KAAK;SAAC,CAAC,MAAM,CACvF,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,WAAW,KAAK,SAAS,CACnC,CAAA;QACD,MAAM,OAAO,GACX,aAAa,CAAC,MAAM,KAAK,CAAC,GACtB,OAAO,GACP,aAAa,CAEV,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,GAAK,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAClC,IAAI,EAAE,CACN,IAAI,CAAC,KAAK,CAAC,CAAA;QACpB,OAAO,CAAA,YAAA,EAAe,UAAU,CAAA,GAAA,EAAM,OAAO,CAAA,CAAA,CAAG,CAAA;IAClD,CAAC;IAEO,mBAAmB,CAAC,UAAkB,EAAA;;QAC5C,MAAM,aAAa,GAAG,CAAA,KAAA,CAAA,KAAA,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,QAAQ,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,sBAAsB,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,CAAA,CAAE,CAAA;QAChG,MAAM,UAAU,GAAG,YAAY,KAAC,iOAAS,EAAC,aAAa,EAAE,CAAC,GAAG,EAAE,CAAG,CAAD,EAAI,KAAA,QAAH,GAAG,KAAA,KAAA,IAAH,GAAG,GAAI,KAAK,CAAC,CAAC,CAAA;QAEhF,OAAO;YAAC,CAAA,YAAA,EAAe,UAAU,CAAA,IAAA,CAAM;SAAC,CACrC,MAAM,CAAC,CAAA,0BAAA,EAA6B,UAAU,EAAE,CAAC,CACjD,MAAM,CAAC,GAAG,CAAC,CACX,IAAI,CAAC,IAAI,CAAC,CAAA;IACf,CAAC;IAEO,gBAAgB,GAAA;QACtB,MAAM,OAAO,GAAgB,CAAA,CAAE,CAAA;QAC/B,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE;YACnC,MAAM,UAAU,GAAG,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,IAAI,CAAC,CAAA;YACjD,IAAI,UAAU,EAAE;gBACd,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,UAAU,CAAA;aAC7B,MAAM;gBACL,MAAM,MAAM,GAAG,CAAC,CAAC,SAAS,EAAE,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAG,CAAD,GAAK,CAAC,SAAS,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAA;gBACpE,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;aACrC;QACH,CAAC,CAAC,CAAA;QACF,OAAO,OAAO,CAAA;IAChB,CAAC;IAEO,iBAAiB,GAAA;QACvB,MAAM,WAAW,GAAqB,CAAA,CAAE,CAAA;QACxC,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;gBACxC,+NAAO,EAAC,KAAK,CAAC,SAAS,EAAE,EAAE,CAAC,KAAK,EAAE,EAAE;gBACnC,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAA,CAAE,CAAA;gBACvD,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAA;YAChE,CAAC,CAAC,CAAA;QACJ,CAAC,CAAC,CAAA;QACF,OAAO,WAAW,CAAA;IACpB,CAAC;IAEO,kBAAkB,GAAA;QACxB,MAAM,SAAS,GAAgB,CAAA,CAAE,CAAA;QACjC,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE;;YACrC,QAAI,2NAAqB,EAAC,CAAC,CAAC,EAAE;gBAC5B,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAA,KAAA,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,IAAI,CAAC,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,gBAAgB,CAAC,CAAC,CAAC,IAA4B,CAAC,CAAA;gBACtG,OAAM;aACP;YACD,MAAM,UAAU,GAAG,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,IAAI,CAAC,CAAA;YACjD,IAAI,UAAU,EAAE;gBACd,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,UAAU,CAAA;aAC/B,MAAM;gBACL,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,KAAK,CAAA;aAC1B;QACH,CAAC,CAAC,CAAA;QACF,OAAO,SAAS,CAAA;IAClB,CAAC;IAEO,iBAAiB,GAAA;QACvB,MAAM,YAAY,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAA;QAE7C,IAAI,IAAI,CAAC,WAAW,CAAC,aAAa,EAAE;YAClC,MAAM,cAAc,OAAa,8NAAM,EAAC,YAAY,EAAE,CAAC,MAAM,EAAE,SAAS,EAAE,CACxE,CAD0E,GACtE,CAAC,aAAa,CAAC,SAAS,EAAE,MAAM,CAAC,CACtC,CAAA;YACD,OAAO,CAAC;mBAAG,cAAc;gBAAE,IAAI,CAAC,aAAa,CAAC,gBAAgB,EAAE,YAAY,CAAC;aAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;SAC5F;QAED,OAAO,IAAI,CAAC,uBAAuB,CAAC,gBAAgB,EAAE,YAAY,EAAE,YAAY,CAAC,CAAA;IACnF,CAAC;IAEO,gBAAgB,GAAA;QACtB,MAAM,WAAW,GAAG,IAAI,CAAC,gBAAgB,EAAE,CAAA;QAE3C,IAAI,IAAI,CAAC,WAAW,CAAC,aAAa,EAAE;YAClC,OAAO;uBACF,8NAAM,EAAC,WAAW,EAAE,CAAC,GAAG,EAAE,IAAI,EAAE,CAAG,CAAD,AAAC,YAAA,EAAe,IAAI,CAAA,GAAA,EAAM,GAAG,EAAE,CAAC;gBACrE,IAAI,CAAC,aAAa,CAAC,eAAe,EAAE,WAAW,CAAC;aACjD,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;SACf;QAED,OAAO,IAAI,CAAC,kBAAkB,CAAC,eAAe,EAAE,WAAW,CAAC,CAAA;IAC9D,CAAC;IAEO,kBAAkB,GAAA;QACxB,OAAO,IAAI,CAAC,kBAAkB,CAAC,iBAAiB,EAAE,IAAI,CAAC,kBAAkB,EAAE,CAAC,CAAA;IAC9E,CAAC;IAEO,sBAAsB,CAC5B,YAAiC,EACjC,UAA6B,EAAA;;QAE7B,IAAI,CAAC,CAAA,CAAA,KAAA,CAAA,KAAA,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,QAAQ,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,sBAAsB,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,UAAU,CAAA,EAAE;YACrF,OAAO,KAAK,CAAA;SACb;QAED,IAAI,YAAY,CAAC,WAAW,KAAK,SAAS,EAAE;YAC1C,OAAO,UAAU,CAAA;SAClB;QAED,IAAI,UAAU,CAAC,QAAQ,KAAK,SAAS,EAAE;YACrC,OAAO,UAAU,CAAA;SAClB;QAED,OAAO,UAAU,CAAA;IACnB,CAAC;IAEO,iBAAiB,CAAC,YAAiC,EAAE,UAA6B,EAAA;QACxF,MAAM,kBAAkB,GAAG,IAAI,CAAC,sBAAsB,CAAC,YAAY,EAAE,UAAU,CAAC,CAAA;QAEhF,IAAI,kBAAkB,KAAK,KAAK,EAAE;YAChC,OAAO,CAAA,mBAAA,EAAsB,UAAU,CAAC,IAAI,CAAA,EAAA,CAAI,CAAA;SACjD;QAED,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAA;QAEjC,OAAO,CAAA,mBAAA,EAAsB,UAAU,CAAC,IAAI,CAAA,IAAA,EAAO,kBAAkB,CAAA,EAAA,CAAI,CAAA;IAC3E,CAAC;IAEO,gBAAgB,CAAC,SAA6E,EAAA;QACpG,MAAM,WAAW,GAAoB,CAAA,CAAE,CAAA;QACvC,SAAS,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;YACzB,MAAM,UAAU,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;YACpD,IAAI,UAAU,EAAE;gBACd,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,UAAU,CAAA;gBACnC,OAAM;aACP;YACD,QAAI,oNAAW,EAAC,IAAI,CAAC,EAAE;gBACrB,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAC1B,QAAQ,EAAE,CACV,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,GAAK,CAAC,iBAAiB,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAC3C,IAAI,CAAC,KAAK,CAAC,CAAA;aACf,MAAM,QAAI,wNAAe,EAAC,IAAI,CAAC,EAAE;gBAChC,MAAM,aAAa,GAAG,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,GAAK,CAAC,iBAAiB,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAA;gBACpG,IAAI,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE;oBAC5B,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;iBACnD,MAAM;oBACL,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,KAAK,CAAA;iBAC/B;aACF,MAAM,IAAI,IAAI,CAAC,IAAI,KAAK,OAAO,IAAI,IAAI,CAAC,IAAI,KAAK,UAAU,EAAE;gBAC5D,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAA;aAC9B,MAAM;oBACL,+NAAO,EAAC,IAAI,CAAC,SAAS,EAAE,EAAE,CAAC,KAAK,EAAE,EAAE;oBAClC,MAAM,GAAG,GAAG,AAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAA,CAAE,CAAC,CAAA;oBACnE,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,IAAI,CAAC,EAAE;wBAClC,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;4BAC3B,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG;gCAChB,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,IAAwB,EAAE,KAAK,CAAC;gCACxD,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,IAAI,CAAC;6BACjC,CAAA;yBACF;qBACF;gBACH,CAAC,CAAC,CAAA;aACH;QACH,CAAC,CAAC,CAAA;QACF,OAAO,WAAW,CAAA;IACpB,CAAC;IAEO,iBAAiB,CAAC,QAAgB,EAAA;QACxC,MAAM,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAA;QAC9E,IAAI,UAAU,EAAE;YACd,OAAO,OAAO,UAAU,KAAK,QAAQ,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,UAAU,CAAC,MAAM,CAAA;SACvE;QACD,OAAQ,IAAI,CAAC,WAAW,CAAC,aAAqB,CAAC,QAAQ,CAAC,CAAA;IAC1D,CAAC;IAEO,WAAW,CACjB,KAA6B,EAC7B,uBAAuB;IACvB,KAAwB,EAAA;QAExB,IAAI,KAAK,CAAC,UAAU,QAAI,8OAAiB,EAAC,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE;YACjE,OAAO,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,kBAAkB,CAAA;SACjD;QACD,OAAO,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,CAAA;IAC/B,CAAC;IAEO,kBAAkB,GAAA;QACxB,OAAO,IAAI,CAAC,2BAA2B,CACrC,iBAAiB,EACjB,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAChD,CAAA;IACH,CAAC;IAEO,qBAAqB,GAAA;QAC3B,OAAO,IAAI,CAAC,2BAA2B,CACrC,oBAAoB,EACpB,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CACnD,CAAA;IACH,CAAC;IAEO,iBAAiB,GAAA;QACvB,OAAO,IAAI,CAAC,2BAA2B,CAAC,gBAAgB,EAAE,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAA;IAC3G,CAAC;IAEO,gBAAgB,GAAA;QACtB,MAAM,MAAM,GAAa,EAAE,CAAA;QAC3B,IAAI,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,MAAM,EAAE;YACtC,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAA;SAClC;QACD,IAAI,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,MAAM,EAAE;YACnC,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAA;SAC/B;QACD,IAAI,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,MAAM,EAAE;YAClC,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAA;SAC9B;QACD,OAAO,CAAA,gCAAA,EAAmC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAA;IAChE,CAAC;IAEO,gBAAgB,GAAA;QACtB,MAAM,MAAM,GAAa;YAAC,mBAAmB;SAAC,CAAA;QAC9C,IAAI,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,MAAM,EAAE;YACnC,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAA;SAC/B;QACD,IAAI,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,EAAE;YACjC,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,CAAA;SAC7B;QACD,OAAO,CAAA,+BAAA,EAAkC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAA;IAC/D,CAAC;IAEO,eAAe,GAAA;QACrB,MAAM,UAAU,GAAqC,CAAA,CAAE,CAAA;QACvD,MAAM,SAAS,GAAiD,EAAE,CAAA;QAClE,SAAS,CACN,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAChC,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CACnC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;gBAChB,+NAAO,EAAC,IAAI,CAAC,SAAS,EAAE,EAAE,CAAC,KAAK,EAAE,EAAE;gBAClC,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE;oBACzB,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAA,CAAE,CAAA;oBACnD,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;wBACjE,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,CAAA;wBACtC,OAAO,GAAG,CAAA;oBACZ,CAAC,EAAE,CAAA,CAAsC,CAAC,CAAA;iBAC3C;YACH,CAAC,CAAC,CAAA;QACJ,CAAC,CAAC,CAAA;QACJ,OAAO,UAAU,CAAA;IACnB,CAAC;IAEO,eAAe,GAAA;QACrB,MAAM,UAAU,GAAG,IAAI,CAAC,eAAe,EAAE,CAAA;QACzC,IAAI,IAAI,CAAC,WAAW,CAAC,aAAa,EAAE;YAClC,MAAM,YAAY,GAAa,EAAE,CAAA;gBACjC,+NAAO,EAAC,UAAU,EAAE,CAAC,MAAM,EAAE,QAAQ,EAAE,EAAE;oBACvC,+NAAO,EAAC,MAAM,EAAE,CAAC,IAAI,EAAE,SAAS,EAAE,EAAE;oBAClC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,SAAS,CAAC,EAAE,IAAI,CAAC,CAAC,CAAA;gBACpF,CAAC,CAAC,CAAA;YACJ,CAAC,CAAC,CAAA;YACF,OAAO,CAAC;mBAAG,YAAY;gBAAE,IAAI,CAAC,0BAA0B,CAAC,UAAU,CAAC;aAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;SACnF;QAED,OAAO,IAAI,CAAC,0BAA0B,CAAC,UAAU,CAAC,CAAA;IACpD,CAAC;IAEO,WAAW,CAAC,QAAgB,EAAE,SAAiB,EAAA;QACrD,OAAO,GAAG,QAAQ,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAA,IAAA,CAAM,CAAA;IAC3F,CAAC;IAEO,aAAa,CAAC,IAAY,EAAE,GAAqC,EAAA;QACvE,OAAO;YACL,CAAA,iBAAA,EAAoB,IAAI,CAAA,EAAA,CAAI;mBACzB,8NAAM,EAAC,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,CAAG,CAAD,AAAC,EAAA,EAAK,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,CAAA,CAAA,EAAI,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC;YAC3D,CAAA,CAAA,CAAG;SACJ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;IACd,CAAC;IAEO,aAAa,CAAC,IAAY,EAAE,GAAwB,EAAA;QAC1D,OAAO;YAAC,CAAA,iBAAA,EAAoB,IAAI,CAAA,EAAA,CAAI,EAAE;mBAAG,8NAAM,EAAC,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,CAAG,CAAD,AAAC,EAAA,EAAK,GAAG,CAAA,EAAA,EAAK,GAAG,EAAE,CAAC;YAAE,CAAA,CAAA,CAAG;SAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;IACzG,CAAC;IAEO,kBAAkB,GAAA;QACxB,MAAM,aAAa,GAAqB,CAAA,CAAE,CAAA;QAC1C,MAAM,SAAS,GAAiD,EAAE,CAAA;QAClE,SAAS,CACN,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAChC,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CACnC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;gBAChB,+NAAO,EAAC,IAAI,CAAC,SAAS,EAAE,EAAE,CAAC,KAAK,EAAE,EAAE;gBAClC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAA,CAAE,CAAA;gBACzD,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG;oBAAC,GAAG;oBAAE,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,IAAI,CAAC;iBAAC,CAAA;YAChF,CAAC,CAAC,CAAA;QACJ,CAAC,CAAC,CAAA;QACJ,OAAO,aAAa,CAAA;IACtB,CAAC;IAEO,uBAAuB,GAAA;QAC7B,MAAM,aAAa,GAAqB,CAAA,CAAE,CAAA;QAC1C,MAAM,SAAS,GAAiD,EAAE,CAAA;QAClE,SAAS,CACN,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAChC,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CACnC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;gBAChB,+NAAO,EAAC,IAAI,CAAC,SAAS,EAAE,EAAE,CAAC,KAAK,EAAE,EAAE;gBAClC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAA,CAAE,CAAA;gBACzD,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG;oBAAC,GAAG;oBAAE,CAAA,CAAA,MAAI,qNAAY,EAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,CAAA,CAAA,CAAG;iBAAC,CAAA;YACpF,CAAC,CAAC,CAAA;QACJ,CAAC,CAAC,CAAA;QACJ,OAAO,aAAa,CAAA;IACtB,CAAC;IAEO,eAAe,CAAC,IAAuB,EAAA;QAC7C,MAAM,UAAU,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAA;QACvC,SAAS,OAAO,CAAC,IAAW;YAC1B,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;gBACrB,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;oBAC1B,MAAM,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAA;oBAChC,OAAO,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,OAAO,CAAA,EAAA,CAAI,CAAC,CAAC,CAAC,CAAA,MAAA,EAAS,OAAO,CAAA,CAAA,CAAG,CAAA;iBAC7E;gBACD,OAAO,IAAI,CAAC,CAAC,CAAC,CAAA;aACf;YACD,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;gBAC1B,MAAM,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAA;gBAChC,OAAO,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,OAAO,CAAA,SAAA,CAAW,CAAC,CAAC,CAAC,CAAA,MAAA,EAAS,OAAO,CAAA,QAAA,CAAU,CAAA;aAC3F;YACD,OAAO,GAAG,IAAI,CAAC,CAAC,CAAC,CAAA,OAAA,CAAS,CAAA;QAC5B,CAAC;QACD,OAAO,GAAG,OAAO,CAAC,UAAU,CAAC,CAAA,KAAA,EAAQ,IAAI,EAAE,CAAA;IAC7C,CAAC;IAEO,SAAS,CAAC,IAAuB,EAAA;QACvC,MAAM,MAAM,GAAG,EAAE,CAAA;QACjB,QAAI,sNAAa,EAAC,IAAI,CAAC,EAAE;YACvB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAA;SACnB,MAAM;YACL,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;SAClB;QACD,QAAI,mNAAU,EAAC,IAAI,CAAC,EAAE;YACpB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAA;SACzC,MAAM,QAAI,qNAAY,EAAC,IAAI,CAAC,EAAE;YAC7B,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAA;SACpC,MAAM,QAAI,mNAAU,EAAC,IAAI,CAAC,EAAE;YAC3B,IAAI,IAAI,CAAC,WAAW,CAAC,aAAa,EAAE;gBAClC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;aACvB,MAAM;gBACL,MAAM,CAAC,IAAI,CAAC,CAAA,eAAA,EAAkB,IAAI,CAAC,IAAI,CAAA,EAAA,CAAI,CAAC,CAAA;aAC7C;SACF,MAAM,QAAI,qNAAY,EAAC,IAAI,CAAC,QAAI,wNAAe,EAAC,IAAI,CAAC,QAAI,oNAAW,EAAC,IAAI,CAAC,EAAE;YAC3E,MAAM,CAAC,IAAI,CAAC,CAAA,mBAAA,EAAsB,IAAI,CAAC,IAAI,CAAA,EAAA,CAAI,CAAC,CAAA;SACjD;QACD,OAAO,MAAM,CAAA;IACf,CAAC;IAEO,kBAAkB,GAAA;QACxB,OAAO,IAAI,CAAC,uBAAuB,CAAC,oBAAoB,EAAE,IAAI,CAAC,kBAAkB,EAAE,EAAE,mBAAmB,CAAC,CAAA;IAC3G,CAAC;IAEO,sBAAsB,GAAA;QAC5B,OAAO,IAAI,CAAC,uBAAuB,CACjC,wBAAwB,EACxB,IAAI,CAAC,uBAAuB,EAAE,EAC9B,wBAAwB,CACzB,CAAA;IACH,CAAC;IAEO,YAAY,CAAC,GAAwC,EAAA;QAC3D,OAAO;YAAC,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,EAAE,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;YAAE,IAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC,IAAI,CAAC;SAAC,CAAA;IACvG,CAAC;IAEO,YAAY,CAAC,IAAsB,EAAE,eAAwB,EAAA;QACnE,IAAI,eAAe,QAAI,sNAAa,EAAC,IAAI,CAAC,EAAE;YAC1C,OAAO,GAAG,CAAA;SACX;QAED,OAAO,IAAI,CAAA;IACb,CAAC;IAEO,qBAAqB,CAAC,GAAqB,EAAA;QACjD,MAAM,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAA;QACpC,SAAS,OAAO,CAAC,IAAW;YAC1B,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;gBACrB,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;oBAC1B,MAAM,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAA;oBAChC,OAAO,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,OAAO,CAAA,EAAA,CAAI,CAAC,CAAC,CAAC,CAAA,MAAA,EAAS,OAAO,CAAA,CAAA,CAAG,CAAA;iBAC7E;gBACD,OAAO,IAAI,CAAC,CAAC,CAAC,CAAA;aACf;YACD,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;gBAC1B,MAAM,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAA;gBAChC,OAAO,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,OAAO,CAAA,SAAA,CAAW,CAAC,CAAC,CAAC,CAAA,MAAA,EAAS,OAAO,CAAA,QAAA,CAAU,CAAA;aAC3F;YACD,OAAO,GAAG,IAAI,CAAC,CAAC,CAAC,CAAA,OAAA,CAAS,CAAA;QAC5B,CAAC;QACD,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,CAAA,KAAA,EAAQ,GAAG,EAAE,CAAA;IACzC,CAAC;IAEO,UAAU,CAAC,GAAqB,EAAA;QACtC,MAAM,MAAM,GAAG,EAAE,CAAA;QACjB,QAAI,sNAAa,EAAC,GAAG,CAAC,EAAE;YACtB,GAAG,GAAG,GAAG,CAAC,MAAM,CAAA;SACjB,MAAM;YACL,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;SAClB;QACD,QAAI,mNAAU,EAAC,GAAG,CAAC,EAAE;YACnB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAA;SACzC,MAAM,QAAI,qNAAY,EAAC,GAAG,CAAC,EAAE;YAC5B,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAA;SACnC,MAAM,QAAI,mNAAU,EAAC,GAAG,CAAC,EAAE;YAC1B,IAAI,IAAI,CAAC,WAAW,CAAC,aAAa,EAAE;gBAClC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;aACtB,MAAM;gBACL,MAAM,CAAC,IAAI,CAAC,CAAA,eAAA,EAAkB,GAAG,CAAC,IAAI,CAAA,EAAA,CAAI,CAAC,CAAA;aAC5C;SACF,MAAM,QAAI,0NAAiB,EAAC,GAAG,CAAC,EAAE;YACjC,IAAI,IAAI,CAAC,WAAW,CAAC,aAAa,EAAE;gBAClC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;aACtB,MAAM;gBACL,MAAM,CAAC,IAAI,CAAC,CAAA,gBAAA,EAAmB,GAAG,CAAC,IAAI,CAAA,EAAA,CAAI,CAAC,CAAA;aAC7C;SACF;QACD,OAAO,MAAM,CAAA;IACf,CAAC;IAEO,kBAAkB,CAAC,aAAqB,EAAE,WAAwB,EAAA;QACxE,OAAO;YAAC,CAAA,iBAAA,EAAoB,aAAa,CAAA,EAAA,CAAI;SAAC,CAC3C,MAAM,KAAC,8NAAM,EAAC,WAAW,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,CAAG,CAAA,AAAD,EAAC,EAAK,GAAG,CAAA,EAAA,EAAK,GAAG,EAAE,CAAC,CAAC,CAC7D,MAAM,CAAC,GAAG,CAAC,CACX,IAAI,CAAC,IAAI,CAAC,CAAA;IACf,CAAC;IAEO,2BAA2B,CAAC,aAAqB,EAAE,WAA4B,EAAA;QACrF,OAAO;YAAC,CAAA,iBAAA,EAAoB,aAAa,CAAA,EAAA,CAAI;SAAC,CAC3C,MAAM,KACL,8NAAM,EAAC,WAAW,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;YAC/B,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;gBAC3B,OAAO,CAAA,EAAA,EAAK,GAAG,CAAA,EAAA,EAAK,GAAG,CAAA,CAAA,CAAG,CAAA;aAC3B;YACD,IAAI,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE;gBACjC,OAAO,CAAA,EAAA,EAAK,GAAG,CAAA,KAAA,CAAO,CAAA;aACvB;YACD,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,CAAA;QACnD,CAAC,CAAC,CACH,CACA,MAAM,CAAC,GAAG,CAAC,CACX,IAAI,CAAC,IAAI,CAAC,CAAA;IACf,CAAC;IAEO,uBAAuB,CAAC,aAAqB,EAAE,WAA6B,EAAE,MAAc,EAAA;QAClG,OAAO;YAAC,CAAA,iBAAA,EAAoB,aAAa,CAAA,EAAA,CAAI;SAAC,CAC3C,MAAM,KAAC,8NAAM,EAAC,WAAW,EAAE,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC,CAAC,CACxD,MAAM,CAAC,GAAG,CAAC,CACX,IAAI,CAAC,IAAI,CAAC,CAAA;IACf,CAAC;IAEO,0BAA0B,CAAC,WAA6C,EAAA;QAC9E,OAAO;YAAC,CAAA,mCAAA,CAAqC;SAAC,CAC3C,MAAM,KACL,8NAAM,EAAC,WAAW,EAAE,CAAC,GAAG,EAAE,QAAQ,EAAE,EAAE;YACpC,IAAI,IAAI,CAAC,WAAW,CAAC,aAAa,EAAE;gBAClC,OAAO;oBAAC,CAAA,EAAA,EAAK,QAAQ,CAAA,GAAA,CAAK;iBAAC,CACxB,MAAM,KACL,8NAAM,EAAC,GAAG,EAAE,CAAC,CAAC,EAAE,SAAS,EAAE,CAAG,CAAD,AAAC,IAAA,EAAO,SAAS,CAAA,EAAA,EAAK,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,SAAS,CAAC,EAAE,CAAC,CAC5F,CACA,MAAM,CAAC,KAAK,CAAC,CACb,IAAI,CAAC,IAAI,CAAC,CAAA;aACd;YACD,OAAO;gBAAC,CAAA,EAAA,EAAK,QAAQ,CAAA,GAAA,CAAK;aAAC,CACxB,MAAM,KAAC,8NAAM,EAAC,GAAG,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC,CAAC,CAClD,MAAM,CAAC,KAAK,CAAC,CACb,IAAI,CAAC,IAAI,CAAC,CAAA;QACf,CAAC,CAAC,CACH,CACA,MAAM,CAAC,GAAG,CAAC,CACX,IAAI,CAAC,IAAI,CAAC,CAAA;IACf,CAAC;IAcO,WAAW,CAAC,IAAuB,EAAA;;QACzC,QAAI,2NAAqB,EAAC,IAAI,CAAC,EAAE;YAC/B,OAAO,CAAA,KAAA,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,gBAAgB,CAAC,IAAI,CAAC,IAA4B,CAAC,CAAA;SAChG;QACD,OAAO,CAAA,iBAAA,EAAoB,IAAI,CAAC,IAAI,CAAA,EAAA,CAAI,CAAA;IAC1C,CAAC;IAEO,YAAY,GAAA;QAClB,MAAM,cAAc,GAAa;YAC/B,CAAA,0FAAA,CAA4F;SAC7F,CAAA;QACD,MAAM,mBAAmB,GAAa;YACpC,CAAA,+FAAA,CAAiG;SAClG,CAAA;QACD,MAAM,YAAY,GAAa;YAAC,CAAA,qCAAA,CAAuC;SAAC,CAAA;QACxE,MAAM,eAAe,GAAa;YAAC,CAAA,wCAAA,CAA0C;SAAC,CAAA;QAC9E,MAAM,aAAa,GAAa;YAAC,CAAA,+DAAA,CAAiE;SAAC,CAAA;QACnG,MAAM,kBAAkB,GAAa;YACnC,CAAA,oEAAA,CAAsE;SACvE,CAAA;QACD,MAAM,eAAe,GAAa,EAAE,CAAA;QACpC,MAAM,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,OAAO,IAAI,EAAE,CAAA;QACjE,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;YACzB,IAAI,MAAM,CAAC,MAAM,CAAC,aAAa,EAAE;gBAC/B,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,MAAM,CAAC,CAAC,CAAA;aAClF;YACD,IAAI,MAAM,CAAC,MAAM,CAAC,kBAAkB,EAAE;gBACpC,mBAAmB,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,kBAAkB,CAAC,EAAE,MAAM,CAAC,CAAC,CAAA;aAC5F;YACD,IAAI,MAAM,CAAC,MAAM,CAAC,kBAAkB,EAAE;gBACpC,aAAa,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,kBAAkB,CAAC,EAAE,MAAM,CAAC,CAAC,CAAA;aACtF;YACD,IAAI,MAAM,CAAC,MAAM,CAAC,uBAAuB,EAAE;gBACzC,kBAAkB,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,uBAAuB,CAAC,EAAE,MAAM,CAAC,CAAC,CAAA;aAChG;YACD,IAAI,MAAM,CAAC,MAAM,CAAC,eAAe,EAAE;gBACjC,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,eAAe,CAAC,EAAE,MAAM,CAAC,CAAC,CAAA;aAClF;QACH,CAAC,CAAC,CAAA;QACF,OAAO;YACL,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC;YAC1B;gBACE,kBAAkB;gBAClB;oBACE,aAAa,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;oBACtC,kBAAkB,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;oBAC3C,cAAc,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;oBACvC,mBAAmB,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;oBAC5C,eAAe,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;oBACxC,YAAY,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;iBACtC,CAAC,IAAI,CAAC,IAAI,CAAC;gBACZ,GAAG;aACJ,CAAC,IAAI,CAAC,IAAI,CAAC;SACb,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;IACd,CAAC;IAEO,SAAS,CAAC,OAAkC,EAAA;QAClD,IAAI,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;YAC1B,OAAO,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,GAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;SACxD;QACD,QAAI,iQAAuB,EAAC,OAAO,CAAC,EAAE;YACpC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE;gBAC5B,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAA;YACnB,CAAC,CAAC,CAAA;YACF,OAAO,OAAO,CAAC,QAAQ,EAAE,CAAA;SAC1B;QACD,QAAI,uQAA6B,EAAC,OAAO,CAAC,EAAE;YAC1C,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAA;YACvB,OAAO,EAAE,CAAA;SACV;QACD,OAAO,OAAO,CAAA;IAChB,CAAC;IAEO,SAAS,CAAC,CAAyB,EAAA;QACzC,sBAAA,EAAwB,CACxB,IAAI,KAAC,uQAA6B,EAAC,CAAC,CAAC,EAAE;YACrC,OAAO,CAAC,IAAI,CAAC,CAAA,qCAAA,EAAwC,CAAC,EAAE,CAAC,CAAA;YACzD,OAAM;SACP;QACD,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAA,CAAE,CAAA;QAC7E,IAAI,CAAC,CAAC,MAAM,CAAC,OAAO,EAAE;YACpB,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,OAAO,GAAG,CAAC,CAAC,MAAM,CAAC,OAAO,CAAA;SAC9D;QACD,IAAI,CAAC,CAAC,MAAM,CAAC,QAAQ,EAAE;YACrB,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;gBACpC,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;oBAC/B,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,GAAG,IAAI,CAAA;iBACnD,MAAM;oBACL,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC,CAAA;iBAC5D;YACH,CAAC,CAAC,CAAA;SACH;IACH,CAAC;CACF;AAED,SAAS,OAAO,CAAC,GAAW,EAAE,OAAe;IAC3C,OAAO,GAAG,CACP,KAAK,CAAC,IAAI,CAAC,CACX,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,EAAI,OAAO,GAAG,CAAC,EAAE,CAAC,CAC5B,IAAI,CAAC,IAAI,CAAC,CAAA;AACf,CAAC;AAED,MAAM,kBAAkB,GAAG,CAAA;;;EAGzB,CAAA;AAEF,SAAS,YAAY,CAAC,MAA2B;IAC/C,OAAO;QACL,GAAG;YACH,8NAAM,EAAC,MAAM,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;YAC1B,OAAO,CAAA,IAAA,EAAO,GAAG,CAAA,EAAA,EAAK,GAAG,EAAE,CAAA;QAC7B,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;QACb,KAAK;KACN,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;AACd,CAAC"}},
    {"offset": {"line": 5841, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/typegenMetadata.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/typegenMetadata.ts"],"sourcesContent":["import { GraphQLSchema, lexicographicSortSchema, printSchema } from 'graphql'\nimport * as path from 'path'\nimport type { BuilderConfigInput, TypegenInfo } from './builder'\nimport type { ConfiguredTypegen } from './core'\nimport type { NexusGraphQLSchema } from './definitions/_types'\nimport { SDL_HEADER, TYPEGEN_HEADER } from './lang'\nimport { typegenAutoConfig } from './typegenAutoConfig'\nimport { TypegenFormatFn, typegenFormatPrettier } from './typegenFormatPrettier'\nimport { TypegenPrinter } from './typegenPrinter'\n\nexport interface TypegenMetadataConfig\n  extends Omit<BuilderConfigInput, 'outputs' | 'shouldGenerateArtifacts'> {\n  nexusSchemaImportId?: string\n  outputs: {\n    schema: null | string\n    typegen: null | ConfiguredTypegen\n  }\n}\n\n/**\n * Passed into the SchemaBuilder, this keeps track of any necessary field / type metadata we need to be aware\n * of when building the generated types and/or SDL artifact, including but not limited to:\n */\nexport class TypegenMetadata {\n  constructor(protected config: TypegenMetadataConfig) {}\n\n  /** Generates the artifacts of the build based on what we know about the schema and how it was defined. */\n  async generateArtifacts(schema: NexusGraphQLSchema) {\n    const sortedSchema = this.sortSchema(schema)\n    const { typegen } = this.config.outputs\n    if (this.config.outputs.schema || typegen) {\n      const { schemaTypes, tsTypes, globalTypes } = await this.generateArtifactContents(sortedSchema, typegen)\n      if (this.config.outputs.schema) {\n        await this.writeFile('schema', schemaTypes, this.config.outputs.schema)\n      }\n      if (typegen) {\n        if (typeof typegen === 'string') {\n          await this.writeFile('types', tsTypes, typegen)\n        } else {\n          await this.writeFile('types', tsTypes, typegen.outputPath)\n          if (typeof typegen.globalsPath === 'string') {\n            await this.writeFile('types', globalTypes ?? '', typegen.globalsPath)\n          }\n        }\n      }\n    }\n  }\n\n  async generateArtifactContents(schema: NexusGraphQLSchema, typegen: string | null | ConfiguredTypegen) {\n    const result = {\n      schemaTypes: this.generateSchemaFile(schema),\n      tsTypes: '',\n      globalTypes: null as null | string,\n    }\n    if (!typegen) {\n      return result\n    }\n    if (typeof typegen === 'string') {\n      result.tsTypes = await this.generateTypesFile(schema, typegen)\n    } else {\n      const generateResult = await this.generateConfiguredTypes(schema, typegen)\n      result.tsTypes = generateResult.tsTypes\n      result.globalTypes = generateResult.globalTypes\n    }\n    return result\n  }\n\n  sortSchema(schema: NexusGraphQLSchema) {\n    let sortedSchema = schema\n    if (typeof lexicographicSortSchema !== 'undefined') {\n      sortedSchema = lexicographicSortSchema(schema) as NexusGraphQLSchema\n    }\n    return sortedSchema\n  }\n\n  async writeFile(type: 'schema' | 'types', output: string, filePath: string) {\n    if (typeof filePath !== 'string' || !path.isAbsolute(filePath)) {\n      return Promise.reject(\n        new Error(`Expected an absolute path to output the Nexus ${type}, saw ${filePath}`)\n      )\n    }\n    const fs = require('fs') as typeof import('fs')\n    const util = require('util') as typeof import('util')\n    const [readFile, writeFile, removeFile, mkdir] = [\n      util.promisify(fs.readFile),\n      util.promisify(fs.writeFile),\n      util.promisify(fs.unlink),\n      util.promisify(fs.mkdir),\n    ]\n    let formatTypegen: TypegenFormatFn | null = null\n    if (typeof this.config.formatTypegen === 'function') {\n      formatTypegen = this.config.formatTypegen\n    } else if (this.config.prettierConfig) {\n      formatTypegen = typegenFormatPrettier(this.config.prettierConfig)\n    }\n    const content = typeof formatTypegen === 'function' ? await formatTypegen(output, type) : output\n    const [toSave, existing] = await Promise.all([content, readFile(filePath, 'utf8').catch(() => '')])\n    if (toSave !== existing) {\n      const dirPath = path.dirname(filePath)\n      try {\n        await mkdir(dirPath, { recursive: true })\n      } catch (e) {\n        if (e.code !== 'EEXIST') {\n          throw e\n        }\n      }\n      // VSCode reacts to file changes better if a file is first deleted,\n      // apparently. See issue motivating this logic here:\n      // https://github.com/graphql-nexus/schema/issues/247.\n      try {\n        await removeFile(filePath)\n      } catch (e) {\n        /* istanbul ignore next */\n        if (e.code !== 'ENOENT' && e.code !== 'ENOTDIR') {\n          throw e\n        }\n      }\n      return writeFile(filePath, toSave)\n    }\n  }\n\n  /** Generates the schema, adding any directives as necessary */\n  generateSchemaFile(schema: GraphQLSchema): string {\n    let printedSchema = this.config.customPrintSchemaFn\n      ? this.config.customPrintSchemaFn(schema)\n      : printSchema(schema)\n    return [SDL_HEADER, printedSchema].join('\\n\\n')\n  }\n\n  /** Generates the type definitions */\n  async generateTypesFile(schema: NexusGraphQLSchema, typegenPath: string): Promise<string> {\n    const typegenInfo = await this.getTypegenInfo(schema, typegenPath)\n\n    return new TypegenPrinter(schema, {\n      declareInputs: false,\n      ...typegenInfo,\n      typegenPath,\n    }).print()\n  }\n\n  /** Generates the type definitions */\n  async generateConfiguredTypes(schema: NexusGraphQLSchema, typegen: ConfiguredTypegen) {\n    const { outputPath: typegenPath, globalsPath, globalsHeaders, declareInputs = false } = typegen\n    const typegenInfo = await this.getTypegenInfo(schema, typegenPath)\n\n    return new TypegenPrinter(schema, {\n      ...typegenInfo,\n      typegenPath,\n      globalsPath,\n      globalsHeaders,\n      declareInputs,\n    }).printConfigured()\n  }\n\n  async getTypegenInfo(schema: GraphQLSchema, typegenPath?: string): Promise<TypegenInfo> {\n    if ('typegenConfig' in this.config) {\n      throw new Error(\n        'Error: typegenConfig was removed from the API. Please open an issue if you were using it.'\n      )\n    }\n\n    if (this.config.sourceTypes) {\n      return typegenAutoConfig(this.config.sourceTypes, this.config.contextType)(\n        schema,\n        typegenPath || this.config.outputs.typegen?.outputPath || ''\n      )\n    }\n\n    return {\n      nexusSchemaImportId: this.config.nexusSchemaImportId,\n      headers: [TYPEGEN_HEADER],\n      imports: [],\n      contextTypeImport: this.config.contextType,\n      sourceTypeMap: {},\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6016, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/typegenUtils.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/typegenUtils.ts"],"sourcesContent":["import * as path from 'path'\nimport type { BuilderConfigInput } from './builder'\nimport type { ConfiguredTypegen } from './core'\nimport type { TypegenMetadataConfig } from './typegenMetadata'\nimport { assertAbsolutePath, getOwnPackage, isProductionStage } from './utils'\n\n/** Normalizes the builder config into the config we need for typegen */\nexport function resolveTypegenConfig(config: BuilderConfigInput): TypegenMetadataConfig {\n  const {\n    outputs,\n    shouldGenerateArtifacts = Boolean(!process.env.NODE_ENV || process.env.NODE_ENV !== 'production'),\n    ...rest\n  } = config\n\n  const defaultSDLFilePath = path.join(process.cwd(), 'schema.graphql')\n\n  let typegenFilePath: ConfiguredTypegen | null = null\n  let sdlFilePath: string | null = null\n\n  if (outputs === undefined) {\n    if (isProductionStage()) {\n      sdlFilePath = defaultSDLFilePath\n    }\n  } else if (outputs === true) {\n    sdlFilePath = defaultSDLFilePath\n  } else if (typeof outputs === 'object') {\n    if (outputs.schema === true) {\n      sdlFilePath = defaultSDLFilePath\n    } else if (typeof outputs.schema === 'string') {\n      sdlFilePath = assertAbsolutePath(outputs.schema, 'outputs.schema')\n    } else if (outputs.schema === undefined && isProductionStage()) {\n    }\n    // handle typegen configuration\n    if (typeof outputs.typegen === 'string') {\n      typegenFilePath = {\n        outputPath: assertAbsolutePath(outputs.typegen, 'outputs.typegen'),\n      }\n    } else if (typeof outputs.typegen === 'object') {\n      typegenFilePath = {\n        ...outputs.typegen,\n        outputPath: assertAbsolutePath(outputs.typegen.outputPath, 'outputs.typegen.outputPath'),\n      } as ConfiguredTypegen\n      if (outputs.typegen.globalsPath) {\n        typegenFilePath.globalsPath = assertAbsolutePath(\n          outputs.typegen.globalsPath,\n          'outputs.typegen.globalsPath'\n        )\n      }\n    }\n  } else if (outputs !== false) {\n    console.warn(\n      `You should specify a configuration value for outputs in Nexus' makeSchema. ` +\n        `Provide one to remove this warning.`\n    )\n  }\n\n  return {\n    ...rest,\n    nexusSchemaImportId: getOwnPackage().name,\n    outputs: {\n      typegen: shouldGenerateArtifacts ? typegenFilePath : null,\n      schema: shouldGenerateArtifacts ? sdlFilePath : null,\n    },\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA,OAAO,KAAK,IAAI,MAAM,MAAM,CAAA;AAI5B,OAAO,EAAE,kBAAkB,EAAE,aAAa,EAAE,iBAAiB,EAAE,MAAM,SAAS,CAAA;;;;AAGxE,SAAU,oBAAoB,CAAC,MAA0B;IAC7D,MAAM,EACJ,OAAO,EACP,uBAAuB,GAAG,OAAO,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,+BAAI,OAAO,CAAC,GAAG,CAAC,QAAQ,gCAAK,YAAY,CAAC,EAAA,GAE/F,MAAM,EADL,IAAI,GAAA,IAAA,mMAAA,EACL,MAAM,EAJJ;QAAA;QAAA;KAIL,CAAS,CAAA;IAEV,MAAM,kBAAkB,GAAG,IAAI,CAAC,oGAAI,CAAC,OAAO,CAAC,GAAG,EAAE,EAAE,gBAAgB,CAAC,CAAA;IAErE,IAAI,eAAe,GAA6B,IAAI,CAAA;IACpD,IAAI,WAAW,GAAkB,IAAI,CAAA;IAErC,IAAI,OAAO,KAAK,SAAS,EAAE;QACzB,QAAI,yOAAiB,EAAE,GAAE;YACvB,WAAW,GAAG,kBAAkB,CAAA;SACjC;KACF,MAAM,IAAI,OAAO,KAAK,IAAI,EAAE;QAC3B,WAAW,GAAG,kBAAkB,CAAA;KACjC,MAAM,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;QACtC,IAAI,OAAO,CAAC,MAAM,KAAK,IAAI,EAAE;YAC3B,WAAW,GAAG,kBAAkB,CAAA;SACjC,MAAM,IAAI,OAAO,OAAO,CAAC,MAAM,KAAK,QAAQ,EAAE;YAC7C,WAAW,OAAG,0OAAkB,EAAC,OAAO,CAAC,MAAM,EAAE,gBAAgB,CAAC,CAAA;SACnE,MAAM,IAAI,OAAO,CAAC,MAAM,KAAK,SAAS,QAAI,yOAAiB,EAAE,GAAE,EAC/D;QACD,+BAA+B;QAC/B,IAAI,OAAO,OAAO,CAAC,OAAO,KAAK,QAAQ,EAAE;YACvC,eAAe,GAAG;gBAChB,UAAU,MAAE,0OAAkB,EAAC,OAAO,CAAC,OAAO,EAAE,iBAAiB,CAAC;aACnE,CAAA;SACF,MAAM,IAAI,OAAO,OAAO,CAAC,OAAO,KAAK,QAAQ,EAAE;YAC9C,eAAe,GAAG,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACb,OAAO,CAAC,OAAO,GAAA;gBAClB,UAAU,MAAE,0OAAkB,EAAC,OAAO,CAAC,OAAO,CAAC,UAAU,EAAE,4BAA4B,CAAC;YAAA,EACpE,CAAA;YACtB,IAAI,OAAO,CAAC,OAAO,CAAC,WAAW,EAAE;gBAC/B,eAAe,CAAC,WAAW,OAAG,0OAAkB,EAC9C,OAAO,CAAC,OAAO,CAAC,WAAW,EAC3B,6BAA6B,CAC9B,CAAA;aACF;SACF;KACF,MAAM,IAAI,OAAO,KAAK,KAAK,EAAE;QAC5B,OAAO,CAAC,IAAI,CACV,CAAA,2EAAA,CAA6E,GAC3E,CAAA,mCAAA,CAAqC,CACxC,CAAA;KACF;IAED,OAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACK,IAAI,GAAA;QACP,mBAAmB,MAAE,qOAAa,EAAE,EAAC,IAAI;QACzC,OAAO,EAAE;YACP,OAAO,EAAE,uBAAuB,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,IAAI;YACzD,MAAM,EAAE,uBAAuB,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,IAAI;SACrD;IAAA,GACF;AACH,CAAC"}},
    {"offset": {"line": 6074, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/makeSchema.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/makeSchema.ts"],"sourcesContent":["import { ConfiguredTypegen, makeSchemaInternal, SchemaConfig } from './builder'\nimport type { NexusGraphQLSchema } from './definitions/_types'\nimport { TypegenMetadata } from './typegenMetadata'\nimport { resolveTypegenConfig } from './typegenUtils'\nimport { assertNoMissingTypes, runAbstractTypeRuntimeChecks } from './utils'\n\n/**\n * Defines the GraphQL schema, by combining the GraphQL types defined by the GraphQL Nexus layer or any\n * manually defined GraphQLType objects.\n *\n * Requires at least one type be named \"Query\", which will be used as the root query type.\n */\nexport function makeSchema(config: SchemaConfig): NexusGraphQLSchema {\n  const { schema, missingTypes, finalConfig } = makeSchemaInternal(config)\n  const typegenConfig = resolveTypegenConfig(finalConfig)\n  const sdl = typegenConfig.outputs.schema\n  const typegen = typegenConfig.outputs.typegen\n  if (sdl || typegen) {\n    // Generating in the next tick allows us to use the schema\n    // in the optional thunk for the typegen config\n    const typegenPromise = new TypegenMetadata(typegenConfig).generateArtifacts(schema)\n    if (config.shouldExitAfterGenerateArtifacts) {\n      let typegenPath = '(not enabled)'\n      if (typegenConfig.outputs.typegen) {\n        typegenPath = typegenConfig.outputs.typegen.outputPath\n        if (typegenConfig.outputs.typegen.globalsPath) {\n          typegenPath += ` / ${typegenConfig.outputs.typegen.globalsPath}`\n        }\n      }\n      typegenPromise\n        .then(() => {\n          console.log(`Generated Artifacts:\n          TypeScript Types  ==> ${typegenPath}\n          GraphQL Schema    ==> ${typegenConfig.outputs.schema || '(not enabled)'}`)\n          process.exit(0)\n        })\n        .catch((e) => {\n          console.error(e)\n          process.exit(1)\n        })\n    } else {\n      typegenPromise.catch((e) => {\n        console.error(e)\n      })\n    }\n  }\n  assertNoMissingTypes(schema, missingTypes)\n  runAbstractTypeRuntimeChecks(schema, finalConfig.features)\n  return schema\n}\n\n/** Like makeSchema except that typegen is always run and waited upon. */\nexport async function generateSchema(config: SchemaConfig): Promise<NexusGraphQLSchema> {\n  const { schema, missingTypes, finalConfig } = makeSchemaInternal(config)\n  const typegenConfig = resolveTypegenConfig(finalConfig)\n  await new TypegenMetadata(typegenConfig).generateArtifacts(schema)\n  assertNoMissingTypes(schema, missingTypes)\n  runAbstractTypeRuntimeChecks(schema, finalConfig.features)\n  return schema\n}\n\n/**\n * Mainly useful for testing, generates the schema and returns the artifacts that would have been otherwise\n * written to the filesystem.\n */\ngenerateSchema.withArtifacts = async (\n  config: SchemaConfig,\n  typegen: string | null | ConfiguredTypegen = null\n): Promise<{\n  schema: NexusGraphQLSchema\n  schemaTypes: string\n  tsTypes: string\n  globalTypes: string | null\n}> => {\n  const { schema, missingTypes, finalConfig } = makeSchemaInternal(config)\n  const typegenConfig = resolveTypegenConfig(finalConfig)\n  const { schemaTypes, tsTypes, globalTypes } = await new TypegenMetadata(\n    typegenConfig\n  ).generateArtifactContents(schema, typegen)\n  assertNoMissingTypes(schema, missingTypes)\n  runAbstractTypeRuntimeChecks(schema, finalConfig.features)\n  return { schema, schemaTypes, tsTypes, globalTypes }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6156, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/definitions/extendInputType.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/definitions/extendInputType.ts"],"sourcesContent":["import { assertValidName } from 'graphql'\nimport type { GetGen } from '../typegenTypeHelpers'\nimport type { InputDefinitionBlock } from './definitionBlocks'\nimport { NexusTypes, withNexusSymbol } from './_types'\n\nexport interface NexusExtendInputTypeConfig<TypeName extends string> {\n  type: TypeName\n  definition(t: InputDefinitionBlock<TypeName>): void\n}\n\nexport class NexusExtendInputTypeDef<TypeName extends string> {\n  constructor(readonly name: TypeName, protected config: NexusExtendInputTypeConfig<any> & { name: string }) {\n    assertValidName(name)\n  }\n  get value() {\n    return this.config\n  }\n}\n\nwithNexusSymbol(NexusExtendInputTypeDef, NexusTypes.ExtendInputObject)\n\n/**\n * Adds new fields to an existing inputObjectType in the schema. Useful when splitting your schema across\n * several domains.\n *\n * @see https://nexusjs.org/docs/api/extend-type\n */\nexport function extendInputType<TypeName extends GetGen<'inputNames', string>>(\n  config: NexusExtendInputTypeConfig<TypeName>\n) {\n  return new NexusExtendInputTypeDef(config.type, {\n    ...config,\n    name: config.type,\n  })\n}\n"],"names":[],"mappings":";;;;;;AAAA,OAAO,EAAE,eAAe,EAAE,MAAM,SAAS,CAAA;AAGzC,OAAO,EAAE,UAAU,EAAE,eAAe,EAAE,MAAM,UAAU,CAAA;;;AAOhD,MAAO,uBAAuB;IAClC,YAAqB,IAAc,EAAY,MAA0D,CAAA;QAApF,IAAA,CAAA,IAAI,GAAJ,IAAI,CAAU;QAAY,IAAA,CAAA,MAAM,GAAN,MAAM,CAAoD;YACvG,kOAAe,EAAC,IAAI,CAAC,CAAA;IACvB,CAAC;IACD,IAAI,KAAK,GAAA;QACP,OAAO,IAAI,CAAC,MAAM,CAAA;IACpB,CAAC;CACF;IAED,uPAAe,EAAC,uBAAuB,EAAE,kPAAU,CAAC,iBAAiB,CAAC,CAAA;AAQhE,SAAU,eAAe,CAC7B,MAA4C;IAE5C,OAAO,IAAI,uBAAuB,CAAC,MAAM,CAAC,IAAI,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACzC,MAAM,GAAA;QACT,IAAI,EAAE,MAAM,CAAC,IAAI;IAAA,GACjB,CAAA;AACJ,CAAC"}},
    {"offset": {"line": 6186, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/definitions/extendType.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/definitions/extendType.ts"],"sourcesContent":["import { assertValidName } from 'graphql'\nimport type { AllOutputTypesPossible } from '../typegenTypeHelpers'\nimport type { ObjectDefinitionBlock } from './objectType'\nimport type { IsSubscriptionType, SubscriptionBuilder } from './subscriptionType'\nimport { NexusTypes, withNexusSymbol } from './_types'\n\nexport interface NexusExtendTypeConfig<TypeName extends string> {\n  /**\n   * The name of the type you want to extend.\n   *\n   * Nexus types this as all the object types in your schema but you can add new types here as well and Nexus\n   * will create them for you. Note that this will appear to be a static type error until the next Nexus\n   * reflection run.\n   *\n   * @example\n   *   'Query'\n   */\n  type: TypeName\n  /**\n   * Define the fields you want to extend the type with. This method works almost exactly like the objectType\n   * \"definition\" method.\n   *\n   * @param t The type builder. Usually the same as that passed to objectType \"definition\" method except if\n   *   extending the Subscription type in which case you get a subscription type builder (which differs\n   *   slightly in that it requires implementation of a \"subscribe\" method on field configurations).\n   */\n  definition(\n    t: IsSubscriptionType<TypeName> extends true ? SubscriptionBuilder : ObjectDefinitionBlock<TypeName>\n  ): void\n}\n\nexport class NexusExtendTypeDef<TypeName extends string> {\n  constructor(\n    readonly name: TypeName,\n    protected config: NexusExtendTypeConfig<TypeName> & { name: TypeName }\n  ) {\n    assertValidName(name)\n  }\n  get value() {\n    return this.config\n  }\n}\n\nwithNexusSymbol(NexusExtendTypeDef, NexusTypes.ExtendObject)\n\n/**\n * [API Docs](https://nxs.li/docs/api/extend-type)\n *\n * Add new fields to an existing objectType.\n *\n * This is useful when splitting your schema's type definitions across modules wherein each module is\n * concerned with its own domain (User, Post, Comment, etc.). You may discover that some types are shared\n * across domains and you want to co-locate the definition of the field contributions to where the domains\n * they relate to are.\n *\n * A classic example is contributing fields to root types Query, Mutation, or Subscription. Note that this\n * use-case is so common Nexus ships dedicated functions for it: queryField, mutationField, subscriptionField.\n *\n * You can extend types before defining them strictly with objectType or the root field functions (queryType\n * etc.). The typing for \"type\" property will appear to suggest that you cannot, however once Nexus reflection\n * has run you'll see that the type you \"extended\" exists in the schema and that your static typing error has\n * been resolved. This behaviour is a convenience especially when extending root types which you might never\n * define in your schema directly.\n *\n * @example\n *   // types/User.ts\n *\n *   export const User = objectType({\n *     name: 'User',\n *     // ...\n *   })\n *\n *   // Remember: It does not matter if you have\n *   // used queryType(...) elsewhere or not.\n *\n *   export const UserQuery = extendType({\n *     type: 'Query',\n *     definition(t) {\n *       t.list.nonNull.field('users', {\n *         type: 'User',\n *         resolve() {\n *           return // ...\n *         },\n *       })\n *     },\n *   })\n *\n * @param config The specification of which type to extend and how. This is basically a subset of the\n *   configuration object passed to the objectType function.\n */\nexport function extendType<TypeName extends AllOutputTypesPossible>(config: NexusExtendTypeConfig<TypeName>) {\n  return new NexusExtendTypeDef(config.type, { ...config, name: config.type }) as NexusExtendTypeDef<any>\n}\n"],"names":[],"mappings":";;;;;;AAAA,OAAO,EAAE,eAAe,EAAE,MAAM,SAAS,CAAA;AAIzC,OAAO,EAAE,UAAU,EAAE,eAAe,EAAE,MAAM,UAAU,CAAA;;;AA2BhD,MAAO,kBAAkB;IAC7B,YACW,IAAc,EACb,MAA4D,CAAA;QAD7D,IAAA,CAAA,IAAI,GAAJ,IAAI,CAAU;QACb,IAAA,CAAA,MAAM,GAAN,MAAM,CAAsD;YAEtE,kOAAe,EAAC,IAAI,CAAC,CAAA;IACvB,CAAC;IACD,IAAI,KAAK,GAAA;QACP,OAAO,IAAI,CAAC,MAAM,CAAA;IACpB,CAAC;CACF;IAED,uPAAe,EAAC,kBAAkB,EAAE,kPAAU,CAAC,YAAY,CAAC,CAAA;AA+CtD,SAAU,UAAU,CAA0C,MAAuC;IACzG,OAAO,IAAI,kBAAkB,CAAC,MAAM,CAAC,IAAI,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAO,MAAM,GAAA;QAAE,IAAI,EAAE,MAAM,CAAC,IAAI;IAAA,GAA8B,CAAA;AACzG,CAAC"}},
    {"offset": {"line": 6216, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/definitions/mutationField.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/definitions/mutationField.ts"],"sourcesContent":["import type { FieldOutConfig, OutputDefinitionBlock } from './definitionBlocks'\nimport { extendType, NexusExtendTypeDef } from './extendType'\n\nexport type MutationFieldConfig<FieldName extends string> =\n  | FieldOutConfig<'Mutation', FieldName>\n  | (() => FieldOutConfig<'Mutation', FieldName>)\n\n/**\n * [API Docs](https://nexusjs.org/docs/api/mutation-field) | [2018 GraphQL\n * Spec](https://spec.graphql.org/June2018/#sec-Mutation)\n *\n * Define one or more fields on the Mutation type.\n *\n * Use this if you are going to modularize your schema and thus be wanting to contribute fields to Mutation\n * type from multiple modules. You do not have to have previously defined a Mutation type before using this.\n * If you haven't Nexus will create one automatically for you.\n *\n * This is shorthand for:\n *\n * `extendType({ type: 'Mutation' })`\n *\n * If you need to leverage plugins or define multiple fields then use the typeBuilder overload variant of this\n * function. Otherwise you may prefer to the field name/config variant.\n *\n * @example\n *   // User.ts\n *   // Overload 1: Type Builder\n *\n *   mutationField((t) => {\n *     t.field('signup', {\n *       type: 'User',\n *       args: {\n *         email: stringArg(),\n *       },\n *       // ...\n *     })\n *     t.field('deactivate', {\n *       type: 'User',\n *       args: {\n *         userId: idArg(),\n *       },\n *       // ...\n *     })\n *   })\n *\n * @example\n *   // User.ts\n *   // Overload 2: Field Name/Config\n *\n *   mutationField('signup', {\n *     type: 'User',\n *     args: {\n *       email: stringArg(),\n *     },\n *     // ...\n *   })\n *\n * @param typeBuilder The same as the \"definition\" method you define on object type configurations.\n */\nexport function mutationField(\n  typeBuilder: (t: OutputDefinitionBlock<'Mutation'>) => void\n): NexusExtendTypeDef<'Mutation'>\n\n/**\n * [API Docs](https://nexusjs.org/docs/api/mutation-field) | [2018 GraphQL\n * Spec](https://spec.graphql.org/June2018/#sec-Mutation)\n *\n * Define one or more fields on the mutation type.\n *\n * The Mutation type is one of three [root types](https://spec.graphql.org/June2018/#sec-Root-Operation-Types)\n * in GraphQL and its fields represent API operations your clients can run that may have side-effects.\n *\n * Use this instead of mutationType if you are going to modularize your schema and thus be wanting to\n * contribute fields to Mutation type from multiple modules. You do not have to have previously defined a\n * Mutation type before using this. If you haven't Nexus will create one automatically for you.\n *\n * This is shorthand for:\n *\n * `extendType({ type: 'Mutation' })`\n *\n * If you need to leverage plugins or define multiple fields then use the typeBuilder overload variant of this\n * function. Otherwise you may prefer to the field name/config variant.\n *\n * @example\n *   // User.ts\n *   // Overload 1: Type Builder\n *\n *   mutationField((t) => {\n *     t.field('signup', {\n *       type: 'User',\n *       args: {\n *         email: stringArg(),\n *       },\n *       // ...\n *     })\n *     t.field('deactivate', {\n *       type: 'User',\n *       args: {\n *         userId: idArg(),\n *       },\n *       // ...\n *     })\n *   })\n *\n * @example\n *   // User.ts\n *   // Overload 2: Field Name/Config\n *\n *   mutationField('signup', {\n *     type: 'User',\n *     args: {\n *       email: stringArg(),\n *     },\n *     // ...\n *   })\n *\n * @param name The name of the field on the Mutation type. Names are case‚Äêsensitive and must conform to\n *     pattern: `[_A-Za-z][_0-9A-Za-z]*`\n * @param config The same type of configuration you would pass to t.field(\"...\", config)\n */\nexport function mutationField<FieldName extends string>(\n  name: FieldName,\n  config: MutationFieldConfig<FieldName>\n): NexusExtendTypeDef<'Mutation'>\n\nexport function mutationField(...args: any[]) {\n  return extendType({\n    type: 'Mutation',\n    definition(t) {\n      if (typeof args[0] === 'function') {\n        return args[0](t)\n      }\n      const [fieldName, config] = args as [string, MutationFieldConfig<any>]\n      const finalConfig = typeof config === 'function' ? config() : config\n      t.field(fieldName, finalConfig)\n    },\n  })\n}\n"],"names":[],"mappings":";;;;AACA,OAAO,EAAE,UAAU,EAAsB,MAAM,cAAc,CAAA;;AA4HvD,SAAU,aAAa,CAAC,GAAG,IAAW;IAC1C,WAAO,sPAAU,EAAC;QAChB,IAAI,EAAE,UAAU;QAChB,UAAU,EAAC,CAAC;YACV,IAAI,OAAO,IAAI,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;gBACjC,OAAO,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAA;aAClB;YACD,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC,GAAG,IAA0C,CAAA;YACtE,MAAM,WAAW,GAAG,OAAO,MAAM,KAAK,UAAU,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,MAAM,CAAA;YACpE,CAAC,CAAC,KAAK,CAAC,SAAS,EAAE,WAAW,CAAC,CAAA;QACjC,CAAC;KACF,CAAC,CAAA;AACJ,CAAC"}},
    {"offset": {"line": 6239, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/definitions/mutationType.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/definitions/mutationType.ts"],"sourcesContent":["import { NexusObjectTypeConfig, objectType } from './objectType'\n\n/**\n * [2018 GraphQL Spec](https://spec.graphql.org/June2018/#sec-Mutation)\n *\n * Define a Mutation type.\n *\n * The Mutation type is one of three [root types](https://spec.graphql.org/June2018/#sec-Root-Operation-Types)\n * in GraphQL and its fields represent API operations your clients can run that may have side-effects.\n *\n * You can only have one of these in your schema. If you are going to modularize your schema and thus be\n * wanting to contribute fields to Mutation type from multiple modules then use\n * [mutationField](https://nxs.li/docs/api/mutation-field) intead.\n *\n * This is a shorthand for:\n *\n * `objectType({ name: 'Mutation' })`\n *\n * @example\n *   mutationType({\n *     definition(t) {\n *       t.field('signup', {\n *         type: 'User',\n *         args: {\n *           email: stringArg(),\n *         },\n *         // ...\n *       })\n *       t.field('buy', {\n *         type: 'Recipet',\n *         args: {\n *           productId: idArg(),\n *         },\n *         // ...\n *       })\n *     },\n *   })\n *\n * @param config Specify your Mutation type's fields, description, and more. See each config property's jsDoc\n *   for more detail.\n */\nexport function mutationType(config: Omit<NexusObjectTypeConfig<'Mutation'>, 'name'>) {\n  return objectType({ ...config, name: 'Mutation' })\n}\n"],"names":[],"mappings":";;;;AAAA,OAAO,EAAyB,UAAU,EAAE,MAAM,cAAc,CAAA;;AAyC1D,SAAU,YAAY,CAAC,MAAuD;IAClF,WAAO,sPAAU,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAM,MAAM,GAAA;QAAE,IAAI,EAAE,UAAU;IAAA,GAAG,CAAA;AACpD,CAAC"}},
    {"offset": {"line": 6254, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/definitions/queryField.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/definitions/queryField.ts"],"sourcesContent":["import type { FieldOutConfig, OutputDefinitionBlock } from './definitionBlocks'\nimport { extendType, NexusExtendTypeDef } from './extendType'\n\nexport type QueryFieldConfig<FieldName extends string> =\n  | FieldOutConfig<'Query', FieldName>\n  | (() => FieldOutConfig<'Query', FieldName>)\n\n/**\n * [API Docs](https://nexusjs.org/docs/api/query-field) | [2018 GraphQL\n * Spec](https://spec.graphql.org/June2018/#sec-Query)\n *\n * Define one or more fields on the Query type.\n *\n * The Query type is one of three [root types](https://spec.graphql.org/June2018/#sec-Root-Operation-Types) in\n * GraphQL and its fields represent API operations your clients can run that must not have side-effects.\n *\n * Use this instead of queryType if you are going to modularize your schema and thus be wanting to contribute\n * fields to Query type from multiple modules. You do not have to have previously defined a Query type before\n * using this. If you haven't Nexus will create one automatically for you.\n *\n * This is shorthand for:\n *\n * `extendType({ type: 'Query' })`\n *\n * If you need to leverage plugins or define multiple fields then use the typeBuilder overload variant of this\n * function. Otherwise you may prefer to the field name/config variant.\n *\n * @example\n *   // User.ts\n *   // Overload 1: Type Builder\n *\n *   queryField((t) => {\n *     t.field('user', {\n *       type: 'User',\n *       args: {\n *         id: idArg(),\n *       },\n *       // ...\n *     })\n *   })\n *\n * @example\n *   // User.ts\n *   // Overload 2: Field Name/Config\n *\n *   queryField('user', {\n *     type: 'User',\n *     args: {\n *       id: idArg(),\n *     },\n *     // ...\n *   })\n *\n * @param typeBuilder The same as the \"definition\" method you define on object type configurations.\n */\nexport function queryField(\n  typeBuilder: (t: OutputDefinitionBlock<'Query'>) => void\n): NexusExtendTypeDef<'Query'>\n\n/**\n * [API Docs](https://nexusjs.org/docs/api/query-field) | [2018 GraphQL\n * Spec](https://spec.graphql.org/June2018/#sec-Query)\n *\n * Define one or more fields on the Query type.\n *\n * Use this if you are going to modularize your schema and thus be wanting to contribute fields to Query type\n * from multiple modules. You do not have to have previously defined a Query type before using this. If you\n * haven't Nexus will create one automatically for you.\n *\n * This is shorthand for:\n *\n * `extendType({ type: 'Query' })`\n *\n * If you need to leverage plugins or define multiple fields then use the typeBuilder overload variant of this\n * function. Otherwise you may prefer to the field name/config variant.\n *\n * @example\n *   // User.ts\n *   // Overload 1: Type Builder\n *\n *   queryField((t) => {\n *     t.field('user', {\n *       type: 'User',\n *       args: {\n *         id: idArg(),\n *       },\n *       // ...\n *     })\n *   })\n *\n * @example\n *   // User.ts\n *   // Overload 2: Field Name/Config\n *\n *   queryField('user', {\n *     type: 'User',\n *     args: {\n *       id: idArg(),\n *     },\n *     // ...\n *   })\n *\n * @param name The name of the field on the Query type. Names are case‚Äêsensitive and must conform to pattern:\n *     `[_A-Za-z][_0-9A-Za-z]*`\n * @param config The same type of configuration you would pass to t.field(\"...\", config)\n */\nexport function queryField<FieldName extends string>(\n  name: FieldName,\n  config: QueryFieldConfig<FieldName>\n): NexusExtendTypeDef<'Query'>\n\nexport function queryField(...args: any[]) {\n  return extendType({\n    type: 'Query',\n    definition(t) {\n      if (typeof args[0] === 'function') {\n        return args[0](t)\n      }\n\n      const [fieldName, config] = args as [string, QueryFieldConfig<any>]\n      const finalConfig = typeof config === 'function' ? config() : config\n      t.field(fieldName, finalConfig)\n    },\n  })\n}\n"],"names":[],"mappings":";;;;AACA,OAAO,EAAE,UAAU,EAAsB,MAAM,cAAc,CAAA;;AA8GvD,SAAU,UAAU,CAAC,GAAG,IAAW;IACvC,WAAO,sPAAU,EAAC;QAChB,IAAI,EAAE,OAAO;QACb,UAAU,EAAC,CAAC;YACV,IAAI,OAAO,IAAI,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;gBACjC,OAAO,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAA;aAClB;YAED,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC,GAAG,IAAuC,CAAA;YACnE,MAAM,WAAW,GAAG,OAAO,MAAM,KAAK,UAAU,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,MAAM,CAAA;YACpE,CAAC,CAAC,KAAK,CAAC,SAAS,EAAE,WAAW,CAAC,CAAA;QACjC,CAAC;KACF,CAAC,CAAA;AACJ,CAAC"}},
    {"offset": {"line": 6277, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/definitions/queryType.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/definitions/queryType.ts"],"sourcesContent":["import { NexusObjectTypeConfig, objectType } from './objectType'\n\n/**\n * [2018 GraphQL Spec](https://spec.graphql.org/June2018/#sec-Query)\n *\n * Define a Query type.\n *\n * The Query type is one of three [root types](https://spec.graphql.org/June2018/#sec-Root-Operation-Types) in\n * GraphQL and its fields represent API operations your clients can run that must not have side-effects.\n *\n * You can only have one of these in your schema. If you are going to modularize your schema and thus be\n * wanting to contribute fields to Query type from multiple modules then use\n * [queryField](https://nxs.li/docs/api/query-field) intead.\n *\n * This is a shorthand for:\n *\n * `objectType({ name: 'Query' })`\n *\n * @example\n *   queryType({\n *     definition(t) {\n *       t.field('user', {\n *         type: 'User',\n *         args: {\n *           id: idArg(),\n *         },\n *         // ...\n *       })\n *       t.field('search', {\n *         type: 'SearchResult',\n *         args: {\n *           pattern: stringArg(),\n *         },\n *         // ...\n *       })\n *     },\n *   })\n *\n * @param config Specify your Query type's fields, description, and more. See each config property's jsDoc for\n *   more detail.\n */\nexport function queryType(config: Omit<NexusObjectTypeConfig<'Query'>, 'name'>) {\n  return objectType({ ...config, name: 'Query' })\n}\n"],"names":[],"mappings":";;;;AAAA,OAAO,EAAyB,UAAU,EAAE,MAAM,cAAc,CAAA;;AAyC1D,SAAU,SAAS,CAAC,MAAoD;IAC5E,WAAO,sPAAU,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAM,MAAM,GAAA;QAAE,IAAI,EAAE,OAAO;IAAA,GAAG,CAAA;AACjD,CAAC"}},
    {"offset": {"line": 6292, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/definitions/subscriptionField.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/definitions/subscriptionField.ts"],"sourcesContent":["import { extendType, NexusExtendTypeDef } from './extendType'\nimport type { SubscriptionBuilder, SubscriptionTypeConfig } from './subscriptionType'\n\nexport type SubscriptionFieldConfig<FieldName extends string, Event> =\n  | SubscriptionTypeConfig<FieldName, Event>\n  | (() => SubscriptionTypeConfig<FieldName, Event>)\n\n/**\n * [2018 GraphQL Spec](https://spec.graphql.org/June2018/#sec-Subscription)\n *\n * Define one or more fields on the Subscription type.\n *\n * This is shorthand for:\n *\n * `extendType({ type: 'Subscription' })`\n *\n * The Subscription type is one of three [root\n * types](https://spec.graphql.org/June2018/#sec-Root-Operation-Types) in GraphQL and its fields represent API\n * operations your clients can run to be pushed data changes over time.\n *\n * Use this instead of subscriptionType if you are going to modularize your schema and thus be wanting to\n * contribute fields to the Subscription type from multiple modules. You do not have to have previously\n * defined a Query type before using this. If you haven't Nexus will create one automatically for you.\n *\n * Note that the main difference about Subscription type from other object types is that its field\n * configurations require a special \"subscribe\" method where you can return an asynchronous iterator. Promises\n * yielded by that iterator become available to the resolver in its first param, the source data.\n *\n * If you need to leverage plugins or define multiple fields then use the typeBuilder overload variant of this\n * function. Otherwise you may prefer to the field name/config variant.\n *\n * @example\n *   // Contrived but simple self-contained example\n *\n *   subscriptionField((t) => {\n *     t.boolean('truths', {\n *       subscribe() {\n *         async function* createTruthsStream() {\n *           while (true) {\n *             await new Promise((res) => setTimeout(res, 1000))\n *             yield Math.random() > 0.5\n *           }\n *         }\n *         return createTruthsStream()\n *       },\n *       resolve(truthPromise) {\n *         return truthPromise\n *       },\n *     })\n *   })\n *\n * @example\n *   // A slightly less contrived example\n *   // See the full working example at\n *   // https://nxs.li/examples/subscriptions\n *\n *   import { PubSub } from 'apollo-server-express'\n *   import { makeSchema, mutationType, objectType, stringArg, subscriptionType } from '_AT_nexus/schema'\n *   import * as path from 'path'\n *\n *   export const pubsub = new PubSub()\n *\n *   type User = {\n *     email: string\n *   }\n *\n *   type Event<T> = {\n *     data: T\n *   }\n *\n *   makeSchema({\n *     types: [\n *       subscriptionField('signup', {\n *         type: 'User',\n *         subscribe() {\n *           return pubsub.asyncIterator('signup')\n *         },\n *         async resolve(eventPromise: Promise<Event<User>>) {\n *           const event = await eventPromise\n *           return event.data\n *         },\n *       }),\n *\n *       mutationField('signup', {\n *         type: 'User',\n *         args: {\n *           email: stringArg(),\n *         },\n *         async resolve(_, args) {\n *           const newUser = {\n *             email: args.email,\n *           }\n *           // ...\n *           await pubsub.publish('signup', {\n *             data: newUser,\n *           })\n *           return newUser\n *         },\n *       }),\n *\n *       objectType({\n *         name: 'User',\n *         definition(t) {\n *           t.string('email')\n *         },\n *       }),\n *     ],\n *     typegenAutoConfig: {\n *       sources: [{ source: __filename, alias: 'SourceTypes' }],\n *     },\n *   })\n *\n * @param typeBuilder The same as the \"definition\" method you define on object type configurations.\n */\nexport function subscriptionField(\n  typeBuilder: (t: SubscriptionBuilder) => void\n): NexusExtendTypeDef<'Subscription'>\n\n/**\n * [2018 GraphQL Spec](https://spec.graphql.org/June2018/#sec-Subscription)\n *\n * Define one or more fields on the Subscription type.\n *\n * This is shorthand for:\n *\n * `extendType({ type: 'Subscription' })`\n *\n * The Subscription type is one of three [root\n * types](https://spec.graphql.org/June2018/#sec-Root-Operation-Types) in GraphQL and its fields represent API\n * operations your clients can run to be pushed data changes over time.\n *\n * Use this instead of subscriptionType if you are going to modularize your schema and thus be wanting to\n * contribute fields to the Subscription type from multiple modules. You do not have to have previously\n * defined a Query type before using this. If you haven't Nexus will create one automatically for you.\n *\n * Note that the main difference about Subscription type from other object types is that its field\n * configurations require a special \"subscribe\" method where you can return an asynchronous iterator. Promises\n * yielded by that iterator become available to the resolver in its first param, the source data.\n *\n * If you need to leverage plugins or define multiple fields then use the typeBuilder overload variant of this\n * function. Otherwise you may prefer to the field name/config variant.\n *\n * @example\n *   // Contrived but simple self-contained example\n *\n *   subscriptionField((t) => {\n *     t.boolean('truths', {\n *       subscribe() {\n *         async function* createTruthsStream() {\n *           while (true) {\n *             await new Promise((res) => setTimeout(res, 1000))\n *             yield Math.random() > 0.5\n *           }\n *         }\n *         return createTruthsStream()\n *       },\n *       resolve(truthPromise) {\n *         return truthPromise\n *       },\n *     })\n *   })\n *\n * @example\n *   // A slightly less contrived example\n *   // See the full working example at\n *   // https://nxs.li/examples/subscriptions\n *\n *   import { PubSub } from 'apollo-server-express'\n *   import { makeSchema, mutationType, objectType, stringArg, subscriptionType } from '_AT_nexus/schema'\n *   import * as path from 'path'\n *\n *   export const pubsub = new PubSub()\n *\n *   type User = {\n *     email: string\n *   }\n *\n *   type Event<T> = {\n *     data: T\n *   }\n *\n *   makeSchema({\n *     types: [\n *       subscriptionField('signup', {\n *         type: 'User',\n *         subscribe() {\n *           return pubsub.asyncIterator('signup')\n *         },\n *         async resolve(eventPromise: Promise<Event<User>>) {\n *           const event = await eventPromise\n *           return event.data\n *         },\n *       }),\n *\n *       mutationField('signup', {\n *         type: 'User',\n *         args: {\n *           email: stringArg(),\n *         },\n *         async resolve(_, args) {\n *           const newUser = {\n *             email: args.email,\n *           }\n *           // ...\n *           await pubsub.publish('signup', {\n *             data: newUser,\n *           })\n *           return newUser\n *         },\n *       }),\n *\n *       objectType({\n *         name: 'User',\n *         definition(t) {\n *           t.string('email')\n *         },\n *       }),\n *     ],\n *     typegenAutoConfig: {\n *       sources: [{ source: __filename, alias: 'SourceTypes' }],\n *     },\n *   })\n *\n * @param name The name of the field on the Query type. Names are case‚Äêsensitive and must conform to pattern:\n *   `[_A-Za-z][_0-9A-Za-z]*`\n * @param config The same type of configuration you would pass to t.field(\"...\", config)\n */\nexport function subscriptionField<FieldName extends string, Event>(\n  name: FieldName,\n  config: SubscriptionFieldConfig<FieldName, Event>\n): NexusExtendTypeDef<'Subscription'>\n\nexport function subscriptionField(...args: any[]) {\n  return extendType({\n    type: 'Subscription',\n    definition(t) {\n      if (typeof args[0] === 'function') {\n        return args[0](t)\n      }\n\n      const [fieldName, config] = args as [string, SubscriptionFieldConfig<any, any>]\n      const finalConfig = typeof config === 'function' ? config() : config\n      t.field(fieldName, finalConfig as any)\n    },\n  })\n}\n"],"names":[],"mappings":";;;;AAAA,OAAO,EAAE,UAAU,EAAsB,MAAM,cAAc,CAAA;;AAwOvD,SAAU,iBAAiB,CAAC,GAAG,IAAW;IAC9C,WAAO,sPAAU,EAAC;QAChB,IAAI,EAAE,cAAc;QACpB,UAAU,EAAC,CAAC;YACV,IAAI,OAAO,IAAI,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;gBACjC,OAAO,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAA;aAClB;YAED,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC,GAAG,IAAmD,CAAA;YAC/E,MAAM,WAAW,GAAG,OAAO,MAAM,KAAK,UAAU,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,MAAM,CAAA;YACpE,CAAC,CAAC,KAAK,CAAC,SAAS,EAAE,WAAkB,CAAC,CAAA;QACxC,CAAC;KACF,CAAC,CAAA;AACJ,CAAC"}},
    {"offset": {"line": 6315, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/definitions/subscriptionType.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/definitions/subscriptionType.ts"],"sourcesContent":["import type { GraphQLResolveInfo } from 'graphql'\nimport type { ArgsValue, GetGen, MaybePromise, MaybePromiseDeep, ResultValue } from '../typegenTypeHelpers'\nimport type { IsEqual } from '../typeHelpersInternal'\nimport type { CommonOutputFieldConfig } from './definitionBlocks'\nimport { objectType } from './objectType'\nimport type { AllNexusOutputTypeDefs } from './wrapping'\n\nexport type IsSubscriptionType<T> = IsEqual<T, 'Subscription'>\n\nexport interface SubscriptionTypeConfigBase<FieldName extends string, Event = any> {\n  resolve(\n    root: Event,\n    args: ArgsValue<'Subscription', FieldName>,\n    context: GetGen<'context'>,\n    info: GraphQLResolveInfo\n  ):\n    | MaybePromise<ResultValue<'Subscription', FieldName>>\n    | MaybePromiseDeep<ResultValue<'Subscription', FieldName>>\n  subscribe(\n    root: object,\n    args: ArgsValue<'Subscription', FieldName>,\n    ctx: GetGen<'context'>,\n    info: GraphQLResolveInfo\n  ): MaybePromise<AsyncIterator<Event>> | MaybePromiseDeep<AsyncIterator<Event>>\n}\n\n// prettier-ignore\nexport type SubscriptionScalarConfig<FieldName extends string, Event> =\n    CommonOutputFieldConfig<'Subscription', FieldName>\n  & SubscriptionTypeConfigBase<FieldName, Event>\n\n// prettier-ignore\nexport interface SubscriptionTypeConfig<FieldName extends string, Event> extends SubscriptionScalarConfig<FieldName, Event> {\n  type: GetGen<'allOutputTypes'> | AllNexusOutputTypeDefs\n}\n\n// prettier-ignore\nexport interface SubscriptionTypeConfigWithName<FieldName extends string, Event> extends SubscriptionTypeConfig<FieldName, Event> {\n  /**\n   * The name of this field. Must conform to the regex pattern: [_A-Za-z][_0-9A-Za-z]*\n   */  \n  name: FieldName\n}\n\n// prettier-ignore\nexport interface SubscriptionBuilder {\n  list: SubscriptionBuilder\n  nonNull: Omit<SubscriptionBuilder, 'nonNull' | 'nullable'>\n  nullable: Omit<SubscriptionBuilder, 'nonNull' | 'nullable'>\n  string<FieldName extends string, Event>(fieldName: FieldName, config: SubscriptionScalarConfig<FieldName, Event>): void\n  int<FieldName extends string, Event>(fieldName: FieldName, config: SubscriptionScalarConfig<FieldName, Event>): void\n  boolean<FieldName extends string, Event>(fieldName: FieldName, opts: SubscriptionScalarConfig<FieldName, Event>): void\n  id<FieldName extends string, Event>(fieldName: FieldName, config: SubscriptionScalarConfig<FieldName, Event>): void\n  float<FieldName extends string, Event>(fieldName: FieldName, config: SubscriptionScalarConfig<FieldName, Event>): void\n  field<FieldName extends string, Event>(config: SubscriptionTypeConfigWithName<FieldName, Event>): void\n  field<FieldName extends string, Event>(name: FieldName, config: SubscriptionTypeConfig<FieldName, Event>): void\n}\n\nexport type SubscriptionTypeParams = {\n  definition(t: SubscriptionBuilder): void\n}\n\n/**\n * [2018 GraphQL Spec](https://spec.graphql.org/June2018/#sec-Subscription)\n *\n * Define a Subscription type.\n *\n * This is a shorthand for:\n *\n * `objectType({ name: 'Subscription' })`\n *\n * The Subscription type is one of three [root\n * types](https://spec.graphql.org/June2018/#sec-Root-Operation-Types) in GraphQL and its fields represent API\n * operations your clients can run to be pushed data changes over time.\n *\n * You can only have one of these in your schema. If you are going to modularize your schema and thus be\n * wanting to contribute fields to the Subscription type from multiple modules then use\n * [queryField](https://nxs.li/docs/api/subscription-field) intead.\n *\n * Note that the main difference about Subscription type from other object types is that its field\n * configurations require a special \"subscribe\" method where you can return an asynchronous iterator. Promises\n * yielded by that iterator become available to the resolver in its first param, the source data.\n *\n * @example\n *   // Contrived but simple self-contained example\n *\n *   subscriptionType({\n *     definition(t) {\n *       t.boolean('truths', {\n *         subscribe() {\n *           async function* createTruthsStream() {\n *             while (true) {\n *               await new Promise((res) => setTimeout(res, 1000))\n *               yield Math.random() > 0.5\n *             }\n *           }\n *           return createTruthsStream()\n *         },\n *         resolve(truthPromise) {\n *           return truthPromise\n *         },\n *       })\n *     },\n *   })\n *\n * @example\n *   // A slightly less contrived example\n *   // See the full working example at\n *   // https://nxs.li/examples/subscriptions\n *\n *   import { PubSub } from 'apollo-server-express'\n *   import { makeSchema, mutationType, objectType, stringArg, subscriptionType } from '_AT_nexus/schema'\n *   import * as path from 'path'\n *\n *   export const pubsub = new PubSub()\n *\n *   type User = {\n *     email: string\n *   }\n *\n *   type Event<T> = {\n *     data: T\n *   }\n *\n *   export const schema = makeSchema({\n *     types: [\n *       subscriptionType({\n *         definition(t) {\n *           t.field('signup', {\n *             type: 'User',\n *             subscribe() {\n *               return pubsub.asyncIterator('signup')\n *             },\n *             async resolve(eventPromise: Promise<Event<User>>) {\n *               const event = await eventPromise\n *               return event.data\n *             },\n *           })\n *         },\n *       }),\n *\n *       mutationType({\n *         definition(t) {\n *           t.field('signup', {\n *             type: 'User',\n *             args: {\n *               email: stringArg(),\n *             },\n *             async resolve(_, args) {\n *               const newUser = {\n *                 email: args.email,\n *               }\n *               // ...\n *               await pubsub.publish('signup', {\n *                 data: newUser,\n *               })\n *               return newUser\n *             },\n *           })\n *         },\n *       }),\n *\n *       objectType({\n *         name: 'User',\n *         definition(t) {\n *           t.string('email')\n *         },\n *       }),\n *     ],\n *     typegenAutoConfig: {\n *       sources: [{ source: __filename, alias: 'SourceTypes' }],\n *     },\n *   })\n *\n * @param config Specify your Subscription type's fields, description, and more. See each config property's\n *   jsDoc for more detail.\n */\nexport function subscriptionType(config: SubscriptionTypeParams) {\n  return objectType({ ...config, name: 'Subscription' } as any)\n}\n"],"names":[],"mappings":";;;;AAIA,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAA;;AA6KnC,SAAU,gBAAgB,CAAC,MAA8B;IAC7D,WAAO,sPAAU,EAAC,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAK,MAAM,GAAA;QAAE,IAAI,EAAE,cAAc;IAAA,EAAS,CAAC,CAAA;AAC/D,CAAC"}},
    {"offset": {"line": 6330, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/sdlConverter.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/sdlConverter.ts"],"sourcesContent":["import {\n  buildSchema,\n  GraphQLArgument,\n  GraphQLEnumType,\n  GraphQLField,\n  GraphQLInputField,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLNamedType,\n  GraphQLObjectType,\n  GraphQLOutputType,\n  GraphQLScalarType,\n  GraphQLSchema,\n  GraphQLUnionType,\n  GraphQLWrappingType,\n  isObjectType,\n  isScalarType,\n  isSpecifiedScalarType,\n} from 'graphql'\nimport { eachObj, GroupedTypes, groupTypes, isInterfaceField, objValues } from './utils'\nimport { unwrapGraphQLDef, NexusFinalWrapKind } from './definitions/wrapping'\n\nexport function convertSDL(sdl: string, commonjs: null | boolean = false, json = JSON) {\n  try {\n    return new SDLConverter(sdl, commonjs, json).print()\n  } catch (e) {\n    return `Error Parsing SDL into Schema: ${e.stack}`\n  }\n}\n\n/** Convert an existing SDL schema into a GraphQL Nexus format */\nexport class SDLConverter {\n  protected export: string\n  protected schema: GraphQLSchema | null\n  protected groupedTypes: GroupedTypes\n  protected usedImports: Set<string> = new Set()\n  protected exports: Set<string> = new Set()\n\n  constructor(sdl: string, protected commonjs: null | boolean = false, protected json: JSON = JSON) {\n    this.export = commonjs === null || commonjs ? 'const ' : 'export const '\n    this.schema = buildSchema(sdl)\n    this.groupedTypes = groupTypes(this.schema)\n  }\n\n  print() {\n    const body = [\n      this.printObjectTypes(),\n      this.printInterfaceTypes(),\n      this.printInputObjectTypes(),\n      this.printUnionTypes(),\n      this.printEnumTypes(),\n      this.printScalarTypes(),\n      this.printExports(),\n    ]\n    return [this.printUsedImports()]\n      .concat(body)\n      .filter((f) => f)\n      .join('\\n\\n')\n  }\n\n  printUsedImports() {\n    if (this.commonjs) {\n      return `const { ${Array.from(this.usedImports).join(', ')} } = require('nexus');`\n    }\n    return `import { ${Array.from(this.usedImports).join(', ')} } from 'nexus';`\n  }\n\n  printObjectTypes() {\n    if (this.groupedTypes.object.length > 0) {\n      this.usedImports.add('objectType')\n      return this.groupedTypes.object.map((t) => this.printObjectType(t)).join('\\n')\n    }\n    return ''\n  }\n\n  printObjectType(type: GraphQLObjectType): string {\n    const implementing = type.getInterfaces().map((i) => i.name)\n    const implementsInterfaces = implementing.length > 0 ? `    t.implements(${implementing.join(', ')})` : ''\n    this.exports.add(type.name)\n    return this.printBlock([\n      `${this.export}${type.name} = objectType({`,\n      `  name: \"${type.name}\",`,\n      this.maybeDescription(type),\n      `  definition(t) {`,\n      implementsInterfaces,\n      this.printObjectFields(type),\n      `  }`,\n      `})`,\n    ])\n  }\n\n  printObjectFields(type: GraphQLObjectType | GraphQLInterfaceType) {\n    return objValues(type.getFields())\n      .map((field) => {\n        if (isObjectType(type) && isInterfaceField(type, field.name)) {\n          return\n        }\n        return this.printField('output', field)\n      })\n      .filter((f) => f)\n      .join('\\n')\n  }\n\n  printInputObjectFields(type: GraphQLInputObjectType) {\n    return objValues(type.getFields())\n      .map((field) => this.printField('input', field))\n      .filter((f) => f)\n      .join('\\n')\n  }\n\n  printField(source: 'input' | 'output', field: GraphQLField<any, any> | GraphQLInputField) {\n    const { namedType, wrapping } = unwrapGraphQLDef(field.type)\n    let prefix = 't.'\n\n    let typeString: string | undefined = undefined\n\n    ;[...wrapping].reverse().forEach((w) => {\n      if (w === 'List') {\n        prefix += `list.`\n      } else {\n        prefix += `nonNull.`\n      }\n    })\n\n    return `    ${prefix}${this.printFieldMethod(source, field, namedType, typeString)}`\n  }\n\n  printFieldMethod(\n    source: 'input' | 'output',\n    field: GraphQLField<any, any> | GraphQLInputField,\n    type:\n      | Exclude<GraphQLOutputType, GraphQLWrappingType>\n      | Exclude<GraphQLInputObjectType, GraphQLWrappingType>,\n    typeString?: string\n  ) {\n    const objectMeta: Record<string, any> = {}\n    let str = ''\n    if (isCommonScalar(type) && !typeString) {\n      str += `${type.name.toLowerCase()}(\"${field.name}\"`\n    } else {\n      objectMeta.type = typeString ?? type\n      str += `field(\"${field.name}\"`\n    }\n    if ('deprecationReason' in field && field.deprecationReason) {\n      objectMeta.deprecation = field.deprecationReason\n    }\n    if (field.description) {\n      objectMeta.description = field.description\n    }\n    if (source === 'output') {\n      const outputField = field as GraphQLField<any, any>\n      if (outputField.args.length) {\n        objectMeta.args = outputField.args\n      }\n    } else {\n      const inputField = field as GraphQLInputField\n      if (inputField.defaultValue !== undefined) {\n        objectMeta.default = inputField.defaultValue\n      }\n    }\n    const metaKeys = Object.keys(objectMeta)\n    if (metaKeys.length > 0) {\n      if (metaKeys.length === 1 && !objectMeta.args) {\n        const key = metaKeys[0]\n        str += `, { ${key}: ${this.printMeta(objectMeta[key], key)} }`\n      } else {\n        str += `, {\\n`\n        eachObj(objectMeta, (val, key) => {\n          str += `      ${key}: ${this.printMeta(val, key)},\\n`\n        })\n        str += `    }`\n      }\n    }\n    return `${str})`\n  }\n\n  printMeta(val: any, key: string) {\n    if (key === 'type') {\n      return val\n    }\n    if (key === 'args') {\n      let str = `{\\n`\n      ;(val as GraphQLArgument[]).forEach((arg) => {\n        str += `        ${arg.name}: ${this.printArg(arg)},\\n`\n      })\n      str += `      }`\n      return str\n    }\n    return this.json.stringify(val)\n  }\n\n  printArg(arg: GraphQLArgument) {\n    const description = arg.description\n    const defaultValue = arg.defaultValue\n    const { namedType: type, wrapping } = unwrapGraphQLDef(arg.type)\n    const isArg = !isSpecifiedScalarType(type)\n    let str = ''\n    if (isArg) {\n      this.usedImports.add('arg')\n      str += `arg(`\n    } else {\n      this.usedImports.add(`${type.toString().toLowerCase()}Arg`)\n\n      str += `${type.toString().toLowerCase()}Arg(`\n    }\n    const metaToAdd = []\n    let wrappedType = type.name\n\n    if (isArg) {\n      metaToAdd.push(`type: ${this.addWrapping(wrappedType, wrapping)}`)\n    }\n    if (description) {\n      metaToAdd.push(`description: ${JSON.stringify(description)}`)\n    }\n    if (defaultValue) {\n      metaToAdd.push(`default: ${JSON.stringify(defaultValue)}`)\n    }\n    str +=\n      metaToAdd.length > 1\n        ? `{\\n          ${metaToAdd.join(',\\n          ')}\\n        })`\n        : metaToAdd.length\n        ? `{ ${metaToAdd[0]} })`\n        : ')'\n\n    return isArg ? str : this.addWrapping(str, wrapping)\n  }\n\n  addWrapping(toWrap: string, wrapping: NexusFinalWrapKind[]) {\n    let wrappedVal = toWrap\n    wrapping.forEach((w) => {\n      if (w === 'NonNull') {\n        this.usedImports.add('nonNull')\n        wrappedVal = `nonNull(${wrappedVal})`\n      } else if (w === 'List') {\n        this.usedImports.add('list')\n        wrappedVal = `list(${wrappedVal})`\n      }\n    })\n    return wrappedVal\n  }\n\n  printInterfaceTypes() {\n    if (this.groupedTypes.interface.length) {\n      this.usedImports.add('interfaceType')\n      return this.groupedTypes.interface.map((t) => this.printInterfaceType(t)).join('\\n')\n    }\n    return ''\n  }\n\n  printInterfaceType(type: GraphQLInterfaceType): string {\n    const implementing: string[] =\n      // @ts-ignore\n      typeof type.getInterfaces === 'function' ? type.getInterfaces().map((i) => i.name) : []\n    const implementsInterfaces = implementing.length > 0 ? `    t.implements(${implementing.join(', ')})` : ''\n    this.exports.add(type.name)\n    return this.printBlock([\n      `${this.export}${type.name} = interfaceType({`,\n      `  name: \"${type.name}\",`,\n      this.maybeDescription(type),\n      `  definition(t) {`,\n      implementsInterfaces,\n      this.printObjectFields(type),\n      `  }`,\n      `});`,\n    ])\n  }\n\n  printEnumTypes() {\n    if (this.groupedTypes.enum.length) {\n      this.usedImports.add('enumType')\n      return this.groupedTypes.enum.map((t) => this.printEnumType(t)).join('\\n')\n    }\n    return ''\n  }\n\n  printEnumType(type: GraphQLEnumType): string {\n    const members = type.getValues().map((val) => {\n      const { description, name, deprecationReason, value } = val\n      if (!description && !deprecationReason && name === value) {\n        return val.name\n      }\n      return { description, name, deprecation: deprecationReason, value }\n    })\n    this.exports.add(type.name)\n    return this.printBlock([\n      `${this.export}${type.name} = enumType({`,\n      `  name: \"${type.name}\",`,\n      this.maybeDescription(type),\n      `  members: ${this.json.stringify(members)},`,\n      `});`,\n    ])\n  }\n\n  printInputObjectTypes() {\n    if (this.groupedTypes.input.length) {\n      this.usedImports.add('inputObjectType')\n      return this.groupedTypes.input.map((t) => this.printInputObjectType(t)).join('\\n')\n    }\n    return ''\n  }\n\n  printInputObjectType(type: GraphQLInputObjectType): string {\n    this.exports.add(type.name)\n    return this.printBlock([\n      `${this.export}${type.name} = inputObjectType({`,\n      `  name: \"${type.name}\",`,\n      this.maybeDescription(type),\n      `  definition(t) {`,\n      this.printInputObjectFields(type),\n      `  }`,\n      `});`,\n    ])\n  }\n\n  printUnionTypes() {\n    if (this.groupedTypes.union.length) {\n      this.usedImports.add('unionType')\n      return this.groupedTypes.union.map((t) => this.printUnionType(t)).join('\\n')\n    }\n    return ''\n  }\n\n  printUnionType(type: GraphQLUnionType): string {\n    this.exports.add(type.name)\n    return this.printBlock([\n      `${this.export}${type.name} = unionType({`,\n      `  name: \"${type.name}\",`,\n      this.maybeDescription(type),\n      `  definition(t) {`,\n      `    t.members(${type.getTypes().join(', ')})`,\n      `  }`,\n      `});`,\n    ])\n  }\n\n  printScalarTypes() {\n    if (this.groupedTypes.scalar.length) {\n      this.usedImports.add('scalarType')\n      return this.groupedTypes.scalar\n        .filter((s) => !isSpecifiedScalarType(s))\n        .map((t) => this.printScalarType(t))\n        .join('\\n')\n    }\n    return ''\n  }\n\n  printScalarType(type: GraphQLScalarType): string {\n    this.exports.add(type.name)\n    return this.printBlock([\n      `${this.export}${type.name} = scalarType({`,\n      `  name: \"${type.name}\",`,\n      this.maybeDescription(type),\n      this.maybeAsNexusType(type),\n      `  serialize() { /* Todo */ },`,\n      `  parseValue() { /* Todo */ },`,\n      `  parseLiteral() { /* Todo */ }`,\n      `});`,\n    ])\n  }\n\n  printExports() {\n    if (!this.commonjs || this.exports.size === 0) {\n      return ''\n    }\n    const exports = Array.from(this.exports)\n    return this.printBlock(exports.map((exp) => `exports.${exp} = ${exp};`))\n  }\n\n  maybeAsNexusType(type: GraphQLScalarType) {\n    if (isCommonScalar(type)) {\n      return `  asNexusMethod: \"${type.name.toLowerCase()}\",`\n    }\n    return null\n  }\n\n  maybeDescription(type: GraphQLNamedType) {\n    if (type.description) {\n      return `  description: ${this.json.stringify(type.description)},`\n    }\n    return null\n  }\n\n  printBlock(block: (string | null)[]) {\n    return block.filter((t) => t !== null && t !== '').join('\\n')\n  }\n}\n\nfunction isCommonScalar(field: GraphQLNamedType): boolean {\n  if (isScalarType(field)) {\n    return field.name === 'UUID' || field.name === 'Date' || isSpecifiedScalarType(field)\n  }\n  return false\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6667, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/typegenTypeHelpers.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/typegenTypeHelpers.ts"],"sourcesContent":["import type { GraphQLAbstractType, GraphQLResolveInfo } from 'graphql'\nimport type { NexusInterfaceTypeDef } from './definitions/interfaceType'\nimport type { NexusObjectTypeDef } from './definitions/objectType'\n\ndeclare global {\n  interface NexusGen {}\n  interface NexusGenCustomInputMethods<TypeName extends string> {}\n  interface NexusGenCustomOutputMethods<TypeName extends string> {}\n  interface NexusGenCustomOutputProperties<TypeName extends string> {}\n  interface NexusGenPluginSchemaConfig {}\n  interface NexusGenPluginTypeConfig<TypeName extends string> {}\n  interface NexusGenPluginInputTypeConfig<TypeName extends string> {}\n  interface NexusGenPluginFieldConfig<TypeName extends string, FieldName extends string> {}\n  interface NexusGenPluginInputFieldConfig<TypeName extends string, FieldName extends string> {}\n  interface NexusGenPluginArgConfig {}\n}\n\nexport type AllInputTypes = GetGen<'allInputTypes', string>\n\nexport type AllOutputTypes = GetGen<'allOutputTypes', string>\n\n/** This type captures all output types defined in the app as well as core GraphQL spec objects. */\nexport type AllOutputTypesPossible = AllOutputTypes | 'Query' | 'Mutation' | 'Subscription'\n\nexport type FieldType<TypeName extends string, FieldName extends string> = GetGen3<\n  'fieldTypes',\n  TypeName,\n  FieldName\n>\n\nexport type MaybePromise<T> = PromiseLike<T> | T\n\n/**\n * Because the GraphQL field execution algorithm automatically resolves promises at any level of the tree, we\n * use this to help signify that.\n */\nexport type MaybePromiseDeep<T> = Date extends T\n  ? MaybePromise<T>\n  : null extends T\n  ? MaybePromise<T>\n  : boolean extends T\n  ? MaybePromise<T>\n  : number extends T\n  ? MaybePromise<T>\n  : string extends T\n  ? MaybePromise<T>\n  : T extends Array<infer U>\n  ? MaybePromise<Array<MaybePromiseDeep<U>>>\n  : T extends ReadonlyArray<infer Y>\n  ? MaybePromise<ReadonlyArray<MaybePromiseDeep<Y>>>\n  : T extends object\n  ? MaybePromise<\n      | T\n      | {\n          [P in keyof T]: MaybePromiseDeep<T[P]>\n        }\n    >\n  : MaybePromise<T>\n\n/**\n * The NexusAbstractTypeResolver type can be used if you want to preserve type-safety and autocomplete on an\n * abstract type resolver (interface or union) outside of the Nexus configuration\n *\n * @example\n *   const mediaType: AbstractTypeResolver<'MediaType'> = (root, ctx, info) => {\n *     if (ctx.user.isLoggedIn()) {\n *       return ctx.user.getItems()\n *     }\n *     return null\n *   }\n */\nexport interface AbstractTypeResolver<TypeName extends string> {\n  (\n    source: SourceValue<TypeName>,\n    context: GetGen<'context'>,\n    info: GraphQLResolveInfo,\n    abstractType: GraphQLAbstractType\n  ): MaybePromise<AbstractResolveReturn<TypeName> | null>\n}\n\n/**\n * The FieldResolver type can be used when you want to preserve type-safety and autocomplete on a resolver\n * outside of the Nexus definition block\n *\n * @example\n *   const userItems: FieldResolver<'User', 'items'> = (root, args, ctx, info) => {\n *     if (ctx.user.isLoggedIn()) {\n *       return ctx.user.getItems()\n *     }\n *     return null\n *   }\n */\nexport type FieldResolver<TypeName extends string, FieldName extends string> = (\n  /**\n   * The [source data](https://nxs.li/guides/source-types) for the GraphQL object that this field belongs to,\n   * unless this is a root field (any field on a [root operation\n   * type](https://spec.graphql.org/June2018/#sec-Root-Operation-Types): Query, Mutation, Subscription), in\n   * which case there is no source data and this will be undefined.\n   */\n  source: SourceValue<TypeName>,\n  /**\n   * If you have defined arguments on this field then this parameter will contain any arguments passed by the\n   * client. If you specified default values for any arguments and the client did not explicitly pass *any*\n   * value (including null) for those arguments then you will see the defaults here.\n   *\n   * Note that thanks to [Nexus' reflection system](https://nxs.li/guides/reflection) this parameter's type\n   * will always be type safe.\n   */\n  args: ArgsValue<TypeName, FieldName>,\n  /**\n   * The context data for this request.\n   *\n   * The context data is typically a singleton scoped to the lifecycle of the request. This means created at\n   * the beginning of a request and then passed to all the resolvers that execute while resolving the request.\n   * It is often used to store information like the current user making the request. Nexus is not responsible\n   * for this however. That is typically something you'll do with e.g. [Mercurius](https://mercurius.dev) or\n   * [Apollo Server](https://apollographql.com/docs/apollo-server/api/apollo-server).\n   *\n   * Note that the type here will be whatever you have specified for \"contextType\" in your makeSchema configuration.\n   */\n  context: GetGen<'context'>,\n  /**\n   * The GraphQL resolve info.\n   *\n   * This is an advanced parameter seldom used. It includes things like the AST of the [GraphQL\n   * document](https://spec.graphql.org/June2018/#sec-Language.Document) sent by the client.\n   */\n  info: GraphQLResolveInfo\n) => MaybePromise<ResultValue<TypeName, FieldName>> | MaybePromiseDeep<ResultValue<TypeName, FieldName>>\n\nexport type FieldTypeName<TypeName extends string, FieldName extends string> = GetGen3<\n  'fieldTypeNames',\n  TypeName,\n  FieldName\n>\n\nexport type SubFieldResolver<\n  TypeName extends string,\n  FieldName extends string,\n  SubFieldName extends string\n> = (\n  root: SourceValue<TypeName>,\n  args: ArgsValue<TypeName, FieldName>,\n  context: GetGen<'context'>,\n  info: GraphQLResolveInfo\n) =>\n  | MaybePromise<ResultValue<TypeName, FieldName>[SubFieldName]>\n  | MaybePromiseDeep<ResultValue<TypeName, FieldName>[SubFieldName]>\n\nexport type AbstractResolveReturn<TypeName extends string> = GetGen2<'abstractTypeMembers', TypeName, any>\n\n/** Generated type helpers: */\nexport type GenTypesShapeKeys =\n  | 'context'\n  | 'inputTypes'\n  | 'rootTypes'\n  | 'inputTypeShapes'\n  | 'argTypes'\n  | 'fieldTypes'\n  | 'fieldTypeNames'\n  | 'allTypes'\n  | 'typeInterfaces'\n  | 'objectNames'\n  | 'inputNames'\n  | 'enumNames'\n  | 'interfaceNames'\n  | 'scalarNames'\n  | 'unionNames'\n  | 'allInputTypes'\n  | 'allOutputTypes'\n  | 'allNamedTypes'\n  | 'abstractTypes'\n  | 'abstractTypeMembers'\n  | 'objectsUsingAbstractStrategyIsTypeOf'\n  | 'abstractsUsingStrategyResolveType'\n  | 'features'\n\n/** Helpers for handling the generated schema */\nexport type GenTypesShape = Record<GenTypesShapeKeys, any>\n\nexport type GetGen<K extends GenTypesShapeKeys, Fallback = any> = NexusGen extends infer GenTypes\n  ? GenTypes extends GenTypesShape\n    ? GenTypes[K]\n    : Fallback\n  : Fallback\n\nexport type GetGen2<\n  K extends GenTypesShapeKeys,\n  K2 extends Extract<keyof GenTypesShape[K], string>,\n  Fallback = any\n> = K2 extends keyof GetGen<K, never> ? GetGen<K>[K2] : Fallback\n\nexport type GetGen3<\n  K extends GenTypesShapeKeys,\n  K2 extends Extract<keyof GenTypesShape[K], string>,\n  K3 extends Extract<keyof GenTypesShape[K][K2], string>,\n  Fallback = any\n> = K2 extends keyof GetGen<K, never>\n  ? K3 extends keyof GetGen<K>[K2]\n    ? GetGen<K>[K2][K3]\n    : Fallback\n  : Fallback\n\nexport type HasGen<K extends GenTypesShapeKeys> = NexusGen extends infer GenTypes\n  ? GenTypes extends GenTypesShape\n    ? K extends keyof GenTypes\n      ? true\n      : false\n    : false\n  : false\n\nexport type HasGen2<\n  K extends GenTypesShapeKeys,\n  K2 extends Extract<keyof GenTypesShape[K], string>\n> = NexusGen extends infer GenTypes\n  ? GenTypes extends GenTypesShape\n    ? K extends keyof GenTypes\n      ? K2 extends keyof GenTypes[K]\n        ? true\n        : false\n      : false\n    : false\n  : false\n\nexport type HasGen3<\n  K extends GenTypesShapeKeys,\n  K2 extends Extract<keyof GenTypesShape[K], string>,\n  K3 extends Extract<keyof GenTypesShape[K][K2], string>\n> = NexusGen extends infer GenTypes\n  ? GenTypes extends GenTypesShape\n    ? K extends keyof GenTypes\n      ? K2 extends keyof GenTypes[K]\n        ? K3 extends keyof GenTypes[K][K2]\n          ? true\n          : false\n        : false\n      : false\n    : false\n  : false\n\nexport type SourceValue<TypeName extends string> = GetGen2<'rootTypes', TypeName>\n\nexport type RootValueField<TypeName extends string, FieldName extends string> = GetGen3<\n  'rootTypes',\n  TypeName,\n  FieldName\n>\n\nexport type ArgsValue<TypeName extends string, FieldName extends string> = HasGen3<\n  'fieldTypes',\n  TypeName,\n  FieldName\n> extends true\n  ? GetGen3<'argTypes', TypeName, FieldName, {}>\n  : any\n\nexport type ResultValue<TypeName extends string, FieldName extends string> = GetGen3<\n  'fieldTypes',\n  TypeName,\n  FieldName\n>\n\nexport type NeedsResolver<TypeName extends string, FieldName extends string> = HasGen3<\n  'fieldTypes',\n  TypeName,\n  FieldName\n> extends true\n  ? null extends GetGen3<'fieldTypes', TypeName, FieldName>\n    ? false\n    : HasGen3<'rootTypes', TypeName, FieldName> extends true\n    ? null extends GetGen3<'rootTypes', TypeName, FieldName>\n      ? true\n      : false\n    : true\n  : HasGen3<'rootTypes', TypeName, FieldName> extends true\n  ? null extends GetGen3<'rootTypes', TypeName, FieldName>\n    ? true\n    : false\n  : false\n\nexport type IsFeatureEnabled2<PathPart1 extends string, PathPart2 extends string> = GetGen3<\n  'features',\n  PathPart1,\n  PathPart2,\n  false\n> extends true\n  ? true\n  : false\n\nexport type Discriminate<\n  TypeName extends string,\n  Required extends 'required' | 'optional',\n  Type = SourceValue<TypeName>\n> = Type extends { __typename: TypeName }\n  ? Type\n  : Type extends { __typename?: TypeName }\n  ? Type\n  : Required extends 'required'\n  ? Type & { __typename: TypeName }\n  : Type & { __typename?: TypeName }\n\nexport type InterfaceFieldsFor<TypeName extends string> = {\n  [K in GetGen2<'typeInterfaces', TypeName, never>]: keyof GetGen2<'fieldTypeNames', K>\n}[GetGen2<'typeInterfaces', TypeName, never>]\n\nexport type ModificationType<TypeName, FieldName> = TypeName extends string\n  ? FieldName extends string\n    ? GetGen2<\n        'abstractTypeMembers',\n        GetGen3<'fieldTypeNames', GetGen2<'typeInterfaces', TypeName, never>, FieldName>,\n        never\n      > extends infer U\n      ? U extends string\n        ? U | ConcreteModificationType<U>\n        : never\n      : never\n    : any\n  : any\n\nexport type ConcreteModificationType<U extends string> = GetGen2<'objectNames', U, never> extends string\n  ? NexusObjectTypeDef<U>\n  : NexusInterfaceTypeDef<U>\n"],"names":[],"mappings":""}},
    {"offset": {"line": 6674, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/core.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/core.ts"],"sourcesContent":["// The \"core\" is used as a namespace to re-export everything,\n// For anyone who wants to use the internals\nexport * from './builder'\nexport * from './makeSchema'\nexport * from './definitions/args'\nexport * from './definitions/decorateType'\nexport * from './definitions/definitionBlocks'\nexport * from './definitions/enumType'\nexport * from './definitions/extendInputType'\nexport * from './definitions/extendType'\nexport * from './definitions/inputObjectType'\nexport * from './definitions/interfaceType'\nexport * from './definitions/list'\nexport * from './definitions/mutationField'\nexport * from './definitions/mutationType'\nexport * from './definitions/nonNull'\nexport * from './definitions/nullable'\nexport * from './definitions/objectType'\nexport * from './definitions/queryField'\nexport * from './definitions/queryType'\nexport * from './definitions/scalarType'\nexport * from './definitions/subscriptionField'\nexport * from './definitions/subscriptionType'\nexport * from './definitions/nexusMeta'\nexport * from './definitions/unionType'\nexport * from './definitions/wrapping'\nexport * from './definitions/_types'\nexport * from './dynamicMethod'\nexport * from './plugin'\nexport * from './plugins'\nexport * from './rebuildType'\nexport * from './sdlConverter'\nexport * from './typegenAutoConfig'\nexport * from './typegenFormatPrettier'\nexport * from './typegenMetadata'\nexport * from './typegenPrinter'\nexport * from './typegenTypeHelpers'\nexport * from './typegenUtils'\nexport * from './utils'\n"],"names":[],"mappings":";AAAA,6DAA6D;AAC7D,4CAA4C;AAC5C,cAAc,WAAW,CAAA;AACzB,cAAc,cAAc,CAAA;AAC5B,cAAc,oBAAoB,CAAA;AAClC,cAAc,4BAA4B,CAAA;AAC1C,cAAc,gCAAgC,CAAA;AAC9C,cAAc,wBAAwB,CAAA;AACtC,cAAc,+BAA+B,CAAA;AAC7C,cAAc,0BAA0B,CAAA;AACxC,cAAc,+BAA+B,CAAA;AAC7C,cAAc,6BAA6B,CAAA;AAC3C,cAAc,oBAAoB,CAAA;AAClC,cAAc,6BAA6B,CAAA;AAC3C,cAAc,4BAA4B,CAAA;AAC1C,cAAc,uBAAuB,CAAA;AACrC,cAAc,wBAAwB,CAAA;AACtC,cAAc,0BAA0B,CAAA;AACxC,cAAc,0BAA0B,CAAA;AACxC,cAAc,yBAAyB,CAAA;AACvC,cAAc,0BAA0B,CAAA;AACxC,cAAc,iCAAiC,CAAA;AAC/C,cAAc,gCAAgC,CAAA;AAC9C,cAAc,yBAAyB,CAAA;AACvC,cAAc,yBAAyB,CAAA;AACvC,cAAc,wBAAwB,CAAA;AACtC,cAAc,sBAAsB,CAAA;AACpC,cAAc,iBAAiB,CAAA;AAC/B,cAAc,UAAU,CAAA;AACxB,cAAc,WAAW,CAAA;AACzB,cAAc,eAAe,CAAA;AAC7B,cAAc,gBAAgB,CAAA;AAC9B,cAAc,qBAAqB,CAAA;AACnC,cAAc,yBAAyB,CAAA;AACvC,cAAc,mBAAmB,CAAA;AACjC,cAAc,kBAAkB,CAAA;AAChC,cAAc,sBAAsB,CAAA;AACpC,cAAc,gBAAgB,CAAA;AAC9B,cAAc,SAAS,CAAA"}},
    {"offset": {"line": 7161, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/dynamicProperty.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/dynamicProperty.ts"],"sourcesContent":["import type { SchemaBuilder } from './builder'\nimport type { OutputDefinitionBlock } from './definitions/definitionBlocks'\nimport { NexusTypes, withNexusSymbol } from './definitions/_types'\nimport type { BaseExtensionConfig } from './dynamicMethod'\n\nexport type OutputPropertyFactoryConfig<T> = {\n  stage: 'walk' | 'build'\n  builder: SchemaBuilder\n  typeDef: OutputDefinitionBlock<any>\n  /** The name of the type this field is being declared on */\n  typeName: string\n}\n\nexport interface DynamicOutputPropertyConfig<T extends string> extends BaseExtensionConfig<T> {\n  /** Invoked when the property is accessed (as a getter) */\n  factory(config: OutputPropertyFactoryConfig<T>): any\n}\n\nexport class DynamicOutputPropertyDef<Name extends string> {\n  constructor(readonly name: Name, protected config: DynamicOutputPropertyConfig<Name>) {}\n  get value() {\n    return this.config\n  }\n}\nwithNexusSymbol(DynamicOutputPropertyDef, NexusTypes.DynamicOutputProperty)\n\n/**\n * Defines a new property on the object definition block for an output type, making it possible to build\n * custom DSL's on top of Nexus, e.g. in nexus-prisma\n *\n * T.model.posts()\n */\nexport function dynamicOutputProperty<T extends string>(config: DynamicOutputPropertyConfig<T>) {\n  return new DynamicOutputPropertyDef(config.name, config)\n}\n"],"names":[],"mappings":";;;;;;AAEA,OAAO,EAAE,UAAU,EAAE,eAAe,EAAE,MAAM,sBAAsB,CAAA;;AAgB5D,MAAO,wBAAwB;IACnC,YAAqB,IAAU,EAAY,MAAyC,CAAA;QAA/D,IAAA,CAAA,IAAI,GAAJ,IAAI,CAAM;QAAY,IAAA,CAAA,MAAM,GAAN,MAAM,CAAmC;IAAG,CAAC;IACxF,IAAI,KAAK,GAAA;QACP,OAAO,IAAI,CAAC,MAAM,CAAA;IACpB,CAAC;CACF;IACD,uPAAe,EAAC,wBAAwB,EAAE,kPAAU,CAAC,qBAAqB,CAAC,CAAA;AAQrE,SAAU,qBAAqB,CAAmB,MAAsC;IAC5F,OAAO,IAAI,wBAAwB,CAAC,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,CAAA;AAC1D,CAAC"}},
    {"offset": {"line": 7186, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/nexus@1.3.0+2e36366335d68c76/node_modules/nexus/dist-esm/index.js","sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/nexus%401.3.0%2B2e36366335d68c76/node_modules/nexus/src/index.ts"],"sourcesContent":["import * as blocks from './blocks'\nimport * as core from './core'\n\n// All of the Public API definitions\nexport { makeSchema } from './makeSchema'\nexport { arg, booleanArg, floatArg, idArg, intArg, stringArg } from './definitions/args'\nexport { decorateType } from './definitions/decorateType'\nexport { enumType } from './definitions/enumType'\nexport { extendInputType } from './definitions/extendInputType'\nexport { extendType } from './definitions/extendType'\nexport { inputObjectType } from './definitions/inputObjectType'\nexport { interfaceType } from './definitions/interfaceType'\nexport { list } from './definitions/list'\nexport { mutationField } from './definitions/mutationField'\nexport { mutationType } from './definitions/mutationType'\nexport { nonNull } from './definitions/nonNull'\nexport { nullable } from './definitions/nullable'\nexport { objectType } from './definitions/objectType'\nexport { queryField } from './definitions/queryField'\nexport { queryType } from './definitions/queryType'\nexport { asNexusMethod, scalarType } from './definitions/scalarType'\nexport { subscriptionField } from './definitions/subscriptionField'\nexport { subscriptionType } from './definitions/subscriptionType'\nexport { unionType } from './definitions/unionType'\nexport { dynamicInputMethod, dynamicOutputMethod } from './dynamicMethod'\nexport { dynamicOutputProperty } from './dynamicProperty'\nexport { createPlugin, plugin, PluginBuilderLens, PluginConfig } from './plugin'\nexport * from './plugins'\nexport { convertSDL } from './sdlConverter'\nexport { AllInputTypes, AllOutputTypes, FieldResolver, FieldType } from './typegenTypeHelpers'\nexport { groupTypes } from './utils'\nexport { blocks, core }\n"],"names":[],"mappings":";;AAAA,OAAO,KAAK,MAAM,MAAM,UAAU,CAAA;;AAClC,OAAO,KAAK,IAAI,MAAM,QAAQ,CAAA;AAE9B,oCAAoC;AACpC,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAA;AACzC,OAAO,EAAE,GAAG,EAAE,UAAU,EAAE,QAAQ,EAAE,KAAK,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,oBAAoB,CAAA;AACxF,OAAO,EAAE,YAAY,EAAE,MAAM,4BAA4B,CAAA;AACzD,OAAO,EAAE,QAAQ,EAAE,MAAM,wBAAwB,CAAA;AACjD,OAAO,EAAE,eAAe,EAAE,MAAM,+BAA+B,CAAA;AAC/D,OAAO,EAAE,UAAU,EAAE,MAAM,0BAA0B,CAAA;AACrD,OAAO,EAAE,eAAe,EAAE,MAAM,+BAA+B,CAAA;AAC/D,OAAO,EAAE,aAAa,EAAE,MAAM,6BAA6B,CAAA;AAC3D,OAAO,EAAE,IAAI,EAAE,MAAM,oBAAoB,CAAA;AACzC,OAAO,EAAE,aAAa,EAAE,MAAM,6BAA6B,CAAA;AAC3D,OAAO,EAAE,YAAY,EAAE,MAAM,4BAA4B,CAAA;AACzD,OAAO,EAAE,OAAO,EAAE,MAAM,uBAAuB,CAAA;AAC/C,OAAO,EAAE,QAAQ,EAAE,MAAM,wBAAwB,CAAA;AACjD,OAAO,EAAE,UAAU,EAAE,MAAM,0BAA0B,CAAA;AACrD,OAAO,EAAE,UAAU,EAAE,MAAM,0BAA0B,CAAA;AACrD,OAAO,EAAE,SAAS,EAAE,MAAM,yBAAyB,CAAA;AACnD,OAAO,EAAE,aAAa,EAAE,UAAU,EAAE,MAAM,0BAA0B,CAAA;AACpE,OAAO,EAAE,iBAAiB,EAAE,MAAM,iCAAiC,CAAA;AACnE,OAAO,EAAE,gBAAgB,EAAE,MAAM,gCAAgC,CAAA;AACjE,OAAO,EAAE,SAAS,EAAE,MAAM,yBAAyB,CAAA;AACnD,OAAO,EAAE,kBAAkB,EAAE,mBAAmB,EAAE,MAAM,iBAAiB,CAAA;AACzE,OAAO,EAAE,qBAAqB,EAAE,MAAM,mBAAmB,CAAA;AACzD,OAAO,EAAE,YAAY,EAAE,MAAM,EAAmC,MAAM,UAAU,CAAA;AAChF,cAAc,WAAW,CAAA;AACzB,OAAO,EAAE,UAAU,EAAE,MAAM,gBAAgB,CAAA;AAC3C,OAAO,EAA2D,MAAM,sBAAsB,CAAA;AAC9F,OAAO,EAAE,UAAU,EAAE,MAAM,SAAS,CAAA"}}]
}