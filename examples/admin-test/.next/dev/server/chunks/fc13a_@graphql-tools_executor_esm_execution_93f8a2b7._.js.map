{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/%40graphql-tools%2Bexecutor%401.5.1%2B2e36366335d68c76/node_modules/%40graphql-tools/executor/esm/execution/coerceError.js"],"sourcesContent":["export function coerceError(error) {\n    if (error instanceof Error) {\n        return error;\n    }\n    if (typeof error === 'object' && error != null) {\n        if ('message' in error && typeof error.message === 'string') {\n            let errorOptions;\n            if ('cause' in error) {\n                errorOptions = { cause: error.cause };\n            }\n            const coercedError = new Error(error.message, errorOptions);\n            if ('stack' in error && typeof error.stack === 'string') {\n                coercedError.stack = error.stack;\n            }\n            if ('name' in error && typeof error.name === 'string') {\n                coercedError.name = error.name;\n            }\n            return coercedError;\n        }\n    }\n    return new Error(String(error));\n}\n"],"names":[],"mappings":";;;;AAAO,SAAS,YAAY,KAAK;IAC7B,IAAI,iBAAiB,OAAO;QACxB,OAAO;IACX;IACA,IAAI,OAAO,UAAU,YAAY,SAAS,MAAM;QAC5C,IAAI,aAAa,SAAS,OAAO,MAAM,OAAO,KAAK,UAAU;YACzD,IAAI;YACJ,IAAI,WAAW,OAAO;gBAClB,eAAe;oBAAE,OAAO,MAAM,KAAK;gBAAC;YACxC;YACA,MAAM,eAAe,IAAI,MAAM,MAAM,OAAO,EAAE;YAC9C,IAAI,WAAW,SAAS,OAAO,MAAM,KAAK,KAAK,UAAU;gBACrD,aAAa,KAAK,GAAG,MAAM,KAAK;YACpC;YACA,IAAI,UAAU,SAAS,OAAO,MAAM,IAAI,KAAK,UAAU;gBACnD,aAAa,IAAI,GAAG,MAAM,IAAI;YAClC;YACA,OAAO;QACX;IACJ;IACA,OAAO,IAAI,MAAM,OAAO;AAC5B","ignoreList":[0]}},
    {"offset": {"line": 36, "column": 0}, "map": {"version":3,"sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/%40graphql-tools%2Bexecutor%401.5.1%2B2e36366335d68c76/node_modules/%40graphql-tools/executor/esm/execution/flattenAsyncIterable.js"],"sourcesContent":["import { DisposableSymbols } from '@whatwg-node/disposablestack';\n/**\n * Given an AsyncIterable of AsyncIterables, flatten all yielded results into a\n * single AsyncIterable.\n */\nexport function flattenAsyncIterable(iterable) {\n    // You might think this whole function could be replaced with\n    //\n    //    async function* flattenAsyncIterable(iterable) {\n    //      for await (const subIterator of iterable) {\n    //        yield* subIterator;\n    //      }\n    //    }\n    //\n    // but calling `.return()` on the iterator it returns won't interrupt the `for await`.\n    const topIterator = iterable[Symbol.asyncIterator]();\n    let currentNestedIterator;\n    let waitForCurrentNestedIterator;\n    let done = false;\n    async function next() {\n        if (done) {\n            return { value: undefined, done: true };\n        }\n        try {\n            if (!currentNestedIterator) {\n                // Somebody else is getting it already.\n                if (waitForCurrentNestedIterator) {\n                    await waitForCurrentNestedIterator;\n                    return await next();\n                }\n                // Nobody else is getting it. We should!\n                let resolve;\n                waitForCurrentNestedIterator = new Promise(r => {\n                    resolve = r;\n                });\n                const topIteratorResult = await topIterator.next();\n                if (topIteratorResult.done) {\n                    // Given that done only ever transitions from false to true,\n                    // require-atomic-updates is being unnecessarily cautious.\n                    done = true;\n                    return await next();\n                }\n                // eslint is making a reasonable point here, but we've explicitly protected\n                // ourself from the race condition by ensuring that only the single call\n                // that assigns to waitForCurrentNestedIterator is allowed to assign to\n                // currentNestedIterator or waitForCurrentNestedIterator.\n                currentNestedIterator = topIteratorResult.value[Symbol.asyncIterator]();\n                waitForCurrentNestedIterator = undefined;\n                resolve();\n                return await next();\n            }\n            const rememberCurrentNestedIterator = currentNestedIterator;\n            const nestedIteratorResult = await currentNestedIterator.next();\n            if (!nestedIteratorResult.done) {\n                return nestedIteratorResult;\n            }\n            // The nested iterator is done. If it's still the current one, make it not\n            // current. (If it's not the current one, somebody else has made us move on.)\n            if (currentNestedIterator === rememberCurrentNestedIterator) {\n                currentNestedIterator = undefined;\n            }\n            return await next();\n        }\n        catch (err) {\n            done = true;\n            throw err;\n        }\n    }\n    return {\n        next,\n        async return() {\n            done = true;\n            await Promise.all([currentNestedIterator?.return?.(), topIterator.return?.()]);\n            return { value: undefined, done: true };\n        },\n        async throw(error) {\n            done = true;\n            await Promise.all([currentNestedIterator?.throw?.(error), topIterator.throw?.(error)]);\n            /* c8 ignore next */\n            throw error;\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n        async [DisposableSymbols.asyncDispose]() {\n            done = true;\n            await Promise.all([\n                currentNestedIterator?.[DisposableSymbols.asyncDispose]?.(),\n                topIterator?.[DisposableSymbols.asyncDispose]?.(),\n            ]);\n        },\n    };\n}\n"],"names":[],"mappings":";;;;AAAA;;AAKO,SAAS,qBAAqB,QAAQ;IACzC,6DAA6D;IAC7D,EAAE;IACF,sDAAsD;IACtD,mDAAmD;IACnD,6BAA6B;IAC7B,SAAS;IACT,OAAO;IACP,EAAE;IACF,sFAAsF;IACtF,MAAM,cAAc,QAAQ,CAAC,OAAO,aAAa,CAAC;IAClD,IAAI;IACJ,IAAI;IACJ,IAAI,OAAO;IACX,eAAe;QACX,IAAI,MAAM;YACN,OAAO;gBAAE,OAAO;gBAAW,MAAM;YAAK;QAC1C;QACA,IAAI;YACA,IAAI,CAAC,uBAAuB;gBACxB,uCAAuC;gBACvC,IAAI,8BAA8B;oBAC9B,MAAM;oBACN,OAAO,MAAM;gBACjB;gBACA,wCAAwC;gBACxC,IAAI;gBACJ,+BAA+B,IAAI,QAAQ,CAAA;oBACvC,UAAU;gBACd;gBACA,MAAM,oBAAoB,MAAM,YAAY,IAAI;gBAChD,IAAI,kBAAkB,IAAI,EAAE;oBACxB,4DAA4D;oBAC5D,0DAA0D;oBAC1D,OAAO;oBACP,OAAO,MAAM;gBACjB;gBACA,2EAA2E;gBAC3E,wEAAwE;gBACxE,uEAAuE;gBACvE,yDAAyD;gBACzD,wBAAwB,kBAAkB,KAAK,CAAC,OAAO,aAAa,CAAC;gBACrE,+BAA+B;gBAC/B;gBACA,OAAO,MAAM;YACjB;YACA,MAAM,gCAAgC;YACtC,MAAM,uBAAuB,MAAM,sBAAsB,IAAI;YAC7D,IAAI,CAAC,qBAAqB,IAAI,EAAE;gBAC5B,OAAO;YACX;YACA,0EAA0E;YAC1E,6EAA6E;YAC7E,IAAI,0BAA0B,+BAA+B;gBACzD,wBAAwB;YAC5B;YACA,OAAO,MAAM;QACjB,EACA,OAAO,KAAK;YACR,OAAO;YACP,MAAM;QACV;IACJ;IACA,OAAO;QACH;QACA,MAAM;YACF,OAAO;YACP,MAAM,QAAQ,GAAG,CAAC;gBAAC,uBAAuB;gBAAY,YAAY,MAAM;aAAK;YAC7E,OAAO;gBAAE,OAAO;gBAAW,MAAM;YAAK;QAC1C;QACA,MAAM,OAAM,KAAK;YACb,OAAO;YACP,MAAM,QAAQ,GAAG,CAAC;gBAAC,uBAAuB,QAAQ;gBAAQ,YAAY,KAAK,GAAG;aAAO;YACrF,kBAAkB,GAClB,MAAM;QACV;QACA,CAAC,OAAO,aAAa,CAAC;YAClB,OAAO,IAAI;QACf;QACA,MAAM,CAAC,2QAAiB,CAAC,YAAY,CAAC;YAClC,OAAO;YACP,MAAM,QAAQ,GAAG,CAAC;gBACd,uBAAuB,CAAC,2QAAiB,CAAC,YAAY,CAAC;gBACvD,aAAa,CAAC,2QAAiB,CAAC,YAAY,CAAC;aAChD;QACL;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 144, "column": 0}, "map": {"version":3,"sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/%40graphql-tools%2Bexecutor%401.5.1%2B2e36366335d68c76/node_modules/%40graphql-tools/executor/esm/execution/invariant.js"],"sourcesContent":["export function invariant(condition, message) {\n    if (!condition) {\n        throw new Error(message != null ? message : 'Unexpected invariant triggered.');\n    }\n}\n"],"names":[],"mappings":";;;;AAAO,SAAS,UAAU,SAAS,EAAE,OAAO;IACxC,IAAI,CAAC,WAAW;QACZ,MAAM,IAAI,MAAM,WAAW,OAAO,UAAU;IAChD;AACJ","ignoreList":[0]}},
    {"offset": {"line": 157, "column": 0}, "map": {"version":3,"sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/%40graphql-tools%2Bexecutor%401.5.1%2B2e36366335d68c76/node_modules/%40graphql-tools/executor/esm/execution/promiseForObject.js"],"sourcesContent":["import { handleMaybePromise, isPromise } from '@whatwg-node/promise-helpers';\n/**\n * This function transforms a JS object `Record<string, Promise<T>>` into\n * a `Promise<Record<string, T>>`\n *\n * This is akin to bluebird's `Promise.props`, but implemented only using\n * `Promise.all` so it will work with any implementation of ES6 promises.\n */\nexport function promiseForObject(object, signal, signalPromise) {\n    signal?.throwIfAborted();\n    const resolvedObject = Object.create(null);\n    const promises = [];\n    for (const key in object) {\n        const valueSet$ = handleMaybePromise(() => object[key], resolvedValue => {\n            resolvedObject[key] = resolvedValue;\n        });\n        if (isPromise(valueSet$)) {\n            promises.push(valueSet$);\n        }\n    }\n    if (!promises.length) {\n        return resolvedObject;\n    }\n    const promiseAll = promises.length === 1 ? promises[0] : Promise.all(promises);\n    if (signalPromise) {\n        return Promise.race([signalPromise, promiseAll]).then(() => resolvedObject);\n    }\n    return promiseAll.then(() => resolvedObject);\n}\n"],"names":[],"mappings":";;;;AAAA;;AAQO,SAAS,iBAAiB,MAAM,EAAE,MAAM,EAAE,aAAa;IAC1D,QAAQ;IACR,MAAM,iBAAiB,OAAO,MAAM,CAAC;IACrC,MAAM,WAAW,EAAE;IACnB,IAAK,MAAM,OAAO,OAAQ;QACtB,MAAM,YAAY,IAAA,gRAAkB,EAAC,IAAM,MAAM,CAAC,IAAI,EAAE,CAAA;YACpD,cAAc,CAAC,IAAI,GAAG;QAC1B;QACA,IAAI,IAAA,uQAAS,EAAC,YAAY;YACtB,SAAS,IAAI,CAAC;QAClB;IACJ;IACA,IAAI,CAAC,SAAS,MAAM,EAAE;QAClB,OAAO;IACX;IACA,MAAM,aAAa,SAAS,MAAM,KAAK,IAAI,QAAQ,CAAC,EAAE,GAAG,QAAQ,GAAG,CAAC;IACrE,IAAI,eAAe;QACf,OAAO,QAAQ,IAAI,CAAC;YAAC;YAAe;SAAW,EAAE,IAAI,CAAC,IAAM;IAChE;IACA,OAAO,WAAW,IAAI,CAAC,IAAM;AACjC","ignoreList":[0]}},
    {"offset": {"line": 191, "column": 0}, "map": {"version":3,"sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/%40graphql-tools%2Bexecutor%401.5.1%2B2e36366335d68c76/node_modules/%40graphql-tools/executor/esm/execution/values.js"],"sourcesContent":["import { coerceInputValue, isInputType, isNonNullType, print, typeFromAST, valueFromAST, } from 'graphql';\nimport { createGraphQLError, hasOwnProperty, inspect, printPathArray } from '@graphql-tools/utils';\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getVariableValues(schema, varDefNodes, inputs, options) {\n    const errors = [];\n    const maxErrors = options?.maxErrors;\n    try {\n        const coerced = coerceVariableValues(schema, varDefNodes, inputs, error => {\n            if (maxErrors != null && errors.length >= maxErrors) {\n                throw createGraphQLError('Too many errors processing variables, error limit reached. Execution aborted.');\n            }\n            errors.push(error);\n        });\n        if (errors.length === 0) {\n            return { coerced };\n        }\n    }\n    catch (error) {\n        errors.push(error);\n    }\n    return { errors };\n}\nfunction coerceVariableValues(schema, varDefNodes, inputs, onError) {\n    const coercedValues = {};\n    for (const varDefNode of varDefNodes) {\n        const varName = varDefNode.variable.name.value;\n        const varType = typeFromAST(schema, varDefNode.type);\n        if (!isInputType(varType)) {\n            // Must use input types for variables. This should be caught during\n            // validation, however is checked again here for safety.\n            const varTypeStr = print(varDefNode.type);\n            onError(createGraphQLError(`Variable \"$${varName}\" expected value of type \"${varTypeStr}\" which cannot be used as an input type.`, { nodes: varDefNode.type }));\n            continue;\n        }\n        if (!hasOwnProperty(inputs, varName)) {\n            if (varDefNode.defaultValue) {\n                coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);\n            }\n            else if (isNonNullType(varType)) {\n                const varTypeStr = inspect(varType);\n                onError(createGraphQLError(`Variable \"$${varName}\" of required type \"${varTypeStr}\" was not provided.`, {\n                    nodes: varDefNode,\n                }));\n            }\n            continue;\n        }\n        const value = inputs[varName];\n        if (value === null && isNonNullType(varType)) {\n            const varTypeStr = inspect(varType);\n            onError(createGraphQLError(`Variable \"$${varName}\" of non-null type \"${varTypeStr}\" must not be null.`, {\n                nodes: varDefNode,\n            }));\n            continue;\n        }\n        coercedValues[varName] = coerceInputValue(value, varType, (path, invalidValue, error) => {\n            let prefix = `Variable \"$${varName}\" got invalid value ` + inspect(invalidValue);\n            if (path.length > 0) {\n                prefix += ` at \"${varName}${printPathArray(path)}\"`;\n            }\n            onError(createGraphQLError(prefix + '; ' + error.message, {\n                nodes: varDefNode,\n                originalError: error,\n            }));\n        });\n    }\n    return coercedValues;\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAUO,SAAS,kBAAkB,MAAM,EAAE,WAAW,EAAE,MAAM,EAAE,OAAO;IAClE,MAAM,SAAS,EAAE;IACjB,MAAM,YAAY,SAAS;IAC3B,IAAI;QACA,MAAM,UAAU,qBAAqB,QAAQ,aAAa,QAAQ,CAAA;YAC9D,IAAI,aAAa,QAAQ,OAAO,MAAM,IAAI,WAAW;gBACjD,MAAM,IAAA,gRAAkB,EAAC;YAC7B;YACA,OAAO,IAAI,CAAC;QAChB;QACA,IAAI,OAAO,MAAM,KAAK,GAAG;YACrB,OAAO;gBAAE;YAAQ;QACrB;IACJ,EACA,OAAO,OAAO;QACV,OAAO,IAAI,CAAC;IAChB;IACA,OAAO;QAAE;IAAO;AACpB;AACA,SAAS,qBAAqB,MAAM,EAAE,WAAW,EAAE,MAAM,EAAE,OAAO;IAC9D,MAAM,gBAAgB,CAAC;IACvB,KAAK,MAAM,cAAc,YAAa;QAClC,MAAM,UAAU,WAAW,QAAQ,CAAC,IAAI,CAAC,KAAK;QAC9C,MAAM,UAAU,IAAA,0NAAW,EAAC,QAAQ,WAAW,IAAI;QACnD,IAAI,CAAC,IAAA,oNAAW,EAAC,UAAU;YACvB,mEAAmE;YACnE,wDAAwD;YACxD,MAAM,aAAa,IAAA,+MAAK,EAAC,WAAW,IAAI;YACxC,QAAQ,IAAA,gRAAkB,EAAC,CAAC,WAAW,EAAE,QAAQ,0BAA0B,EAAE,WAAW,wCAAwC,CAAC,EAAE;gBAAE,OAAO,WAAW,IAAI;YAAC;YAC5J;QACJ;QACA,IAAI,CAAC,IAAA,6RAAc,EAAC,QAAQ,UAAU;YAClC,IAAI,WAAW,YAAY,EAAE;gBACzB,aAAa,CAAC,QAAQ,GAAG,IAAA,4NAAY,EAAC,WAAW,YAAY,EAAE;YACnE,OACK,IAAI,IAAA,sNAAa,EAAC,UAAU;gBAC7B,MAAM,aAAa,IAAA,yNAAO,EAAC;gBAC3B,QAAQ,IAAA,gRAAkB,EAAC,CAAC,WAAW,EAAE,QAAQ,oBAAoB,EAAE,WAAW,mBAAmB,CAAC,EAAE;oBACpG,OAAO;gBACX;YACJ;YACA;QACJ;QACA,MAAM,QAAQ,MAAM,CAAC,QAAQ;QAC7B,IAAI,UAAU,QAAQ,IAAA,sNAAa,EAAC,UAAU;YAC1C,MAAM,aAAa,IAAA,yNAAO,EAAC;YAC3B,QAAQ,IAAA,gRAAkB,EAAC,CAAC,WAAW,EAAE,QAAQ,oBAAoB,EAAE,WAAW,mBAAmB,CAAC,EAAE;gBACpG,OAAO;YACX;YACA;QACJ;QACA,aAAa,CAAC,QAAQ,GAAG,IAAA,oOAAgB,EAAC,OAAO,SAAS,CAAC,MAAM,cAAc;YAC3E,IAAI,SAAS,CAAC,WAAW,EAAE,QAAQ,oBAAoB,CAAC,GAAG,IAAA,yNAAO,EAAC;YACnE,IAAI,KAAK,MAAM,GAAG,GAAG;gBACjB,UAAU,CAAC,KAAK,EAAE,UAAU,IAAA,0QAAc,EAAC,MAAM,CAAC,CAAC;YACvD;YACA,QAAQ,IAAA,gRAAkB,EAAC,SAAS,OAAO,MAAM,OAAO,EAAE;gBACtD,OAAO;gBACP,eAAe;YACnB;QACJ;IACJ;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 278, "column": 0}, "map": {"version":3,"sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/%40graphql-tools%2Bexecutor%401.5.1%2B2e36366335d68c76/node_modules/%40graphql-tools/executor/esm/execution/execute.js"],"sourcesContent":["import { assertValidSchema, getDirectiveValues, GraphQLError, isAbstractType, isLeafType, isListType, isNonNullType, isObjectType, Kind, SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef, versionInfo, } from 'graphql';\nimport { collectSubFields as _collectSubfields, addPath, collectFields, createGraphQLError, fakePromise, getArgumentValues, getDefinedRootType, GraphQLStreamDirective, inspect, isAsyncIterable, isIterableObject, isObjectLike, isPromise, locatedError, mapAsyncIterator, memoize1, memoize3, pathToArray, promiseReduce, } from '@graphql-tools/utils';\nimport { DisposableSymbols } from '@whatwg-node/disposablestack';\nimport { createDeferredPromise, handleMaybePromise } from '@whatwg-node/promise-helpers';\nimport { coerceError } from './coerceError.js';\nimport { flattenAsyncIterable } from './flattenAsyncIterable.js';\nimport { invariant } from './invariant.js';\nimport { promiseForObject } from './promiseForObject.js';\nimport { getVariableValues } from './values.js';\n/**\n * A memoized collection of relevant subfields with regard to the return\n * type. Memoizing ensures the subfields are not repeatedly calculated, which\n * saves overhead when resolving lists of values.\n */\nconst collectSubfields = memoize3((exeContext, returnType, fieldNodes) => _collectSubfields(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));\n/**\n * Implements the \"Executing requests\" section of the GraphQL specification,\n * including `@defer` and `@stream` as proposed in\n * https://github.com/graphql/graphql-spec/pull/742\n *\n * This function returns a Promise of an IncrementalExecutionResults\n * object. This object either consists of a single ExecutionResult, or an\n * object containing an `initialResult` and a stream of `subsequentResults`.\n *\n * If the arguments to this function do not result in a legal execution context,\n * a GraphQLError will be thrown immediately explaining the invalid input.\n */\nexport function execute(args) {\n    // If a valid execution context cannot be created due to incorrect arguments,\n    // a \"Response\" with only errors is returned.\n    const exeContext = buildExecutionContext(args);\n    // Return early errors if execution context failed.\n    if (!('schema' in exeContext)) {\n        return {\n            errors: exeContext.map(e => {\n                Object.defineProperty(e, 'extensions', {\n                    value: {\n                        ...e.extensions,\n                        http: {\n                            ...(e.extensions?.['http'] || {}),\n                            status: 400,\n                        },\n                    },\n                });\n                return e;\n            }),\n        };\n    }\n    return executeImpl(exeContext);\n}\nfunction executeImpl(exeContext) {\n    exeContext.signal?.throwIfAborted();\n    // Return a Promise that will eventually resolve to the data described by\n    // The \"Response\" section of the GraphQL specification.\n    //\n    // If errors are encountered while executing a GraphQL field, only that\n    // field and its descendants will be omitted, and sibling fields will still\n    // be executed. An execution which encounters errors will still result in a\n    // resolved Promise.\n    //\n    // Errors from sub-fields of a NonNull type may propagate to the top level,\n    // at which point we still log the error and null the parent field, which\n    // in this case is the entire response.\n    return handleMaybePromise(() => executeOperation(exeContext), data => {\n        const initialResult = buildResponse(data, exeContext.errors);\n        if (exeContext.subsequentPayloads.size > 0) {\n            return {\n                initialResult: {\n                    ...initialResult,\n                    hasNext: true,\n                },\n                subsequentResults: yieldSubsequentPayloads(exeContext),\n            };\n        }\n        return initialResult;\n    }, (error) => {\n        exeContext.signal?.throwIfAborted();\n        if (error.errors) {\n            exeContext.errors.push(...error.errors);\n        }\n        else {\n            exeContext.errors.push(error);\n        }\n        return buildResponse(null, exeContext.errors);\n    });\n}\n/**\n * Also implements the \"Executing requests\" section of the GraphQL specification.\n * However, it guarantees to complete synchronously (or throw an error) assuming\n * that all field resolvers are also synchronous.\n */\nexport function executeSync(args) {\n    const result = execute(args);\n    // Assert that the execution was synchronous.\n    if (isPromise(result) || 'initialResult' in result) {\n        throw new Error('GraphQL execution failed to complete synchronously.');\n    }\n    return result;\n}\n/**\n * Given a completed execution context and data, build the `{ errors, data }`\n * response defined by the \"Response\" section of the GraphQL specification.\n */\nfunction buildResponse(data, errors) {\n    return errors.length === 0 ? { data } : { errors, data };\n}\n/**\n * Essential assertions before executing to provide developer feedback for\n * improper use of the GraphQL library.\n *\n * @internal\n */\nexport function assertValidExecutionArguments(schema, document, rawVariableValues) {\n    console.assert(!!document, 'Must provide document.');\n    // If the schema used for execution is invalid, throw an error.\n    assertValidSchema(schema);\n    // Variables, if provided, must be an object.\n    console.assert(rawVariableValues == null || isObjectLike(rawVariableValues), 'Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.');\n}\nexport const getFragmentsFromDocument = memoize1(function getFragmentsFromDocument(document) {\n    const fragments = Object.create(null);\n    for (const definition of document.definitions) {\n        if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n            fragments[definition.name.value] = definition;\n        }\n    }\n    return fragments;\n});\n/**\n * Constructs a ExecutionContext object from the arguments passed to\n * execute, which we will pass throughout the other execution methods.\n *\n * Throws a GraphQLError if a valid execution context cannot be created.\n *\n * TODO: consider no longer exporting this function\n * @internal\n */\nexport function buildExecutionContext(args) {\n    const { schema, document, rootValue, contextValue, variableValues: rawVariableValues, operationName, fieldResolver, typeResolver, subscribeFieldResolver, signal, schemaCoordinateInErrors, } = args;\n    signal?.throwIfAborted();\n    // If the schema used for execution is invalid, throw an error.\n    assertValidSchema(schema);\n    const fragments = getFragmentsFromDocument(document);\n    let operation;\n    for (const definition of document.definitions) {\n        switch (definition.kind) {\n            case Kind.OPERATION_DEFINITION:\n                if (operationName == null) {\n                    if (operation !== undefined) {\n                        return [\n                            createGraphQLError('Must provide operation name if query contains multiple operations.', {\n                                extensions: {\n                                    code: 'OPERATION_RESOLUTION_FAILURE',\n                                },\n                            }),\n                        ];\n                    }\n                    operation = definition;\n                }\n                else if (definition.name?.value === operationName) {\n                    operation = definition;\n                }\n                break;\n            default:\n            // ignore non-executable definitions\n        }\n    }\n    if (operation == null) {\n        if (operationName != null) {\n            return [\n                createGraphQLError(`Unknown operation named \"${operationName}\".`, {\n                    extensions: {\n                        code: 'OPERATION_RESOLUTION_FAILURE',\n                    },\n                }),\n            ];\n        }\n        return [\n            createGraphQLError('Must provide an operation.', {\n                extensions: {\n                    code: 'OPERATION_RESOLUTION_FAILURE',\n                },\n            }),\n        ];\n    }\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n    /* c8 ignore next */\n    const variableDefinitions = operation.variableDefinitions ?? [];\n    const coercedVariableValues = getVariableValues(schema, variableDefinitions, rawVariableValues ?? {}, {\n        maxErrors: 50,\n    });\n    if (coercedVariableValues.errors) {\n        return coercedVariableValues.errors;\n    }\n    signal?.throwIfAborted();\n    let onSignalAbort;\n    let signalPromise;\n    if (signal) {\n        const listeners = new Set();\n        const signalDeferred = createDeferredPromise();\n        signalPromise = signalDeferred.promise;\n        const sharedListener = () => {\n            signalDeferred.reject(signal.reason);\n            signal.removeEventListener('abort', sharedListener);\n        };\n        signal.addEventListener('abort', sharedListener, { once: true });\n        signalPromise.catch(() => {\n            for (const listener of listeners) {\n                listener();\n            }\n            listeners.clear();\n        });\n        onSignalAbort = handler => {\n            listeners.add(handler);\n        };\n    }\n    return {\n        schema,\n        fragments,\n        rootValue,\n        contextValue,\n        operation,\n        variableValues: coercedVariableValues.coerced,\n        fieldResolver: fieldResolver ?? defaultFieldResolver,\n        typeResolver: typeResolver ?? defaultTypeResolver,\n        subscribeFieldResolver: subscribeFieldResolver ?? defaultFieldResolver,\n        subsequentPayloads: new Set(),\n        errors: [],\n        signal,\n        onSignalAbort,\n        signalPromise,\n        schemaCoordinateInErrors,\n    };\n}\nfunction buildPerEventExecutionContext(exeContext, payload) {\n    return {\n        ...exeContext,\n        rootValue: payload,\n        subsequentPayloads: new Set(),\n        errors: [],\n    };\n}\n/**\n * Implements the \"Executing operations\" section of the spec.\n */\nfunction executeOperation(exeContext) {\n    const { operation, schema, fragments, variableValues, rootValue } = exeContext;\n    const rootType = getDefinedRootType(schema, operation.operation, [operation]);\n    if (rootType == null) {\n        createGraphQLError(`Schema is not configured to execute ${operation.operation} operation.`, {\n            nodes: operation,\n        });\n    }\n    const { fields: rootFields, patches } = collectFields(schema, fragments, variableValues, rootType, operation.selectionSet);\n    const path = undefined;\n    let result;\n    if (operation.operation === 'mutation') {\n        result = executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);\n    }\n    else {\n        result = executeFields(exeContext, rootType, rootValue, path, rootFields);\n    }\n    for (const patch of patches) {\n        const { label, fields: patchFields } = patch;\n        executeDeferredFragment(exeContext, rootType, rootValue, patchFields, label, path);\n    }\n    return result;\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that must be executed serially.\n */\nfunction executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {\n    return promiseReduce(fields, (results, [responseName, fieldNodes]) => {\n        const fieldPath = addPath(path, responseName, parentType.name);\n        exeContext.signal?.throwIfAborted();\n        return handleMaybePromise(() => executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath), result => {\n            if (result === undefined) {\n                return results;\n            }\n            results[responseName] = result;\n            return results;\n        });\n    }, Object.create(null));\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that may be executed in parallel.\n */\nfunction executeFields(exeContext, parentType, sourceValue, path, fields, asyncPayloadRecord) {\n    const results = Object.create(null);\n    let containsPromise = false;\n    try {\n        for (const [responseName, fieldNodes] of fields) {\n            exeContext.signal?.throwIfAborted();\n            const fieldPath = addPath(path, responseName, parentType.name);\n            const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath, asyncPayloadRecord);\n            if (result !== undefined) {\n                results[responseName] = result;\n                if (isPromise(result)) {\n                    containsPromise = true;\n                }\n            }\n        }\n    }\n    catch (error) {\n        if (error !== exeContext.signal?.reason && containsPromise) {\n            // Ensure that any promises returned by other fields are handled, as they may also reject.\n            return handleMaybePromise(() => promiseForObject(results, exeContext.signal), () => {\n                throw error;\n            }, () => {\n                throw error;\n            });\n        }\n        throw error;\n    }\n    // If there are no promises, we can just return the object\n    if (!containsPromise) {\n        return results;\n    }\n    // Otherwise, results is a map from field name to the result of resolving that\n    // field, which is possibly a promise. Return a promise that will return this\n    // same map, but with any promises replaced with the values they resolved to.\n    return promiseForObject(results, exeContext.signal, exeContext.signalPromise);\n}\n/**\n * Implements the \"Executing fields\" section of the spec\n * In particular, this function figures out the value that the field returns by\n * calling its resolve function, then calls completeValue to complete promises,\n * serialize scalars, or execute the sub-selection-set for objects.\n */\nfunction executeField(exeContext, parentType, source, fieldNodes, path, asyncPayloadRecord) {\n    const errors = asyncPayloadRecord?.errors ?? exeContext.errors;\n    const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);\n    if (!fieldDef) {\n        return;\n    }\n    const returnType = fieldDef.type;\n    const resolveFn = fieldDef.resolve ?? exeContext.fieldResolver;\n    const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);\n    // Get the resolve function, regardless of if its result is normal or abrupt (error).\n    try {\n        exeContext.signal?.throwIfAborted();\n        // Build a JS object of arguments from the field.arguments AST, using the\n        // variables scope to fulfill any variable references.\n        // TODO: find a way to memoize, in case this field is within a List type.\n        const args = getArgumentValues(fieldDef, fieldNodes[0], exeContext.variableValues);\n        // The resolve function's optional third argument is a context value that\n        // is provided to every resolve function within an execution. It is commonly\n        // used to represent an authenticated user, or request-specific caches.\n        const contextValue = exeContext.contextValue;\n        const result = resolveFn(source, args, contextValue, info);\n        let completed;\n        if (isPromise(result)) {\n            completed = result.then(resolved => completeValue(exeContext, returnType, fieldNodes, info, path, resolved, asyncPayloadRecord));\n        }\n        else {\n            completed = completeValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);\n        }\n        if (isPromise(completed)) {\n            // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n            // to take a second callback for the error case.\n            return completed.then(undefined, rawError => {\n                if (rawError instanceof AggregateError) {\n                    let result;\n                    for (let rawErrorItem of rawError.errors) {\n                        rawErrorItem = coerceError(rawErrorItem);\n                        const error = locatedError(rawErrorItem, fieldNodes, pathToArray(path), exeContext.schemaCoordinateInErrors && info);\n                        result = handleFieldError(error, returnType, errors);\n                        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);\n                    }\n                    return result;\n                }\n                rawError = coerceError(rawError);\n                const error = locatedError(rawError, fieldNodes, pathToArray(path), exeContext.schemaCoordinateInErrors && info);\n                const handledError = handleFieldError(error, returnType, errors);\n                filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);\n                return handledError;\n            });\n        }\n        return completed;\n    }\n    catch (rawError) {\n        if (rawError instanceof AggregateError) {\n            let result;\n            for (let rawErrorItem of rawError.errors) {\n                rawErrorItem = coerceError(rawErrorItem);\n                const error = locatedError(rawErrorItem, fieldNodes, pathToArray(path), exeContext.schemaCoordinateInErrors && info);\n                result = handleFieldError(error, returnType, errors);\n                filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);\n            }\n            return result;\n        }\n        const coercedError = coerceError(rawError);\n        const error = locatedError(coercedError, fieldNodes, pathToArray(path), exeContext.schemaCoordinateInErrors && info);\n        const handledError = handleFieldError(error, returnType, errors);\n        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);\n        return handledError;\n    }\n}\n/**\n * TODO: consider no longer exporting this function\n * @internal\n */\nexport function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {\n    // The resolve function's optional fourth argument is a collection of\n    // information about the current execution state.\n    return {\n        fieldName: fieldDef.name,\n        fieldNodes,\n        returnType: fieldDef.type,\n        parentType,\n        path,\n        schema: exeContext.schema,\n        fragments: exeContext.fragments,\n        rootValue: exeContext.rootValue,\n        operation: exeContext.operation,\n        variableValues: exeContext.variableValues,\n        signal: exeContext.signal,\n    };\n}\nexport const CRITICAL_ERROR = 'CRITICAL_ERROR';\nfunction handleFieldError(error, returnType, errors) {\n    // If the field type is non-nullable, then it is resolved without any\n    // protection from errors, however it still properly locates the error.\n    if (isNonNullType(returnType)) {\n        throw error;\n    }\n    if (error.extensions?.[CRITICAL_ERROR]) {\n        throw error;\n    }\n    // Otherwise, error protection is applied, logging the error and resolving\n    // a null value for this field if one is encountered.\n    errors.push(error);\n    return null;\n}\n/**\n * Implements the instructions for completeValue as defined in the\n * \"Value Completion\" section of the spec.\n *\n * If the field type is Non-Null, then this recursively completes the value\n * for the inner type. It throws a field error if that completion returns null,\n * as per the \"Nullability\" section of the spec.\n *\n * If the field type is a List, then this recursively completes the value\n * for the inner type on each item in the list.\n *\n * If the field type is a Scalar or Enum, ensures the completed value is a legal\n * value of the type by calling the `serialize` method of GraphQL type\n * definition.\n *\n * If the field is an abstract type, determine the runtime type of the value\n * and then complete based on that type\n *\n * Otherwise, the field type expects a sub-selection set, and will complete the\n * value by executing all sub-selections.\n */\nfunction completeValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {\n    // If result is an Error, throw a located error.\n    if (result instanceof Error) {\n        throw result;\n    }\n    // If field type is NonNull, complete for inner type, and throw field error\n    // if result is null.\n    if (isNonNullType(returnType)) {\n        const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result, asyncPayloadRecord);\n        if (completed === null) {\n            throw new Error(`Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`);\n        }\n        return completed;\n    }\n    // If result value is null or undefined then return null.\n    if (result == null) {\n        return null;\n    }\n    // If field type is List, complete each item in the list with the inner type\n    if (isListType(returnType)) {\n        return completeListValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);\n    }\n    // If field type is a leaf type, Scalar or Enum, serialize to a valid value,\n    // returning null if serialization is not possible.\n    if (isLeafType(returnType)) {\n        return completeLeafValue(returnType, result);\n    }\n    // If field type is an abstract type, Interface or Union, determine the\n    // runtime Object type and complete for that type.\n    if (isAbstractType(returnType)) {\n        return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);\n    }\n    // If field type is Object, execute and complete all sub-selections.\n    if (isObjectType(returnType)) {\n        return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);\n    }\n    /* c8 ignore next 6 */\n    // Not reachable, all possible output types have been considered.\n    console.assert(false, 'Cannot complete value of unexpected output type: ' + inspect(returnType));\n}\n/**\n * Returns an object containing the `@stream` arguments if a field should be\n * streamed based on the experimental flag, stream directive present and\n * not disabled by the \"if\" argument.\n */\nfunction getStreamValues(exeContext, fieldNodes, path) {\n    // do not stream inner lists of multi-dimensional lists\n    if (typeof path.key === 'number') {\n        return;\n    }\n    // validation only allows equivalent streams on multiple fields, so it is\n    // safe to only check the first fieldNode for the stream directive\n    const stream = getDirectiveValues(GraphQLStreamDirective, fieldNodes[0], exeContext.variableValues);\n    if (!stream) {\n        return;\n    }\n    if (stream.if === false) {\n        return;\n    }\n    invariant(typeof stream['initialCount'] === 'number', 'initialCount must be a number');\n    invariant(stream['initialCount'] >= 0, 'initialCount must be a positive integer');\n    return {\n        initialCount: stream['initialCount'],\n        label: typeof stream['label'] === 'string' ? stream['label'] : undefined,\n    };\n}\n/**\n * Complete a async iterator value by completing the result and calling\n * recursively until all the results are completed.\n */\nasync function completeAsyncIteratorValue(exeContext, itemType, fieldNodes, info, path, iterator, asyncPayloadRecord) {\n    exeContext.signal?.throwIfAborted();\n    if (iterator.return) {\n        exeContext.onSignalAbort?.(() => {\n            iterator.return?.();\n        });\n    }\n    const errors = asyncPayloadRecord?.errors ?? exeContext.errors;\n    const stream = getStreamValues(exeContext, fieldNodes, path);\n    let containsPromise = false;\n    const completedResults = [];\n    let index = 0;\n    while (true) {\n        if (stream && typeof stream.initialCount === 'number' && index >= stream.initialCount) {\n            executeStreamIterator(index, iterator, exeContext, fieldNodes, info, itemType, path, stream.label, asyncPayloadRecord);\n            break;\n        }\n        const itemPath = addPath(path, index, undefined);\n        let iteration;\n        try {\n            iteration = await iterator.next();\n            if (iteration.done) {\n                break;\n            }\n        }\n        catch (rawError) {\n            const coercedError = coerceError(rawError);\n            const error = locatedError(coercedError, fieldNodes, pathToArray(itemPath), exeContext.schemaCoordinateInErrors && info);\n            completedResults.push(handleFieldError(error, itemType, errors));\n            break;\n        }\n        if (completeListItemValue(iteration.value, completedResults, errors, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord)) {\n            containsPromise = true;\n        }\n        index += 1;\n    }\n    return containsPromise ? Promise.all(completedResults) : completedResults;\n}\n/**\n * Complete a list value by completing each item in the list with the\n * inner type\n */\nfunction completeListValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {\n    const itemType = returnType.ofType;\n    const errors = asyncPayloadRecord?.errors ?? exeContext.errors;\n    if (isAsyncIterable(result)) {\n        const iterator = result[Symbol.asyncIterator]();\n        return completeAsyncIteratorValue(exeContext, itemType, fieldNodes, info, path, iterator, asyncPayloadRecord);\n    }\n    if (!isIterableObject(result)) {\n        throw createGraphQLError(`Expected Iterable, but did not find one for field \"${info.parentType.name}.${info.fieldName}\".`);\n    }\n    const stream = getStreamValues(exeContext, fieldNodes, path);\n    // This is specified as a simple map, however we're optimizing the path\n    // where the list contains no Promises by avoiding creating another Promise.\n    let containsPromise = false;\n    let previousAsyncPayloadRecord = asyncPayloadRecord;\n    const completedResults = [];\n    let index = 0;\n    for (const item of result) {\n        // No need to modify the info object containing the path,\n        // since from here on it is not ever accessed by resolver functions.\n        const itemPath = addPath(path, index, undefined);\n        if (stream && typeof stream.initialCount === 'number' && index >= stream.initialCount) {\n            previousAsyncPayloadRecord = executeStreamField(path, itemPath, item, exeContext, fieldNodes, info, itemType, stream.label, previousAsyncPayloadRecord);\n            index++;\n            continue;\n        }\n        if (completeListItemValue(item, completedResults, errors, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord)) {\n            containsPromise = true;\n        }\n        index++;\n    }\n    return containsPromise ? Promise.all(completedResults) : completedResults;\n}\n/**\n * Complete a list item value by adding it to the completed results.\n *\n * Returns true if the value is a Promise.\n */\nfunction completeListItemValue(item, completedResults, errors, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord) {\n    try {\n        let completedItem;\n        if (isPromise(item)) {\n            completedItem = item.then(resolved => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved, asyncPayloadRecord));\n        }\n        else {\n            completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);\n        }\n        if (isPromise(completedItem)) {\n            // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n            // to take a second callback for the error case.\n            completedResults.push(completedItem.then(undefined, rawError => {\n                rawError = coerceError(rawError);\n                const error = locatedError(rawError, fieldNodes, pathToArray(itemPath), exeContext.schemaCoordinateInErrors && info);\n                const handledError = handleFieldError(error, itemType, errors);\n                filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);\n                return handledError;\n            }));\n            return true;\n        }\n        completedResults.push(completedItem);\n    }\n    catch (rawError) {\n        const coercedError = coerceError(rawError);\n        const error = locatedError(coercedError, fieldNodes, pathToArray(itemPath), exeContext.schemaCoordinateInErrors && info);\n        const handledError = handleFieldError(error, itemType, errors);\n        filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);\n        completedResults.push(handledError);\n    }\n    return false;\n}\n/**\n * Complete a Scalar or Enum by serializing to a valid value, returning\n * null if serialization is not possible.\n */\nfunction completeLeafValue(returnType, result) {\n    let serializedResult;\n    // Note: We transform GraphQLError to Error in order to be consistent with\n    // how non-null checks work later on.\n    // See https://github.com/kamilkisiela/graphql-hive/pull/2299\n    // See https://github.com/n1ru4l/envelop/issues/1808\n    try {\n        serializedResult = returnType.serialize(result);\n    }\n    catch (err) {\n        if (err instanceof GraphQLError) {\n            throw new Error(err.message);\n        }\n        throw err;\n    }\n    if (serializedResult == null) {\n        throw new Error(`Expected \\`${inspect(returnType)}.serialize(${inspect(result)})\\` to ` +\n            `return non-nullable value, returned: ${inspect(serializedResult)}`);\n    }\n    return serializedResult;\n}\n/**\n * Complete a value of an abstract type by determining the runtime object type\n * of that value, then complete the value for that type.\n */\nfunction completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {\n    const resolveTypeFn = returnType.resolveType ?? exeContext.typeResolver;\n    const contextValue = exeContext.contextValue;\n    const runtimeType = resolveTypeFn(result, contextValue, info, returnType);\n    if (isPromise(runtimeType)) {\n        return runtimeType.then(resolvedRuntimeType => completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result, asyncPayloadRecord));\n    }\n    return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result, asyncPayloadRecord);\n}\nfunction ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {\n    if (runtimeTypeName == null) {\n        throw createGraphQLError(`Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\". Either the \"${returnType.name}\" type should provide a \"resolveType\" function or each possible type should provide an \"isTypeOf\" function.`, { nodes: fieldNodes });\n    }\n    // releases before 16.0.0 supported returning `GraphQLObjectType` from `resolveType`\n    // TODO: remove in 17.0.0 release\n    if (isObjectType(runtimeTypeName)) {\n        if (versionInfo.major >= 16) {\n            throw createGraphQLError('Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.');\n        }\n        runtimeTypeName = runtimeTypeName.name;\n    }\n    if (typeof runtimeTypeName !== 'string') {\n        throw createGraphQLError(`Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\" with ` +\n            `value ${inspect(result)}, received \"${inspect(runtimeTypeName)}\".`);\n    }\n    const runtimeType = exeContext.schema.getType(runtimeTypeName);\n    if (runtimeType == null) {\n        throw createGraphQLError(`Abstract type \"${returnType.name}\" was resolved to a type \"${runtimeTypeName}\" that does not exist inside the schema.`, { nodes: fieldNodes });\n    }\n    if (!isObjectType(runtimeType)) {\n        throw createGraphQLError(`Abstract type \"${returnType.name}\" was resolved to a non-object type \"${runtimeTypeName}\".`, { nodes: fieldNodes });\n    }\n    if (!exeContext.schema.isSubType(returnType, runtimeType)) {\n        throw createGraphQLError(`Runtime Object type \"${runtimeType.name}\" is not a possible type for \"${returnType.name}\".`, { nodes: fieldNodes });\n    }\n    return runtimeType;\n}\n/**\n * Complete an Object value by executing all sub-selections.\n */\nfunction completeObjectValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {\n    // If there is an isTypeOf predicate function, call it with the\n    // current result. If isTypeOf returns false, then raise an error rather\n    // than continuing execution.\n    if (returnType.isTypeOf) {\n        const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);\n        if (isPromise(isTypeOf)) {\n            return isTypeOf.then(resolvedIsTypeOf => {\n                if (!resolvedIsTypeOf) {\n                    throw invalidReturnTypeError(returnType, result, fieldNodes);\n                }\n                return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord);\n            });\n        }\n        if (!isTypeOf) {\n            throw invalidReturnTypeError(returnType, result, fieldNodes);\n        }\n    }\n    return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord);\n}\nfunction invalidReturnTypeError(returnType, result, fieldNodes) {\n    return createGraphQLError(`Expected value of type \"${returnType.name}\" but got: ${inspect(result)}.`, {\n        nodes: fieldNodes,\n    });\n}\nfunction collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord) {\n    // Collect sub-fields to execute to complete this value.\n    const { fields: subFieldNodes, patches: subPatches } = collectSubfields(exeContext, returnType, fieldNodes);\n    const subFields = executeFields(exeContext, returnType, result, path, subFieldNodes, asyncPayloadRecord);\n    for (const subPatch of subPatches) {\n        const { label, fields: subPatchFieldNodes } = subPatch;\n        executeDeferredFragment(exeContext, returnType, result, subPatchFieldNodes, label, path, asyncPayloadRecord);\n    }\n    return subFields;\n}\n/**\n * If a resolveType function is not given, then a default resolve behavior is\n * used which attempts two strategies:\n *\n * First, See if the provided value has a `__typename` field defined, if so, use\n * that value as name of the resolved type.\n *\n * Otherwise, test each possible type for the abstract type by calling\n * isTypeOf for the object being coerced, returning the first type that matches.\n */\nexport const defaultTypeResolver = function (value, contextValue, info, abstractType) {\n    // First, look for `__typename`.\n    if (isObjectLike(value) && typeof value['__typename'] === 'string') {\n        return value['__typename'];\n    }\n    // Otherwise, test each possible type.\n    const possibleTypes = info.schema.getPossibleTypes(abstractType);\n    const promisedIsTypeOfResults = [];\n    for (let i = 0; i < possibleTypes.length; i++) {\n        const type = possibleTypes[i];\n        if (type.isTypeOf) {\n            const isTypeOfResult = type.isTypeOf(value, contextValue, info);\n            if (isPromise(isTypeOfResult)) {\n                promisedIsTypeOfResults[i] = isTypeOfResult;\n            }\n            else if (isTypeOfResult) {\n                return type.name;\n            }\n        }\n    }\n    if (promisedIsTypeOfResults.length) {\n        return Promise.all(promisedIsTypeOfResults).then(isTypeOfResults => {\n            for (let i = 0; i < isTypeOfResults.length; i++) {\n                if (isTypeOfResults[i]) {\n                    return possibleTypes[i].name;\n                }\n            }\n        });\n    }\n};\n/**\n * If a resolve function is not given, then a default resolve behavior is used\n * which takes the property of the source object of the same name as the field\n * and returns it as the result, or if it's a function, returns the result\n * of calling that function while passing along args and context value.\n */\nexport const defaultFieldResolver = function (source, args, contextValue, info) {\n    // ensure source is a value for which property access is acceptable.\n    if (isObjectLike(source) || typeof source === 'function') {\n        const property = source[info.fieldName];\n        if (typeof property === 'function') {\n            return source[info.fieldName](args, contextValue, info);\n        }\n        return property;\n    }\n};\n/**\n * Implements the \"Subscribe\" algorithm described in the GraphQL specification,\n * including `@defer` and `@stream` as proposed in\n * https://github.com/graphql/graphql-spec/pull/742\n *\n * Returns a Promise which resolves to either an AsyncIterator (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with descriptive\n * errors and no data will be returned.\n *\n * If the source stream could not be created due to faulty subscription resolver\n * logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to an AsyncIterator, which\n * yields a stream of result representing the response stream.\n *\n * Each result may be an ExecutionResult with no `hasNext` (if executing the\n * event did not use `@defer` or `@stream`), or an\n * `InitialIncrementalExecutionResult` or `SubsequentIncrementalExecutionResult`\n * (if executing the event used `@defer` or `@stream`). In the case of\n * incremental execution results, each event produces a single\n * `InitialIncrementalExecutionResult` followed by one or more\n * `SubsequentIncrementalExecutionResult`s; all but the last have `hasNext: true`,\n * and the last has `hasNext: false`. There is no interleaving between results\n * generated from the same original event.\n *\n * Accepts an object with named arguments.\n */\nexport function subscribe(args) {\n    // If a valid execution context cannot be created due to incorrect arguments,\n    // a \"Response\" with only errors is returned.\n    const exeContext = buildExecutionContext(args);\n    // Return early errors if execution context failed.\n    if (!('schema' in exeContext)) {\n        for (const error of exeContext) {\n            // @ts-expect-error - We are intentionally modifying the errors\n            const extensions = (error.extensions ||= {});\n            const httpExtensions = (extensions['http'] ||= {});\n            httpExtensions.status = 400;\n            error.extensions['code'] = 'BAD_USER_INPUT';\n        }\n        return {\n            errors: exeContext,\n        };\n    }\n    const resultOrStream = createSourceEventStreamImpl(exeContext);\n    if (isPromise(resultOrStream)) {\n        return resultOrStream.then(resolvedResultOrStream => mapSourceToResponse(exeContext, resolvedResultOrStream));\n    }\n    return mapSourceToResponse(exeContext, resultOrStream);\n}\nexport function isIncrementalResults(results) {\n    return results?.initialResult;\n}\nexport function flattenIncrementalResults(incrementalResults) {\n    const subsequentIterator = incrementalResults.subsequentResults;\n    let initialResultSent = false;\n    let done = false;\n    return {\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n        next() {\n            if (done) {\n                return fakePromise({ value: undefined, done });\n            }\n            if (initialResultSent) {\n                return subsequentIterator.next();\n            }\n            initialResultSent = true;\n            return fakePromise({\n                value: incrementalResults.initialResult,\n                done,\n            });\n        },\n        return() {\n            done = true;\n            return subsequentIterator.return();\n        },\n        throw(error) {\n            done = true;\n            return subsequentIterator.throw(error);\n        },\n        [DisposableSymbols.asyncDispose]() {\n            done = true;\n            return subsequentIterator?.[DisposableSymbols.asyncDispose]?.();\n        },\n    };\n}\nasync function* ensureAsyncIterable(someExecutionResult) {\n    if ('initialResult' in someExecutionResult) {\n        yield* flattenIncrementalResults(someExecutionResult);\n    }\n    else {\n        yield someExecutionResult;\n    }\n}\nfunction mapSourceToResponse(exeContext, resultOrStream) {\n    if (!isAsyncIterable(resultOrStream)) {\n        return resultOrStream;\n    }\n    // For each payload yielded from a subscription, map it over the normal\n    // GraphQL `execute` function, with `payload` as the rootValue.\n    // This implements the \"MapSourceToResponseEvent\" algorithm described in\n    // the GraphQL specification. The `execute` function provides the\n    // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n    // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n    return flattenAsyncIterable(mapAsyncIterator(resultOrStream, (payload) => handleMaybePromise(() => executeImpl(buildPerEventExecutionContext(exeContext, payload)), ensureAsyncIterable), (error) => {\n        if (error instanceof AggregateError) {\n            throw new AggregateError(error.errors.map(e => wrapError(e, exeContext.operation)), error.message);\n        }\n        throw wrapError(error, exeContext.operation);\n    }));\n}\nfunction wrapError(error, operation) {\n    return createGraphQLError(error.message, {\n        originalError: error,\n        nodes: [operation],\n    });\n}\nfunction createSourceEventStreamImpl(exeContext) {\n    try {\n        const eventStream = executeSubscription(exeContext);\n        if (isPromise(eventStream)) {\n            return eventStream.then(undefined, error => ({ errors: [error] }));\n        }\n        return eventStream;\n    }\n    catch (error) {\n        return { errors: [error] };\n    }\n}\nfunction executeSubscription(exeContext) {\n    const { schema, fragments, operation, variableValues, rootValue } = exeContext;\n    const rootType = schema.getSubscriptionType();\n    if (rootType == null) {\n        throw createGraphQLError('Schema is not configured to execute subscription operation.', {\n            nodes: operation,\n        });\n    }\n    const { fields: rootFields } = collectFields(schema, fragments, variableValues, rootType, operation.selectionSet);\n    const [responseName, fieldNodes] = [...rootFields.entries()][0];\n    const fieldName = fieldNodes[0].name.value;\n    const fieldDef = getFieldDef(schema, rootType, fieldNodes[0]);\n    if (!fieldDef) {\n        throw createGraphQLError(`The subscription field \"${fieldName}\" is not defined.`, {\n            nodes: fieldNodes,\n        });\n    }\n    const path = addPath(undefined, responseName, rootType.name);\n    const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, rootType, path);\n    try {\n        // Implements the \"ResolveFieldEventStream\" algorithm from GraphQL specification.\n        // It differs from \"ResolveFieldValue\" due to providing a different `resolveFn`.\n        // Build a JS object of arguments from the field.arguments AST, using the\n        // variables scope to fulfill any variable references.\n        const args = getArgumentValues(fieldDef, fieldNodes[0], variableValues);\n        // The resolve function's optional third argument is a context value that\n        // is provided to every resolve function within an execution. It is commonly\n        // used to represent an authenticated user, or request-specific caches.\n        const contextValue = exeContext.contextValue;\n        // Call the `subscribe()` resolver or the default resolver to produce an\n        // AsyncIterable yielding raw payloads.\n        const resolveFn = fieldDef.subscribe ?? exeContext.subscribeFieldResolver;\n        const result = resolveFn(rootValue, args, contextValue, info);\n        if (isPromise(result)) {\n            return result\n                .then(result => assertEventStream(result, exeContext.signal, exeContext.onSignalAbort))\n                .then(undefined, error => {\n                throw locatedError(error, fieldNodes, pathToArray(path), exeContext.schemaCoordinateInErrors && info);\n            });\n        }\n        return assertEventStream(result, exeContext.signal, exeContext.onSignalAbort);\n    }\n    catch (error) {\n        throw locatedError(error, fieldNodes, pathToArray(path), exeContext.schemaCoordinateInErrors && info);\n    }\n}\nfunction assertEventStream(result, signal, onSignalAbort) {\n    signal?.throwIfAborted();\n    if (result instanceof Error) {\n        throw result;\n    }\n    // Assert field returned an event stream, otherwise yield an error.\n    if (!isAsyncIterable(result)) {\n        throw createGraphQLError('Subscription field must return Async Iterable. ' + `Received: ${inspect(result)}.`);\n    }\n    if (onSignalAbort) {\n        return {\n            [Symbol.asyncIterator]() {\n                const asyncIterator = result[Symbol.asyncIterator]();\n                if (asyncIterator.return) {\n                    onSignalAbort?.(() => {\n                        asyncIterator.return?.();\n                    });\n                }\n                return asyncIterator;\n            },\n        };\n    }\n    return result;\n}\nfunction executeDeferredFragment(exeContext, parentType, sourceValue, fields, label, path, parentContext) {\n    const asyncPayloadRecord = new DeferredFragmentRecord({\n        label,\n        path,\n        parentContext,\n        exeContext,\n    });\n    let promiseOrData;\n    try {\n        promiseOrData = executeFields(exeContext, parentType, sourceValue, path, fields, asyncPayloadRecord);\n        if (isPromise(promiseOrData)) {\n            promiseOrData = promiseOrData.then(null, e => {\n                asyncPayloadRecord.errors.push(e);\n                return null;\n            });\n        }\n    }\n    catch (e) {\n        asyncPayloadRecord.errors.push(e);\n        promiseOrData = null;\n    }\n    asyncPayloadRecord.addData(promiseOrData);\n}\nfunction executeStreamField(path, itemPath, item, exeContext, fieldNodes, info, itemType, label, parentContext) {\n    const asyncPayloadRecord = new StreamRecord({\n        label,\n        path: itemPath,\n        parentContext,\n        exeContext,\n    });\n    let completedItem;\n    try {\n        try {\n            if (isPromise(item)) {\n                completedItem = item.then(resolved => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved, asyncPayloadRecord));\n            }\n            else {\n                completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);\n            }\n            if (isPromise(completedItem)) {\n                // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n                // to take a second callback for the error case.\n                completedItem = completedItem.then(undefined, rawError => {\n                    rawError = coerceError(rawError);\n                    const error = locatedError(rawError, fieldNodes, pathToArray(itemPath), exeContext.schemaCoordinateInErrors && info);\n                    const handledError = handleFieldError(error, itemType, asyncPayloadRecord.errors);\n                    filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);\n                    return handledError;\n                });\n            }\n        }\n        catch (rawError) {\n            const coercedError = coerceError(rawError);\n            const error = locatedError(coercedError, fieldNodes, pathToArray(itemPath), exeContext.schemaCoordinateInErrors && info);\n            completedItem = handleFieldError(error, itemType, asyncPayloadRecord.errors);\n            filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);\n        }\n    }\n    catch (error) {\n        asyncPayloadRecord.errors.push(error);\n        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);\n        asyncPayloadRecord.addItems(null);\n        return asyncPayloadRecord;\n    }\n    let completedItems;\n    if (isPromise(completedItem)) {\n        completedItems = completedItem.then(value => [value], error => {\n            asyncPayloadRecord.errors.push(error);\n            filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);\n            return null;\n        });\n    }\n    else {\n        completedItems = [completedItem];\n    }\n    asyncPayloadRecord.addItems(completedItems);\n    return asyncPayloadRecord;\n}\nasync function executeStreamIteratorItem(iterator, exeContext, fieldNodes, info, itemType, asyncPayloadRecord, itemPath) {\n    let item;\n    try {\n        const { value, done } = await iterator.next();\n        if (done) {\n            asyncPayloadRecord.setIsCompletedIterator();\n            return { done, value: undefined };\n        }\n        item = value;\n    }\n    catch (rawError) {\n        const coercedError = coerceError(rawError);\n        const error = locatedError(coercedError, fieldNodes, pathToArray(itemPath), exeContext.schemaCoordinateInErrors && info);\n        const value = handleFieldError(error, itemType, asyncPayloadRecord.errors);\n        // don't continue if iterator throws\n        return { done: true, value };\n    }\n    let completedItem;\n    try {\n        completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);\n        if (isPromise(completedItem)) {\n            completedItem = completedItem.then(undefined, rawError => {\n                const error = locatedError(rawError, fieldNodes, pathToArray(itemPath), exeContext.schemaCoordinateInErrors && info);\n                const handledError = handleFieldError(error, itemType, asyncPayloadRecord.errors);\n                filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);\n                return handledError;\n            });\n        }\n        return { done: false, value: completedItem };\n    }\n    catch (rawError) {\n        const error = locatedError(rawError, fieldNodes, pathToArray(itemPath), exeContext.schemaCoordinateInErrors && info);\n        const value = handleFieldError(error, itemType, asyncPayloadRecord.errors);\n        filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);\n        return { done: false, value };\n    }\n}\nasync function executeStreamIterator(initialIndex, iterator, exeContext, fieldNodes, info, itemType, path, label, parentContext) {\n    let index = initialIndex;\n    let previousAsyncPayloadRecord = parentContext ?? undefined;\n    while (true) {\n        const itemPath = addPath(path, index, undefined);\n        const asyncPayloadRecord = new StreamRecord({\n            label,\n            path: itemPath,\n            parentContext: previousAsyncPayloadRecord,\n            iterator,\n            exeContext,\n        });\n        let iteration;\n        try {\n            iteration = await executeStreamIteratorItem(iterator, exeContext, fieldNodes, info, itemType, asyncPayloadRecord, itemPath);\n        }\n        catch (error) {\n            asyncPayloadRecord.errors.push(error);\n            filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);\n            asyncPayloadRecord.addItems(null);\n            // entire stream has errored and bubbled upwards\n            if (iterator?.return) {\n                iterator.return().catch(() => {\n                    // ignore errors\n                });\n            }\n            return;\n        }\n        const { done, value: completedItem } = iteration;\n        let completedItems;\n        if (isPromise(completedItem)) {\n            completedItems = completedItem.then(value => [value], error => {\n                asyncPayloadRecord.errors.push(error);\n                filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);\n                return null;\n            });\n        }\n        else {\n            completedItems = [completedItem];\n        }\n        asyncPayloadRecord.addItems(completedItems);\n        if (done) {\n            break;\n        }\n        previousAsyncPayloadRecord = asyncPayloadRecord;\n        index++;\n    }\n}\nfunction filterSubsequentPayloads(exeContext, nullPath, currentAsyncRecord) {\n    const nullPathArray = pathToArray(nullPath);\n    exeContext.subsequentPayloads.forEach(asyncRecord => {\n        if (asyncRecord === currentAsyncRecord) {\n            // don't remove payload from where error originates\n            return;\n        }\n        for (let i = 0; i < nullPathArray.length; i++) {\n            if (asyncRecord.path[i] !== nullPathArray[i]) {\n                // asyncRecord points to a path unaffected by this payload\n                return;\n            }\n        }\n        // asyncRecord path points to nulled error field\n        if (isStreamPayload(asyncRecord) && asyncRecord.iterator?.return) {\n            asyncRecord.iterator.return().catch(() => {\n                // ignore error\n            });\n        }\n        exeContext.subsequentPayloads.delete(asyncRecord);\n    });\n}\nfunction getCompletedIncrementalResults(exeContext) {\n    const incrementalResults = [];\n    for (const asyncPayloadRecord of exeContext.subsequentPayloads) {\n        const incrementalResult = {};\n        if (!asyncPayloadRecord.isCompleted) {\n            continue;\n        }\n        exeContext.subsequentPayloads.delete(asyncPayloadRecord);\n        if (isStreamPayload(asyncPayloadRecord)) {\n            const items = asyncPayloadRecord.items;\n            if (asyncPayloadRecord.isCompletedIterator) {\n                // async iterable resolver just finished but there may be pending payloads\n                continue;\n            }\n            incrementalResult.items = items;\n        }\n        else {\n            const data = asyncPayloadRecord.data;\n            incrementalResult.data = data ?? null;\n        }\n        incrementalResult.path = asyncPayloadRecord.path;\n        if (asyncPayloadRecord.label) {\n            incrementalResult.label = asyncPayloadRecord.label;\n        }\n        if (asyncPayloadRecord.errors.length > 0) {\n            incrementalResult.errors = asyncPayloadRecord.errors;\n        }\n        incrementalResults.push(incrementalResult);\n    }\n    return incrementalResults;\n}\nfunction yieldSubsequentPayloads(exeContext) {\n    let isDone = false;\n    async function next() {\n        if (isDone) {\n            return { value: undefined, done: true };\n        }\n        const subSequentPayloadPromises = Array.from(exeContext.subsequentPayloads).map(record => record.promise);\n        if (exeContext.signalPromise) {\n            await Promise.race([exeContext.signalPromise, ...subSequentPayloadPromises]);\n        }\n        else {\n            await Promise.race(subSequentPayloadPromises);\n        }\n        if (isDone) {\n            // a different call to next has exhausted all payloads\n            return { value: undefined, done: true };\n        }\n        const incremental = getCompletedIncrementalResults(exeContext);\n        const hasNext = exeContext.subsequentPayloads.size > 0;\n        if (!incremental.length && hasNext) {\n            return next();\n        }\n        if (!hasNext) {\n            isDone = true;\n        }\n        return {\n            value: incremental.length ? { incremental, hasNext } : { hasNext },\n            done: false,\n        };\n    }\n    function returnStreamIterators() {\n        const promises = [];\n        exeContext.subsequentPayloads.forEach(asyncPayloadRecord => {\n            if (isStreamPayload(asyncPayloadRecord) && asyncPayloadRecord.iterator?.return) {\n                promises.push(asyncPayloadRecord.iterator.return());\n            }\n        });\n        return Promise.all(promises);\n    }\n    return {\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n        next,\n        async return() {\n            await returnStreamIterators();\n            isDone = true;\n            return { value: undefined, done: true };\n        },\n        async throw(error) {\n            await returnStreamIterators();\n            isDone = true;\n            throw error;\n        },\n        async [DisposableSymbols.asyncDispose]() {\n            await returnStreamIterators();\n            isDone = true;\n        },\n    };\n}\nclass DeferredFragmentRecord {\n    type;\n    errors;\n    label;\n    path;\n    promise;\n    data;\n    parentContext;\n    isCompleted;\n    _exeContext;\n    _resolve;\n    constructor(opts) {\n        this.type = 'defer';\n        this.label = opts.label;\n        this.path = pathToArray(opts.path);\n        this.parentContext = opts.parentContext;\n        this.errors = [];\n        this._exeContext = opts.exeContext;\n        this._exeContext.subsequentPayloads.add(this);\n        this.isCompleted = false;\n        this.data = null;\n        this.promise = new Promise(resolve => {\n            this._resolve = MaybePromise => {\n                resolve(MaybePromise);\n            };\n        }).then(data => {\n            this.data = data;\n            this.isCompleted = true;\n        });\n    }\n    addData(data) {\n        const parentData = this.parentContext?.promise;\n        if (parentData) {\n            this._resolve?.(parentData.then(() => data));\n            return;\n        }\n        this._resolve?.(data);\n    }\n}\nclass StreamRecord {\n    type;\n    errors;\n    label;\n    path;\n    items;\n    promise;\n    parentContext;\n    iterator;\n    isCompletedIterator;\n    isCompleted;\n    _exeContext;\n    _resolve;\n    constructor(opts) {\n        this.type = 'stream';\n        this.items = null;\n        this.label = opts.label;\n        this.path = pathToArray(opts.path);\n        this.parentContext = opts.parentContext;\n        this.iterator = opts.iterator;\n        this.errors = [];\n        this._exeContext = opts.exeContext;\n        this._exeContext.subsequentPayloads.add(this);\n        this.isCompleted = false;\n        this.items = null;\n        this.promise = new Promise(resolve => {\n            this._resolve = MaybePromise => {\n                resolve(MaybePromise);\n            };\n        }).then(items => {\n            this.items = items;\n            this.isCompleted = true;\n        });\n    }\n    addItems(items) {\n        const parentData = this.parentContext?.promise;\n        if (parentData) {\n            this._resolve?.(parentData.then(() => items));\n            return;\n        }\n        this._resolve?.(items);\n    }\n    setIsCompletedIterator() {\n        this.isCompletedIterator = true;\n    }\n}\nfunction isStreamPayload(asyncPayload) {\n    return asyncPayload.type === 'stream';\n}\n/**\n * This method looks up the field on the given type definition.\n * It has special casing for the three introspection fields,\n * __schema, __type and __typename. __typename is special because\n * it can always be queried as a field, even in situations where no\n * other fields are allowed, like on a Union. __schema and __type\n * could get automatically added to the query type, but that would\n * require mutating type definitions, which would cause issues.\n *\n * @internal\n */\nexport function getFieldDef(schema, parentType, fieldNode) {\n    const fieldName = fieldNode.name.value;\n    if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n        return SchemaMetaFieldDef;\n    }\n    else if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n        return TypeMetaFieldDef;\n    }\n    else if (fieldName === TypeNameMetaFieldDef.name) {\n        return TypeNameMetaFieldDef;\n    }\n    return parentType.getFields()[fieldName];\n}\nexport function isIncrementalResult(result) {\n    return 'incremental' in result;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1657, "column": 0}, "map": {"version":3,"sources":["file:///home/dev/projects/prisma-tools/node_modules/.bun/%40graphql-tools%2Bexecutor%401.5.1%2B2e36366335d68c76/node_modules/%40graphql-tools/executor/esm/execution/normalizedExecutor.js"],"sourcesContent":["import { getOperationAST } from 'graphql';\nimport { memoize1, } from '@graphql-tools/utils';\nimport { handleMaybePromise } from '@whatwg-node/promise-helpers';\nimport { execute, flattenIncrementalResults, isIncrementalResults, subscribe, } from './execute.js';\nexport function normalizedExecutor(args) {\n    const operationAST = getOperationAST(args.document, args.operationName);\n    if (operationAST == null) {\n        throw new Error('Must provide an operation.');\n    }\n    if (operationAST.operation === 'subscription') {\n        return subscribe(args);\n    }\n    return handleMaybePromise(() => execute(args), result => {\n        if (isIncrementalResults(result)) {\n            return flattenIncrementalResults(result);\n        }\n        return result;\n    });\n}\nexport const executorFromSchema = memoize1(function executorFromSchema(schema) {\n    return function schemaExecutor(request) {\n        return normalizedExecutor({\n            schema,\n            document: request.document,\n            variableValues: request.variables,\n            operationName: request.operationName,\n            rootValue: request.rootValue,\n            contextValue: request.context,\n            signal: request.signal || request.info?.signal,\n            schemaCoordinateInErrors: request.schemaCoordinateInErrors,\n        });\n    };\n});\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;AACO,SAAS,mBAAmB,IAAI;IACnC,MAAM,eAAe,IAAA,kOAAe,EAAC,KAAK,QAAQ,EAAE,KAAK,aAAa;IACtE,IAAI,gBAAgB,MAAM;QACtB,MAAM,IAAI,MAAM;IACpB;IACA,IAAI,aAAa,SAAS,KAAK,gBAAgB;QAC3C,OAAO,IAAA,0RAAS,EAAC;IACrB;IACA,OAAO,IAAA,gRAAkB,EAAC,IAAM,IAAA,wRAAO,EAAC,OAAO,CAAA;QAC3C,IAAI,IAAA,qSAAoB,EAAC,SAAS;YAC9B,OAAO,IAAA,0SAAyB,EAAC;QACrC;QACA,OAAO;IACX;AACJ;AACO,MAAM,qBAAqB,IAAA,uQAAQ,EAAC,SAAS,mBAAmB,MAAM;IACzE,OAAO,SAAS,eAAe,OAAO;QAClC,OAAO,mBAAmB;YACtB;YACA,UAAU,QAAQ,QAAQ;YAC1B,gBAAgB,QAAQ,SAAS;YACjC,eAAe,QAAQ,aAAa;YACpC,WAAW,QAAQ,SAAS;YAC5B,cAAc,QAAQ,OAAO;YAC7B,QAAQ,QAAQ,MAAM,IAAI,QAAQ,IAAI,EAAE;YACxC,0BAA0B,QAAQ,wBAAwB;QAC9D;IACJ;AACJ","ignoreList":[0]}}]
}