import { afterAll, beforeAll, describe, expect, test } from 'bun:test';
import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';
import { dirname, join } from 'node:path';
import type { DMMF } from '@prisma/generator-helper';
import { createTempDir } from '../../../tests/helpers/temp-dir';
import { resolveConfig } from '../src/config/loader';
import { ensureDir } from '../src/utils/paths';
import { writeAdmin } from '../src/writers/admin/index';
import { writeDmmf } from '../src/writers/dmmf';
import { writeGraphQL } from '../src/writers/graphql/index';
import { writeNexus } from '../src/writers/nexus/index';
import { writeTypes } from '../src/writers/types';

// Mock DMMF for testing
const mockDmmf: DMMF.Document = {
  datamodel: {
    models: [
      {
        name: 'User',
        dbName: null,
        fields: [
          {
            name: 'id',
            kind: 'scalar',
            isList: false,
            isRequired: true,
            isUnique: false,
            isId: true,
            isReadOnly: false,
            hasDefaultValue: true,
            type: 'Int',
            default: { name: 'autoincrement', args: [] },
            isGenerated: false,
            isUpdatedAt: false,
          },
          {
            name: 'email',
            kind: 'scalar',
            isList: false,
            isRequired: true,
            isUnique: true,
            isId: false,
            isReadOnly: false,
            hasDefaultValue: false,
            type: 'String',
            isGenerated: false,
            isUpdatedAt: false,
          },
        ],
        primaryKey: null,
        uniqueFields: [],
        uniqueIndexes: [],
        isGenerated: false,
      },
      {
        name: 'Post',
        dbName: null,
        fields: [
          {
            name: 'id',
            kind: 'scalar',
            isList: false,
            isRequired: true,
            isUnique: false,
            isId: true,
            isReadOnly: false,
            hasDefaultValue: true,
            type: 'Int',
            default: { name: 'autoincrement', args: [] },
            isGenerated: false,
            isUpdatedAt: false,
          },
          {
            name: 'title',
            kind: 'scalar',
            isList: false,
            isRequired: true,
            isUnique: false,
            isId: false,
            isReadOnly: false,
            hasDefaultValue: false,
            type: 'String',
            isGenerated: false,
            isUpdatedAt: false,
          },
        ],
        primaryKey: null,
        uniqueFields: [],
        uniqueIndexes: [],
        isGenerated: false,
      },
    ],
    enums: [
      {
        name: 'Role',
        values: [
          { name: 'USER', dbName: null },
          { name: 'ADMIN', dbName: null },
        ],
        dbName: null,
      },
    ],
    types: [],
  },
  schema: {
    inputObjectTypes: {
      prisma: [
        {
          name: 'UserWhereInput',
          constraints: { maxNumFields: null, minNumFields: null },
          fields: [
            {
              name: 'id',
              isRequired: false,
              isNullable: false,
              inputTypes: [{ type: 'Int', isList: false, location: 'scalar' }],
            },
          ],
        },
      ],
    },
    outputObjectTypes: {
      prisma: [
        {
          name: 'Query',
          fields: [],
        },
        {
          name: 'Mutation',
          fields: [],
        },
      ],
      model: [],
    },
    enumTypes: {
      prisma: [
        {
          name: 'SortOrder',
          values: ['asc', 'desc'],
        },
      ],
    },
    fieldRefTypes: {
      prisma: [],
    },
  },
  mappings: {
    modelOperations: [],
    otherOperations: { read: [], write: [] },
  },
};

/**
 * Helper function that mimics generateIndexFile from generator.ts
 * This is a direct copy of the logic since generator.ts doesn't export it
 */
function generateIndexFile(config: ReturnType<typeof resolveConfig>): string {
  const exports: string[] = [
    '// Generated by @paljs/generator - DO NOT EDIT',
    '',
    '// DMMF exports',
    "export { dmmf } from './dmmf/index.js';",
    "export type { DMMF } from '@prisma/generator-helper';",
  ];

  if (config.generateTypes) {
    exports.push('');
    exports.push('// Type exports for PrismaSelect');
    exports.push("export * from './types/index.js';");
  }

  if (config.generateGraphQL && typeof config.generateGraphQL === 'object' && config.generateGraphQL.nexus) {
    const nexusOutput = (config.generateGraphQL.nexusOutput || 'nexus').replace(/^\.\//, '');
    exports.push('');
    exports.push('// Nexus GraphQL exports');
    exports.push(`export * from './${nexusOutput}/index.js';`);
  }

  if (config.generateAdmin && typeof config.generateAdmin === 'object' && config.generateAdmin.enabled) {
    const adminOutput = (config.generateAdmin.output || 'admin').replace(/^\.\//, '');
    exports.push('');
    exports.push('// Admin schema exports');
    exports.push(`export { default as adminSchema } from './${adminOutput}/schema.json' with { type: 'json' };`);
  }

  return exports.join('\n') + '\n';
}

describe('Generator Entry Point', () => {
  describe('generateIndexFile', () => {
    test('generates basic index with DMMF exports', () => {
      const config = resolveConfig({});
      const content = generateIndexFile(config);

      expect(content).toContain('// Generated by @paljs/generator - DO NOT EDIT');
      expect(content).toContain('// DMMF exports');
      expect(content).toContain("export { dmmf } from './dmmf/index.js';");
      expect(content).toContain("export type { DMMF } from '@prisma/generator-helper';");
    });

    test('includes types exports when generateTypes is enabled', () => {
      const config = resolveConfig({ generateTypes: true });
      const content = generateIndexFile(config);

      expect(content).toContain('// Type exports for PrismaSelect');
      expect(content).toContain("export * from './types/index.js';");
    });

    test('excludes types exports when generateTypes is disabled', () => {
      const config = resolveConfig({ generateTypes: false });
      const content = generateIndexFile(config);

      expect(content).not.toContain('./types/index.js');
    });

    test('includes Nexus exports when generateGraphQL.nexus is enabled', () => {
      const config = resolveConfig({
        generateGraphQL: { nexus: true },
      });
      const content = generateIndexFile(config);

      expect(content).toContain('// Nexus GraphQL exports');
      expect(content).toContain("export * from './nexus/index.js';");
    });

    test('uses custom nexusOutput path', () => {
      const config = resolveConfig({
        generateGraphQL: { nexus: true, nexusOutput: 'graphql-types' },
      });
      const content = generateIndexFile(config);

      expect(content).toContain("export * from './graphql-types/index.js';");
    });

    test('strips leading ./ from nexusOutput', () => {
      const config = resolveConfig({
        generateGraphQL: { nexus: true, nexusOutput: './custom-nexus' },
      });
      const content = generateIndexFile(config);

      expect(content).toContain("export * from './custom-nexus/index.js';");
      expect(content).not.toContain("'.//");
    });

    test('includes Admin exports when generateAdmin is enabled', () => {
      const config = resolveConfig({
        generateAdmin: { enabled: true },
      });
      const content = generateIndexFile(config);

      expect(content).toContain('// Admin schema exports');
      expect(content).toContain("export { default as adminSchema } from './admin/schema.json' with { type: 'json' };");
    });

    test('uses custom admin output path', () => {
      const config = resolveConfig({
        generateAdmin: { enabled: true, output: 'admin-config' },
      });
      const content = generateIndexFile(config);

      expect(content).toContain("export { default as adminSchema } from './admin-config/schema.json'");
    });

    test('strips leading ./ from admin output', () => {
      const config = resolveConfig({
        generateAdmin: { enabled: true, output: './my-admin' },
      });
      const content = generateIndexFile(config);

      expect(content).toContain("export { default as adminSchema } from './my-admin/schema.json'");
      expect(content).not.toContain("'.//");
    });

    test('includes all exports when everything is enabled', () => {
      const config = resolveConfig({
        generateTypes: true,
        generateGraphQL: { nexus: true },
        generateAdmin: { enabled: true },
      });
      const content = generateIndexFile(config);

      expect(content).toContain('export { dmmf }');
      expect(content).toContain("export * from './types/index.js';");
      expect(content).toContain("export * from './nexus/index.js';");
      expect(content).toContain('export { default as adminSchema }');
    });

    test('excludes Nexus exports when only client is enabled', () => {
      const config = resolveConfig({
        generateGraphQL: { client: true, nexus: false },
      });
      const content = generateIndexFile(config);

      expect(content).not.toContain('nexus/index.js');
    });
  });

  describe('full generation workflow', () => {
    let tempDir: { path: string; cleanup: () => void };

    beforeAll(() => {
      tempDir = createTempDir('generator-workflow');
    });

    afterAll(() => {
      tempDir.cleanup();
    });

    test('creates output directory with ensureDir', () => {
      const outputDir = join(tempDir.path, 'generated', 'paljs');
      ensureDir(outputDir);

      expect(existsSync(outputDir)).toBe(true);
    });

    test('writeDmmf creates dmmf files', () => {
      const outputDir = join(tempDir.path, 'test-dmmf');
      ensureDir(outputDir);

      const result = writeDmmf(outputDir, mockDmmf);

      expect(existsSync(result.jsonPath)).toBe(true);
      expect(existsSync(result.tsPath)).toBe(true);

      const jsonContent = readFileSync(result.jsonPath, 'utf-8');
      const parsed = JSON.parse(jsonContent);
      expect(parsed.datamodel.models).toHaveLength(2);
    });

    test('writeTypes creates types file when enabled', () => {
      const outputDir = join(tempDir.path, 'test-types');
      ensureDir(outputDir);

      const config = resolveConfig({ generateTypes: true });
      const typesPath = writeTypes({ outputDir, dmmf: mockDmmf, config });

      expect(existsSync(typesPath)).toBe(true);

      const content = readFileSync(typesPath, 'utf-8');
      expect(content).toContain('export interface UserSelect');
    });

    test('writeNexus creates nexus files when enabled', () => {
      const outputDir = join(tempDir.path, 'test-nexus');
      ensureDir(outputDir);

      const config = resolveConfig({ generateGraphQL: { nexus: true } });
      const paths = writeNexus({ outputDir, dmmf: mockDmmf, config });

      expect(paths.length).toBeGreaterThan(0);
      expect(existsSync(join(outputDir, 'nexus'))).toBe(true);
      expect(existsSync(join(outputDir, 'nexus', 'User'))).toBe(true);
    });

    test('writeGraphQL creates graphql files when enabled', () => {
      const outputDir = join(tempDir.path, 'test-graphql');
      ensureDir(outputDir);

      const config = resolveConfig({ generateGraphQL: { client: true } });
      const paths = writeGraphQL({ outputDir, dmmf: mockDmmf, config });

      expect(paths.length).toBeGreaterThan(0);
      expect(existsSync(join(outputDir, 'graphql'))).toBe(true);
      expect(existsSync(join(outputDir, 'graphql', 'User.graphql'))).toBe(true);
    });

    test('writeAdmin creates admin files when enabled', () => {
      const outputDir = join(tempDir.path, 'test-admin');
      ensureDir(outputDir);

      const config = resolveConfig({ generateAdmin: { enabled: true } });
      const paths = writeAdmin({ outputDir, dmmf: mockDmmf, config });

      expect(paths.length).toBeGreaterThan(0);
      expect(existsSync(join(outputDir, 'admin'))).toBe(true);
      expect(existsSync(join(outputDir, 'admin', 'schema.json'))).toBe(true);
    });

    test('complete generation creates all expected files', () => {
      const outputDir = join(tempDir.path, 'test-complete');
      ensureDir(outputDir);

      const config = resolveConfig({
        generateTypes: true,
        generateGraphQL: { nexus: true, client: true },
        generateAdmin: { enabled: true },
      });

      // Write DMMF
      writeDmmf(outputDir, mockDmmf);

      // Write Types
      writeTypes({ outputDir, dmmf: mockDmmf, config });

      // Write Nexus
      writeNexus({ outputDir, dmmf: mockDmmf, config });

      // Write GraphQL
      writeGraphQL({ outputDir, dmmf: mockDmmf, config });

      // Write Admin
      writeAdmin({ outputDir, dmmf: mockDmmf, config });

      // Write index
      const indexContent = generateIndexFile(config);
      const indexPath = join(outputDir, 'index.ts');
      writeFileSync(indexPath, indexContent, 'utf-8');

      // Verify structure
      expect(existsSync(join(outputDir, 'dmmf', 'dmmf.json'))).toBe(true);
      expect(existsSync(join(outputDir, 'types', 'index.ts'))).toBe(true);
      expect(existsSync(join(outputDir, 'nexus', 'index.ts'))).toBe(true);
      expect(existsSync(join(outputDir, 'graphql', 'index.graphql'))).toBe(true);
      expect(existsSync(join(outputDir, 'admin', 'schema.json'))).toBe(true);
      expect(existsSync(indexPath)).toBe(true);
    });
  });

  describe('config resolution for generator', () => {
    test('resolves minimal config with defaults', () => {
      const config = resolveConfig({});

      expect(config.generateTypes).toBe(true);
      expect(config.generateGraphQL).toBe(false);
      expect(config.generateAdmin).toBe(false);
      expect(config.prismaName).toBe('prisma');
    });

    test('resolves generateGraphQL: true to object config', () => {
      const config = resolveConfig({ generateGraphQL: true });

      expect(typeof config.generateGraphQL).toBe('object');
      expect((config.generateGraphQL as any).nexus).toBe(true);
      // When generateGraphQL: true, client defaults to false (backwards compatible behavior)
      expect((config.generateGraphQL as any).client).toBe(false);
    });

    test('resolves generateAdmin: true to object config', () => {
      const config = resolveConfig({ generateAdmin: true });

      expect(typeof config.generateAdmin).toBe('object');
      expect((config.generateAdmin as any).enabled).toBe(true);
    });

    test('merges partial model configs with defaults', () => {
      const config = resolveConfig({
        models: {
          User: { exclude: true },
        },
      });

      expect(config.models).toBeDefined();
      expect(config.models?.User?.exclude).toBe(true);
    });
  });
});
