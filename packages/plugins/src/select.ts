import type { DMMF } from '@prisma/generator-helper';
import type { GraphQLResolveInfo } from 'graphql';
import { parseResolveInfo } from 'graphql-parse-resolve-info';

/**
 * Result type for Prisma select objects
 * Used by findMany, findUnique, and other queries
 */
export interface PrismaSelectResult {
  select?: Record<string, boolean | PrismaSelectResult>;
  where?: Record<string, unknown>;
  orderBy?: Record<string, unknown> | Record<string, unknown>[];
  skip?: number;
  take?: number;
  cursor?: Record<string, unknown>;
  distinct?: string[];
  [key: string]: unknown;
}

/**
 * Context passed to defaultFields and excludeFields functions
 * Provides information about the current position in the query tree
 */
export interface FieldsContext {
  /** Current model name being processed */
  modelName: string;
  /** Parent model name (undefined for root query) */
  parentModel?: string;
  /** Nesting depth (0 for root query) */
  depth: number;
}

export interface PrismaSelectOptions<
  ModelName extends string,
  ModelsObject extends Record<ModelName, Record<string, any>>,
> {
  /**
   * Object with models and fields to always include, even if not requested in GraphQL query.
   * @example
   * const defaultFields = {
   *    User: { id: true, name: true },
   *    Post: { id: true, body: true },
   *    // Function to conditionally add fields based on current selection
   *    Account: (select) => select.name ? { firstname: true, lastname: true } : {},
   *    // Function with context for conditional fields based on parent model
   *    Post: (select, ctx) => ctx.parentModel === 'User'
   *      ? { id: true, title: true }  // When fetched from User
   *      : { id: true, title: true, content: true }  // When fetched directly
   * }
   */
  defaultFields?: {
    [model in ModelName]?:
      | {
          [field in keyof ModelsObject[model]]?: boolean;
        }
      | ((
          select: Record<string, unknown>,
          context: FieldsContext,
        ) => { [field in keyof ModelsObject[model]]?: boolean });
  };
  /**
   * Object with models and fields to exclude, even if requested in GraphQL query.
   * @example
   * const excludeFields = {
   *    User: ['password', 'hash'],
   *    Post: ['internalNotes'],
   *    // Function to conditionally exclude fields
   *    Account: (select) => select.isAdmin ? [] : ['secretKey'],
   *    // Function with context
   *    User: (select, ctx) => ctx.depth > 1 ? ['posts'] : []  // Limit nesting
   * }
   */
  excludeFields?: {
    [model in ModelName]?:
      | (keyof ModelsObject[model] | string)[]
      | ((select: Record<string, unknown>, context: FieldsContext) => (keyof ModelsObject[model] | string)[]);
  };
  /**
   * Array of DMMF objects for field validation and filtering.
   *
   * **For Prisma 7+**: Use the DMMF from @paljs/generator output:
   * @example
   * ```typescript
   * import { dmmf } from './generated/paljs';
   *
   * new PrismaSelect<'User', ModelsObject>(info, {
   *   dmmf: [dmmf],
   * });
   * ```
   *
   * **For Prisma 6**: Use Prisma.dmmf from the client:
   * @example
   * ```typescript
   * import { Prisma } from '@prisma/client';
   *
   * new PrismaSelect(info, {
   *   dmmf: [Prisma.dmmf],
   * });
   * ```
   *
   * **Without DMMF**: PrismaSelect still works but field validation is skipped.
   * Invalid fields may be passed to Prisma (causing runtime errors).
   */
  dmmf?: Pick<DMMF.Document, 'datamodel'>[];

  /**
   * Interceptor function to modify `where` clauses for all queries.
   * Useful for implementing global filters like soft deletes, tenant isolation, or access control.
   *
   * @example Soft delete filter
   * ```typescript
   * new PrismaSelect(info, {
   *   whereInterceptor: (where, modelName) => ({
   *     ...where,
   *     deletedAt: null,  // Only return non-deleted records
   *   }),
   * });
   * ```
   *
   * @example Tenant isolation
   * ```typescript
   * new PrismaSelect(info, {
   *   whereInterceptor: (where, modelName, ctx) => {
   *     if (ctx.isRoot) {
   *       return { ...where, tenantId: currentTenantId };
   *     }
   *     return where;
   *   },
   * });
   * ```
   */
  whereInterceptor?: (
    where: Record<string, unknown>,
    modelName: string,
    context: { parentModel?: string; isRoot: boolean },
  ) => Record<string, unknown>;
}

/**
 * Convert GraphQL `info` to a Prisma select object.
 *
 * Supports both Prisma 6 and Prisma 7. For full type safety with Prisma 7,
 * use the types generated by @paljs/generator.
 *
 * @param info - GraphQLResolveInfo from resolver
 *
 * @example Basic usage (works with Prisma 6 and 7)
 * ```typescript
 * const select = new PrismaSelect(info);
 * const users = await prisma.user.findMany({
 *   ...args,
 *   ...select.value,
 * });
 * ```
 *
 * @example With typed models from @paljs/generator (Prisma 7)
 * ```typescript
 * import { dmmf, type ModelsObject, type ModelName } from './generated/paljs';
 *
 * const select = new PrismaSelect<ModelName, ModelsObject>(info, {
 *   dmmf: [dmmf],
 *   defaultFields: {
 *     User: { id: true, email: true },
 *   },
 * });
 *
 * // Fully typed - no more `any`!
 * const users = await prisma.user.findMany(select.value);
 * ```
 *
 * @example GraphQL query transformation
 * ```graphql
 * # GraphQL query
 * {
 *   findManyUser {
 *     id
 *     posts(where: { title: { contains: "a" } }, first: 10) {
 *       id
 *       comments { id }
 *     }
 *   }
 * }
 * ```
 *
 * ```typescript
 * // Transforms to Prisma select:
 * {
 *   select: {
 *     id: true,
 *     posts: {
 *       select: { id: true, comments: { select: { id: true } } },
 *       where: { title: { contains: "a" } },
 *       first: 10
 *     }
 *   }
 * }
 * ```
 */

export class PrismaSelect<
  ModelName extends string = '',
  ModelsObject extends Record<ModelName, Record<string, any>> = Record<ModelName, Record<string, any>>,
> {
  private availableArgs = ['where', 'orderBy', 'skip', 'cursor', 'take', 'distinct'];
  private allowedProps = ['_count'];
  private isAggregate = false;

  constructor(
    private info: GraphQLResolveInfo,
    private options?: PrismaSelectOptions<ModelName, ModelsObject>,
  ) {}

  get value(): PrismaSelectResult {
    const returnType = this.info.returnType.toString().replace(/]/g, '').replace(/\[/g, '').replace(/!/g, '');
    this.isAggregate = returnType.includes('Aggregate');
    return this.valueWithFilter(returnType);
  }

  get dataModel(): DMMF.Model[] {
    if (this.options?.dmmf) {
      const models: DMMF.Model[] = [];
      this.options?.dmmf.forEach((doc) => {
        models.push(...doc.datamodel.models);
      });
      return models;
    }
    return [];
  }

  get defaultFields() {
    return this.options?.defaultFields;
  }

  get excludeFields() {
    return this.options?.excludeFields;
  }

  private get fields() {
    return parseResolveInfo(this.info);
  }

  private static getModelMap(docs?: string, name?: string) {
    const value = docs?.match(/@PrismaSelect.map\(\[(.*?)]\)/);
    if (value && name) {
      const asArray = value[1]
        .replace(/ /g, '')
        .split(',')
        .filter((v) => v);
      return asArray.includes(name);
    }
    return false;
  }

  private model(name?: string) {
    return this.dataModel.find((item) => item.name === name || PrismaSelect.getModelMap(item.documentation, name));
  }

  private field(name: string, model?: DMMF.Model) {
    return model?.fields.find((item) => item.name === name);
  }

  static isObject(item: unknown): item is Record<string, unknown> {
    return item !== null && typeof item === 'object' && !Array.isArray(item);
  }

  static mergeDeep<T extends Record<string, unknown>>(target: T, ...sources: Record<string, unknown>[]): T {
    if (!sources.length) return target;
    const source = sources.shift();

    if (PrismaSelect.isObject(target) && PrismaSelect.isObject(source)) {
      for (const key in source) {
        if (PrismaSelect.isObject(source[key])) {
          if (!target[key]) Object.assign(target, { [key]: {} });
          PrismaSelect.mergeDeep(target[key] as Record<string, unknown>, source[key] as Record<string, unknown>);
        } else {
          Object.assign(target, { [key]: source[key] });
        }
      }
    }

    return PrismaSelect.mergeDeep(target, ...sources);
  }

  /**
   * Get nested value from a select object.
   * @param field - name of field in a select object.
   * @param filterBy - Model name as you have in schema.prisma file.
   * @param mergeObject
   * @example
   * // Graphql query
   * {
   *    findManyUser{
   *      id
   *      posts{
   *        id
   *        comments{
   *          id
   *        }
   *      }
   *    }
   * }
   *
   * // when you need to get more nested fields add `.`
   * PrismaSelect.valueOf('posts.comments', 'Comment');
   * // return
   * { select: { id: true } }
   *
   * PrismaSelect.valueOf('posts', 'Post');
   *
   * // return
   * { select: { id: true, comments: { select: { id: true } } } }
   *
   **/
  valueOf<M extends ModelName = ModelName>(
    field: string,
    filterBy?: M | string,
    mergeObject: Record<string, unknown> = {},
  ): PrismaSelectResult {
    const splitItem = field.split('.');
    let newValue: Record<string, unknown> = this.getSelect(this.fields);
    for (const field of splitItem) {
      if (this.isAggregate && Object.prototype.hasOwnProperty.call(newValue, field)) {
        newValue = newValue[field] as Record<string, unknown>;
      } else if (
        !this.isAggregate &&
        Object.prototype.hasOwnProperty.call(newValue, 'select') &&
        Object.prototype.hasOwnProperty.call((newValue as { select: Record<string, unknown> }).select, field)
      ) {
        newValue = (newValue as { select: Record<string, unknown> }).select[field] as Record<string, unknown>;
      } else {
        return {};
      }
    }
    return filterBy
      ? (PrismaSelect.mergeDeep(
          this.filterBy(filterBy, newValue, { modelName: filterBy, depth: 0 }),
          mergeObject,
        ) as PrismaSelectResult)
      : (newValue as PrismaSelectResult);
  }

  /**
   * Work with this method if your GraphQL type name not like Schema model name.
   * @param modelName - Model name as you have in schema.prisma file.
   * @example
   * // normal call
   * const select = new PrismaSelect(info).value
   *
   * // With filter will filter select object with provided schema model name
   * const select = new PrismaSelect(info).valueWithFilter('User');
   *
   **/
  valueWithFilter<M extends ModelName = ModelName>(modelName: M | string): PrismaSelectResult {
    return this.filterBy(modelName as string, this.getSelect(this.fields), {
      modelName: modelName as string,
      depth: 0,
    });
  }

  private filterBy(
    modelName: string,
    selectObject: Record<string, unknown>,
    context: FieldsContext = { modelName, depth: 0 },
  ): PrismaSelectResult {
    const model = this.model(modelName);
    const selectFields = selectObject.select as Record<string, unknown> | undefined;

    if (model && typeof selectObject === 'object' && selectFields) {
      let defaultFields: Record<string, boolean> = {};
      if (this.defaultFields && this.defaultFields[modelName]) {
        const modelFields = this.defaultFields[modelName];
        defaultFields = (
          typeof modelFields === 'function' ? modelFields(selectFields, context) : modelFields
        ) as Record<string, boolean>;
      }
      const filteredSelect: Record<string, unknown> = { ...defaultFields };

      // Apply whereInterceptor if present and there's a where clause
      let processedSelectObject = selectObject;
      if (this.options?.whereInterceptor && selectObject.where) {
        const interceptedWhere = this.options.whereInterceptor(
          selectObject.where as Record<string, unknown>,
          modelName,
          { parentModel: context.parentModel, isRoot: context.depth === 0 },
        );
        processedSelectObject = { ...selectObject, where: interceptedWhere };
      }

      const filteredObject: PrismaSelectResult = {
        ...processedSelectObject,
        select: filteredSelect as Record<string, boolean | PrismaSelectResult>,
      };

      for (const key in selectFields) {
        if (this.excludeFields && this.excludeFields[modelName]) {
          const modelExcludeFields = this.excludeFields[modelName];
          const excludeFields = (
            typeof modelExcludeFields === 'function' ? modelExcludeFields(selectFields, context) : modelExcludeFields
          ) as string[];
          if (excludeFields.includes(key)) continue;
        }

        if (this.allowedProps.includes(key)) {
          filteredSelect[key] = selectFields[key];
          continue;
        }

        const field = this.field(key, model);

        // Field not found in DMMF - this is a computed field (resolved by custom resolver)
        // Pass it through unchanged unless excluded
        if (!field) {
          filteredSelect[key] = selectFields[key];
          continue;
        }

        // Scalar or enum field - just select it
        if (field.kind !== 'object') {
          filteredSelect[key] = true;
          continue;
        }

        // Relation field - recursively filter with updated context
        const childContext: FieldsContext = {
          modelName: field.type,
          parentModel: modelName,
          depth: context.depth + 1,
        };
        const subModelFilter = this.filterBy(field.type, selectFields[key] as Record<string, unknown>, childContext);

        // Handle custom scalars or unsupported types that don't return an object with select
        if (typeof subModelFilter !== 'object' || subModelFilter === null || !('select' in subModelFilter)) {
          filteredSelect[key] = selectFields[key];
          continue;
        }

        const subSelect = subModelFilter.select as Record<string, unknown> | undefined;
        if (subSelect && Object.keys(subSelect).length > 0) {
          filteredSelect[key] = subModelFilter;
        }
      }
      return filteredObject;
    } else {
      return selectObject as PrismaSelectResult;
    }
  }

  private getArgs(args?: Record<string, unknown>): Record<string, unknown> {
    const filteredArgs: Record<string, unknown> = {};
    if (args) {
      this.availableArgs.forEach((key) => {
        if (args[key]) {
          filteredArgs[key] = args[key];
        }
      });
    }
    return filteredArgs;
  }

  private getSelect(fields: PrismaSelect['fields'], parent = true): Record<string, unknown> {
    const selectFields: Record<string, unknown> = {};
    const baseArgs = parent ? {} : this.getArgs(fields?.args);
    const selectObject: Record<string, unknown> = this.isAggregate ? {} : { select: selectFields, ...baseArgs };

    if (fields) {
      Object.keys(fields.fieldsByTypeName).forEach((type) => {
        const fieldsByTypeName = fields.fieldsByTypeName[type];
        Object.keys(fieldsByTypeName).forEach((key) => {
          const fieldName = fieldsByTypeName[key].name;
          if (Object.keys(fieldsByTypeName[key].fieldsByTypeName).length === 0) {
            if (this.isAggregate) {
              selectObject[fieldName] = true;
            } else {
              selectFields[fieldName] = true;
            }
          } else {
            if (this.isAggregate) {
              selectObject[fieldName] = this.getSelect(fieldsByTypeName[key], false);
            } else {
              selectFields[fieldName] = this.getSelect(fieldsByTypeName[key], false);
            }
          }
        });
      });
    }
    return selectObject;
  }
}
